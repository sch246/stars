<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ˜Ÿç½— (Stars v5.3)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.3.0/lib/marked.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050508; font-family: 'Segoe UI', sans-serif; color: #ddd; }
        #canvas { display: block; width: calc(100vw - var(--sidebar-width, 340px)); height: 100vh; cursor: crosshair; outline: none; }
        #sidebar { position: fixed; right: 0; top: 0; width: var(--sidebar-width, 340px); height: 100vh; background: #111114; border-left: 1px solid #2a2a30; padding: 25px; box-sizing: border-box; display: flex; flex-direction: column; z-index: 10; box-shadow: -5px 0 20px rgba(0,0,0,0.8); }
        #sidebar-resizer { position: fixed; right: var(--sidebar-width, 340px); top: 0; width: 8px; height: 100vh; background: #050508; cursor: ew-resize; z-index: 11; transition: background 0.2s; }
        #sidebar-resizer:hover { background: #4facfe; }
        input, textarea { background: transparent; border: none; color: #eee; outline: none; width: 100%; display: block; font-family: 'Segoe UI', sans-serif; }
        input::placeholder, textarea::placeholder { color: #444; font-style: italic; }
        #node-label { font-size: 28px; font-weight: 700; margin-bottom: 8px; color: #4facfe; border-bottom: 2px solid #2a2a30; padding-bottom: 8px; }
        #node-label:focus { border-bottom-color: #4facfe; }
        #node-uuid { font-size: 10px; color: #444; font-family: monospace; margin-bottom: 5px; user-select: all;}
        #link-status { font-size: 12px; font-family: monospace; margin-bottom: 15px; color: #666; font-weight: bold; display: flex; justify-content: space-between;}
        #node-summary { font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; background: #0d0d0f; border: 1px solid transparent; border-radius: 4px; padding: 5px; height: 60px; resize: vertical; }
        #node-summary:focus { border-color: #333; background: #151518; }
        #node-content { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 15px; resize: none; font-family: 'Consolas', 'Courier New', monospace; line-height: 1.7; border-radius: 6px; font-size: 13px; color: #ccc; }
        #node-content:focus { border-color: #4facfe; }
        #node-color-container { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        #node-color-input { width: 30px; height: 30px; background: transparent; border: none; cursor: pointer; padding: 0; }
        #node-color-hex { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 8px 10px; border-radius: 6px; font-size: 13px; color: #ccc; text-transform: uppercase; }
        #hud { position: fixed; top: 20px; left: 25px; pointer-events: none; z-index: 5; opacity: 0.9; display: flex; flex-direction: column; gap: 20px;}
        h1 { margin: 0; font-size: 18px; color: #555; letter-spacing: 2px; text-transform: uppercase; }
        .controls { font-size: 12px; color: #444; line-height: 1.6; font-family: monospace; }
        .key { color: #4facfe; font-weight: bold; background: rgba(79, 172, 254, 0.1); padding: 2px 4px; border-radius: 3px;}
        #slot-bar { display: flex; gap: 15px; pointer-events: auto; margin-top: 5px;}
        .slot { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; opacity: 0.6; transition: 0.3s; width: 60px; }
        .slot:hover { opacity: 1; transform: scale(1.1); }
        .slot.active { opacity: 1; }
        .slot-circle { width: 24px; height: 24px; border-radius: 50%; background: #333; border: 2px solid transparent; box-shadow: 0 0 5px rgba(0,0,0,0.5); transition: 0.3s; position: relative; }
        .slot-num { position: absolute; top: -5px; left: -5px; font-size: 10px; font-weight: bold; color: #666; background: #050508; padding: 1px 3px; border-radius: 4px; }
        .slot.active .slot-num { color: #4facfe; }
        .slot-name { font-size: 11px; color: #888; text-align: center; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .slot.active .slot-name { color: #ddd; font-weight: bold; }
        #view-controls { font-family: monospace; color: #666; font-size: 12px; }
        #layer-indicator { color: #4facfe; font-weight: bold; }
        #link-mode-indicator { display: none; font-size: 14px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); margin-top: 5px; }
        #link-mode-indicator.active { display: inline-block; animation: pulse-text 2s infinite; }
        @keyframes pulse-text { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
        .overlay-menu { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateX(-170px); background: #1a1a1d; border: 1px solid #444; padding: 15px; border-radius: 8px; display: none; flex-direction: column; gap: 6px; z-index: 50; box-shadow: 0 10px 30px rgba(0,0,0,1); min-width: 260px; }
        .overlay-menu.active { display: flex; }
        .menu-title { font-size: 12px; color: #888; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        .menu-opt { font-size: 13px; color: #ccc; padding: 8px 10px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: background 0.2s;}
        .menu-opt:hover, .menu-opt.selected { background: #333; color: #fff; }
        .menu-key { color: #4facfe; font-weight: bold; font-family: monospace; margin-right: 12px; min-width: 20px;}
        .menu-opt.delete-opt { color: #e74c3c; }
        #tooltip { position: absolute; opacity: 0; background: rgba(0, 0, 0, 0.9); padding: 10px 14px; border-radius: 4px; border-left: 3px solid #4facfe; pointer-events: none; color: #ddd; font-size: 12px; transition: opacity 0.15s; z-index: 100; max-width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.6);}
        #tooltip.fixed-mode { top: 70%; left: 50%; transform: translate(-50%, 0) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); text-align: center; border-left: none; border-top: 3px solid #4facfe; }
        #flash-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); padding: 15px 30px; border-radius: 8px; font-weight: bold; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 404; box-shadow: 0 0 30px rgba(0,0,0,0.5); text-transform: uppercase; letter-spacing: 1px; }
        #flash-message.info { background: rgba(0, 123, 255, 0.15); color: #4facfe; border: 1px solid #4facfe; }
        #flash-message.warn { background: rgba(255, 0, 0, 0.15); color: #ff4d4d; border: 1px solid #ff4d4d; }
        #content-modal { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.85); z-index: 300; justify-content: center; align-items: center; }
        #content-modal.active { display: flex; }
        #modal-body { background: #161619; width: 800px; max-width: 90%; height: 85%; border: 1px solid #333; border-radius: 8px; padding: 40px; box-sizing: border-box; overflow-y: auto; color: #ccc; box-shadow: 0 0 50px rgba(0,0,0,1); }
        #modal-body h1, #modal-body h2, #modal-body h3 { color: #fff; border-bottom: 1px solid #333; padding-bottom: 5px; margin-top: 20px;}
        #modal-body a { color: #4facfe; text-decoration: none; }
        #io-controls { position: fixed; bottom: 20px; left: 25px; z-index: 5; display: flex; gap: 10px; }
        button { background: #1a1a1d; color: #777; border: 1px solid #333; padding: 6px 12px; cursor: pointer; font-size: 11px; border-radius: 3px; transition: 0.2s; }
        button:hover { background: #333; color: #fff; border-color: #555; }
        #preset-editor { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #161619; border: 1px solid #333; border-radius: 8px; padding: 20px; width: 500px; max-width: 90%; z-index: 400; display: none; flex-direction: column; gap: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        #preset-editor.active { display: flex; }
        .preset-list { max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .preset-row { display: flex; gap: 10px; align-items: center; background: #0a0a0c; padding: 5px; border-radius: 4px; border: 1px solid #222; }
        .preset-row:hover { border-color: #444; }
        .preset-input { background: transparent; border: none; color: #ddd; font-family: monospace; font-size: 12px; padding: 4px; border-bottom: 1px solid transparent; }
        .preset-input:focus { border-bottom-color: #4facfe; }
        .preset-color { width: 25px; height: 25px; border: none; background: none; cursor: pointer; padding: 0; }
        .preset-idx { color: #4facfe; font-weight: bold; font-family: monospace; width: 20px; text-align: center; user-select: none; }
        .preset-del { color: #e74c3c; cursor: pointer; font-weight: bold; padding: 0 5px; user-select: none; }
        .preset-del:hover { color: #ff6b6b; }
        .preset-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px; }
        .btn-primary { background: #2980b9; color: white; border-color: #3498db; }
        .btn-primary:hover { background: #3498db; }
        #modal-body code { background: #282c34; padding: 3px 6px; border-radius: 4px; font-family: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace; color: #abb2bf; font-size: 0.95em; }
        #modal-body pre { background: #282c34; padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 1em; margin-bottom: 1em; }
        #modal-body pre code { background: none; padding: 0; font-size: 1em; color: #abb2bf; line-height: 1.5; }
        #custom-dialog-overlay {
            display: none;
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 500;
            align-items: center; justify-content: center;
        }
        #custom-dialog-overlay.active { display: flex; }

        #custom-dialog {
            background: #1a1a1d; border: 1px solid #444; border-radius: 8px;
            padding: 20px; width: 320px; box-shadow: 0 10px 40px rgba(0,0,0,0.9);
            display: flex; flex-direction: column; gap: 15px;
        }
        #custom-dialog-msg { font-size: 14px; color: #ddd; line-height: 1.5; text-align: center; }
        #custom-dialog-input {
            background: #0a0a0c; border: 1px solid #333; padding: 8px;
            border-radius: 4px; width: 100%; box-sizing: border-box;
            color: #fff; display: none; /* é»˜è®¤éšè— */
        }
        #custom-dialog-input:focus { border-color: #4facfe; }
        #custom-dialog-buttons { display: flex; justify-content: center; gap: 10px; } /* æŒ‰é’®å±…ä¸­ */
        #search-controls {
            position: fixed;
            bottom: 20px;
            right: calc(var(--sidebar-width, 340px) + 30px); /* ç´§è´´ä¾§è¾¹æ å·¦ä¾§ */
            width: 200px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 20;
        }
        .search-input {
            background: rgba(10, 10, 12, 0.8);
            border: 1px solid #333;
            padding: 8px 10px;
            border-radius: 4px;
            color: #ddd;
            font-size: 12px;
            font-family: monospace;
            transition: 0.2s;
            backdrop-filter: blur(4px);
        }
        .search-input:focus {
            border-color: #4facfe;
            background: rgba(20, 20, 25, 0.95);
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.2);
        }
        .search-input::placeholder { color: #555; }
    </style>
</head>
<body>

<div id="search-controls">
    <input type="text" id="inp-jump" class="search-input" placeholder="Jump to Node (Enter)">
    <input type="text" id="inp-filter-node" class="search-input" placeholder="Filter Nodes Regex (Enter)">
    <input type="text" id="inp-filter-link" class="search-input" placeholder="Filter Links Regex (Enter)">
</div>
<div id="hud">
    <h1 id="app-title">æ˜Ÿç½— <span style="font-size:10px; opacity:0.5">v5.3</span></h1>
    <div id="slot-bar">
        <div class="slot" id="slot-1" data-index="0"><div class="slot-circle"><span class="slot-num">1</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-2" data-index="1"><div class="slot-circle"><span class="slot-num">2</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-3" data-index="2"><div class="slot-circle"><span class="slot-num">3</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-4" data-index="3"><div class="slot-circle"><span class="slot-num">4</span></div><span class="slot-name">-</span></div>
    </div>

    <div id="view-controls">
        <span id="txt-view-range">è§†é‡èŒƒå›´:</span> <span id="layer-indicator">1</span> <span id="txt-layers">å±‚</span>
        <span id="txt-adjust">(æŒ‰ +/- è°ƒæ•´)</span><br>
        <span id="txt-visible">å½“å‰å¯è§:</span> <span id="visible-count">0</span> <span id="txt-nodes">èŠ‚ç‚¹</span>
    </div>

    <div id="link-mode-indicator">...</div> <!-- å†…å®¹ä¼šåœ¨JSé‡Œåˆå§‹åŒ– -->

    <!-- æŒ‰é”®å¸®åŠ©ï¼šå†…å®¹ä¼šè¢« JS çš„ apply() è¦†ç›–ï¼Œè¿™é‡Œå¯ä»¥ç•™ç©º -->
    <div id="key-controls" class="controls"></div>
</div>

<div id="flash-message"></div>
<div id="relation-picker" class="overlay-menu"></div>

<div id="preset-editor">
    <div class="menu-title">
        <span id="pe-title">é¢„è®¾å…³ç³»ç¼–è¾‘å™¨</span>
        <span style="float:right; cursor:pointer" onclick="App.UI.PresetEditor.close()">âœ•</span>
    </div>
    <div class="controls" id="pe-desc" style="margin-bottom:10px; color:#666;">...</div>
    <div class="preset-list" id="preset-list-container"></div>
    <div class="preset-actions">
        <button id="pe-btn-add" onclick="App.UI.PresetEditor.add()">+ æ–°å¢</button>
        <button id="pe-btn-save" class="btn-primary" onclick="App.UI.PresetEditor.saveAndClose()">ä¿å­˜</button>
    </div>
</div>

<div id="content-modal"><div id="modal-body"></div></div>

<div id="io-controls">
    <button id="btn-save" onclick="App.Store.save()">ä¿å­˜</button>
    <button id="btn-export" onclick="App.Store.exportData()">å¯¼å‡º</button>
    <button id="btn-reset" onclick="App.Store.resetSystem()">é‡ç½®</button>
    <input type="file" id="importFile" style="display:none" onchange="App.Store.importData(this)">
    <button id="btn-import" onclick="document.getElementById('importFile').click()">å¯¼å…¥</button>
    <button id="btn-lang" onclick="App.I18n.toggle()">ğŸŒ English</button>
    <button id="btn-preset" onclick="App.UI.PresetEditor.open()">é¢„è®¾</button>
</div>

<div id="sidebar">
    <input type="text" id="node-label" placeholder="æ¦‚å¿µåç§°">
    <div id="node-uuid">UUID: -</div>
    <div id="link-status">è¿æ¥æ•°: -</div>
    <textarea id="node-summary" placeholder="ç®€çŸ­æ‘˜è¦ (Markdown/HTML)..."></textarea>
    <div id="node-color-container">
        <input type="color" id="node-color-input">
        <input type="text" id="node-color-hex" placeholder="#FFFFFF">
    </div>
    <textarea id="node-content" placeholder="è¯¦ç»†ç¬”è®° (Markdownæ”¯æŒ)..."></textarea>
</div>
<div id="sidebar-resizer"></div>
<div id="tooltip"></div>
<canvas id="canvas"></canvas>

<div id="custom-dialog-overlay">
<div id="custom-dialog">
    <div id="custom-dialog-msg"></div>
    <input type="text" id="custom-dialog-input" placeholder="">
    <div id="custom-dialog-buttons">
        <button id="btn-cancel">å–æ¶ˆ</button>
        <button id="btn-confirm" class="btn-primary">ç¡®å®š</button>
    </div>
</div>
</div>

<script>
/**
 * Stars v5.3
 * Single File Modular Architecture
 */
const App = {};

// ==========================================
// 0. I18n (å›½é™…åŒ–)
// ==========================================
App.I18n = {
    lang: 'en', // é»˜è®¤
    data: {
        "en": {
            "hud.title": "Stars <span style='font-size:10px; opacity:0.5'>v5.3</span>", // ç‰¹æ®Šå¤„ç†å¸¦HTMLçš„æ ‡é¢˜
            "hud.viewLayers": "View Range:",
            "hud.layers": "Layers",
            "hud.adjust": "(+/- to adjust)",
            "hud.visible": "Visible:",
            "hud.nodes": "nodes",
            "hud.linkMode": "ğŸ”— Link Mode: Jump to connect / Esc to cancel",
            "hud.controls": `
                <span class="key">L</span> <span class="key">Fwd Btn</span> New Rel. <span class="key">N</span> New Node <span class="key">Tab</span> <span class="key">Dbl Click</span> New & Connect<br>
                <span class="key">Del</span> <span class="key">X</span> <span class="key">R Click</span> Del Rel/Node<br>
                <span class="key">(shift)WASD</span> <span class="key">(shift)â†‘â†â†“â†’</span> <span class="key">(/?)</span> <span class="key">L Click</span> (Path Aligned) Move <br>
                <span class="key">Space</span> Edit <span class="key">Enter</span> <span class="key">L Click Focus</span> View<br>
                <span class="key">(Shift)1-4</span> (Save) Swap <span class="key">H</span> Home <span class="key">B</span> <span class="key">Back Btn</span> Back<br>
                <span class="key">(shift)Q E</span> <span class="key">(shift)< ></span> (Free Rotate) Prev. Neighbors<br>
                <span class="key">\`</span> Rel. Presets <span class="key">I</span> Hide Tip
            `,
            "btn.save": "Save",
            "btn.export": "Export",
            "btn.reset": "Reset System",
            "btn.import": "Import",
            "btn.language": "ğŸŒ English",
            "btn.presets": "Manage Presets",
            "sidebar.placeholder.label": "Concept Name",
            "sidebar.placeholder.summary": "Short summary (Markdown/HTML)...",
            "sidebar.placeholder.content": "Detailed notes (Markdown supported)...",
            "modal.noContent": "*No content available*",
            "modal.close": "Press ESC to close",
            "alert.resetConfirm": "Resetting the system will clear all data. Are you sure?",
            "alert.deleteConfirm": "Warning: This action will cause {n} nodes to be lost (e.g., {label}...). Continue?",
            "alert.importSuccess": "Data imported successfully",
            "alert.importFail": "Invalid import file format",
            "alert.parseFail": "Failed to parse imported file.",
            "alert.presetValueEmpty": "Preset 'Value' cannot be empty.",
            "alert.presetValueDuplicate": "Preset 'Value' cannot be duplicated.",
            "alert.presetExceedMax": "Maximum number of presets reached.",
            "alert.noLinkToBreak": "No link to break.",
            "alert.rootCannotDelete": "The root node cannot be deleted.",
            "flash.presetUpdated": "Presets updated.",
            "flash.linkCut": "Link cut.",
            "flash.noHistory": "No more history to navigate back to.",
            "linkMode.prompt": "Enter link relationship name or val:",
            "linkMode.promptPlaceholder": "e.g., contains, defined as...",
            "linkMode.typeIndicator": "ğŸ”— <span style='color:{color};'>Link Mode: {type} (Jump to connect / Esc to cancel)</span>",
            "linkMode.deleteLabel": "Delete/Break Link",
            "preset.title": "1. Select Type <span style='font-weight:normal; color:#888;'>(Space Custom{deleteFragment})</span>",
            "preset.menuTitle": "Preset Relationship Editor",
            "preset.menuDesc": "Define common connection types. Press Enter to save.",
            "preset.btnAdd": "+ Add Preset",
            "preset.btnSave": "Save & Apply",
            "preset.input.label": "Display Name (Label)",
            "preset.input.value": "Data Value (Value)",
            "preset.delete": ", D Delete",
            "preset.more": "More",
            "preset.default.includes": "Includes...",
            "preset.default.definedAs": "Defined as...",
            "preset.default.intuitive": "Intuitive understanding",
            "preset.default.calculates": "Calculates...",
            "preset.default.implies": "Implies...",
            "preset.default.orthogonalTo": "Orthogonal to...",
            "fallback.origin": "Origin",
            "fallback.summary": "Workspace Root",
            "fallback.content": "Welcome to Stars in Web. Start exploring!",
            "fallback.newNode": "New Concept",
            "fallback.newRelationship": "New Relationship",
            "dialog.confirm": "Confirm",
            "dialog.cancel": "Cancel",
            "tooltip.preview": "<strong>Preview: {label}</strong><br>{summary}<br><span style='color:#af4cae'>Press <span class=\"key\">â†‘</span> <span class=\"key\">/</span> to Jump</span>",
            "tooltip.click": "<span style='color:#666'>Click to Jump</span>",
            "tooltip.nodeHover": "<strong>{label}</strong><br>{summary}<br><span style='color:#666'>Click to Jump</span>",
            "status.saved": "Stars: Saved.",
            "status.noWorkspace": "Stars: Please open a folder to save data.",
            "input.jump": "Jump to Node (Enter)",
            "input.filterNode": "Filter Nodes Regex (Enter)",
            "input.filterLink": "Filter Links Regex (Enter)",
        },
        "zh-cn": {
            "hud.title": "æ˜Ÿç½— <span style='font-size:10px; opacity:0.5'>v5.3</span>",
            "hud.viewLayers": "è§†é‡èŒƒå›´:",
            "hud.layers": "å±‚",
            "hud.adjust": "(æŒ‰ +/- è°ƒæ•´)",
            "hud.visible": "å½“å‰å¯è§:",
            "hud.nodes": "èŠ‚ç‚¹",
            "hud.linkMode": "ğŸ”— è¿çº¿æ¨¡å¼: è·³è½¬ä»¥è¿æ¥/Esc å–æ¶ˆ",
            "hud.controls": `
                <span class="key">L</span> <span class="key">å‰ä¾§é”®</span> æ–°å»ºå…³ç³» <span class="key">N</span> æ–°å»ºèŠ‚ç‚¹ <span class="key">Tab</span> <span class="key">åŒå‡»</span> æ–°å»ºå¹¶è¿æ¥èŠ‚ç‚¹<br>
                <span class="key">Del</span> <span class="key">X</span> <span class="key">å³é”®</span> åˆ é™¤å…³ç³»/èŠ‚ç‚¹<br>
                <span class="key">(shift)WASD</span> <span class="key">(shift)â†‘â†â†“â†’</span> <span class="key">(/?)</span> <span class="key">å·¦é”®</span> (æ²¿è·¯å¾„)ç§»åŠ¨ <br>
                <span class="key">Space</span> ç¼–è¾‘ <span class="key">Enter</span> <span class="key">å·¦é”®ç„¦ç‚¹</span> æŸ¥çœ‹<br>
                <span class="key">(Shift)1-4</span> (å­˜å…¥)äº¤æ¢ <span class="key">H</span> å›å®¶ <span class="key">B</span> <span class="key">åä¾§é”®</span> åé€€<br>
                <span class="key">(shift)Q E</span> <span class="key">(shift)< ></span> (è‡ªç”±æ—‹è½¬)é¢„è§ˆé‚»å±…<br>
                <span class="key">\`</span> å…³ç³»é¢„è®¾ <span class="key">I</span> éšè—æ­¤æç¤º
            `,
            "btn.save": "ä¿å­˜",
            "btn.export": "å¯¼å‡º",
            "btn.reset": "é‡ç½®ç³»ç»Ÿ",
            "btn.import": "å¯¼å…¥",
            "btn.language": "ğŸŒ ä¸­æ–‡",
            "btn.presets": "é¢„è®¾ç®¡ç†",
            "sidebar.placeholder.label": "æ¦‚å¿µåç§°",
            "sidebar.placeholder.summary": "ç®€çŸ­æ‘˜è¦ (Markdown/HTML)...",
            "sidebar.placeholder.content": "è¯¦ç»†ç¬”è®° (Markdownæ”¯æŒ)...",
            "modal.noContent": "*æš‚æ— æ­£æ–‡å†…å®¹*",
            "modal.close": "æŒ‰ ESC å…³é—­",
            "alert.resetConfirm": "é‡ç½®ç³»ç»Ÿå°†æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Œç¡®å®šå—ï¼Ÿ",
            "alert.deleteConfirm": "è­¦å‘Šï¼šæ­¤æ“ä½œå°†å¯¼è‡´ {n} ä¸ªèŠ‚ç‚¹ä¸¢å¤±ï¼ˆå¦‚ {label}...ï¼‰ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ",
            "alert.importSuccess": "æ•°æ®å¯¼å…¥æˆåŠŸ",
            "alert.importFail": "å¯¼å…¥æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®",
            "alert.parseFail": "è§£æå¯¼å…¥æ–‡ä»¶å¤±è´¥ã€‚",
            "alert.presetValueEmpty": "é¢„è®¾çš„â€œæ•°æ®å€¼â€ä¸èƒ½ä¸ºç©ºã€‚",
            "alert.presetValueDuplicate": "é¢„è®¾çš„â€œæ•°æ®å€¼â€ä¸èƒ½é‡å¤ã€‚",
            "alert.presetExceedMax": "é¢„è®¾æ•°é‡å·²è¾¾ä¸Šé™ã€‚",
            "alert.noLinkToBreak": "æ— è¿æ¥å¯æ–­å¼€ã€‚",
            "alert.rootCannotDelete": "åˆå§‹å¥‡ç‚¹ä¸å¯åˆ é™¤ã€‚",
            "flash.presetUpdated": "é¢„è®¾å·²æ›´æ–°ã€‚",
            "flash.linkCut": "é“¾æ¥å·²åˆ‡æ–­ã€‚",
            "flash.noHistory": "æ²¡æœ‰æ›´å¤šå†å²è®°å½•å¯å›é€€ã€‚",
            "linkMode.prompt": "è¯·è¾“å…¥é“¾æ¥å…³ç³»åç§°æˆ–æ•°æ®å€¼:",
            "linkMode.promptPlaceholder": "ä¾‹å¦‚: åŒ…å«, å®šä¹‰ä¸º...",
            "linkMode.typeIndicator": "ğŸ”— <span style='color:{color};'>è¿çº¿æ¨¡å¼: {type} (è·³è½¬ä»¥è¿æ¥/Esc å–æ¶ˆ)</span>",
            "linkMode.deleteLabel": "åˆ é™¤/æ–­å¼€è¿æ¥",
            "preset.title": "1. é€‰æ‹©ç±»å‹ <span style='font-weight:normal; color:#888;'>(Space è‡ªå®šä¹‰{deleteFragment})</span>",
            "preset.menuTitle": "é¢„è®¾å…³ç³»ç¼–è¾‘å™¨",
            "preset.menuDesc": "å®šä¹‰å¸¸ç”¨çš„è¿æ¥ç±»å‹ã€‚æŒ‰ Enter ä¿å­˜ã€‚",
            "preset.btnAdd": "+ æ–°å¢é¢„è®¾",
            "preset.btnSave": "ä¿å­˜å¹¶åº”ç”¨",
            "preset.input.label": "æ˜¾ç¤ºåç§° (Label)",
            "preset.input.value": "æ•°æ®å€¼ (Value)",
            "preset.delete": ", D åˆ é™¤",
            "preset.more": "æ›´å¤š",
            "preset.default.includes": "åŒ…å«...",
            "preset.default.definedAs": "å®šä¹‰ä¸º...",
            "preset.default.intuitive": "ç›´è§‚ç†è§£",
            "preset.default.calculates": "è®¡ç®—...",
            "preset.default.implies": "æ„å‘³ç€...",
            "preset.default.orthogonalTo": "ä¸...æ­£äº¤",
            "fallback.origin": "èµ·æº",
            "fallback.summary": "å·¥ä½œåŒºæ ¹èŠ‚ç‚¹",
            "fallback.content": "æ¬¢è¿ä½¿ç”¨ Web ä¸­çš„æ˜Ÿç½—ç³»ç»Ÿã€‚",
            "fallback.newNode": "æ–°æ¦‚å¿µ",
            "fallback.newRelationship": "æ–°å…³ç³»",
            "dialog.confirm": "ç¡®å®š",
            "dialog.cancel": "å–æ¶ˆ",
            "tooltip.preview": "<strong>é¢„è§ˆ: {label}</strong><br>{summary}<br><span style='color:#af4cae'>æŒ‰ <span class=\"key\">â†‘</span> <span class=\"key\">/</span> è·³è½¬</span>",
            "tooltip.click": "<span style='color:#666'>ç‚¹å‡»è·³è½¬</span>",
            "tooltip.nodeHover": "<strong>{label}</strong><br>{summary}<br><span style='color:#666'>ç‚¹å‡»è·³è½¬</span>",
            "status.saved": "æ˜Ÿç½—: å·²ä¿å­˜ã€‚",
            "status.noWorkspace": "æ˜Ÿç½—: è¯·å…ˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶å¤¹ä»¥ä¿å­˜æ•°æ®ã€‚",
            "input.jump": "æŒ‰åç§°è·³è½¬ (å›è½¦)",
            "input.filterNode": "æ­£åˆ™ç­›é€‰èŠ‚ç‚¹ (å›è½¦)",
            "input.filterLink": "æ­£åˆ™ç­›é€‰è¿çº¿ (å›è½¦)",
        }
    },
    init() {
        const savedLang = localStorage.getItem('stars_lang');

        if (savedLang) {
            this.lang = savedLang;
        } else {
            // 2. å¦‚æœæ²¡æœ‰å­˜æ¡£ï¼Œå†æ£€æµ‹æµè§ˆå™¨
            const navLang = (navigator.language || navigator.userLanguage).toLowerCase();
            if (navLang.startsWith('zh')) this.lang = 'zh-cn';
            else this.lang = 'en';
        }

        console.log("Stars I18n Initialized:", this.lang);
        this.apply();
    },
    toggle() {
        // åˆ‡æ¢çŠ¶æ€
        this.lang = (this.lang === 'zh-cn') ? 'en' : 'zh-cn';

        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('stars_lang', this.lang);

        // åº”ç”¨æ›´æ”¹
        this.apply();

        // å¯é€‰ï¼šå¼¹å‡ºæç¤º
        App.UI.showFlash((this.lang === 'zh-cn' ? "è¯­è¨€: ä¸­æ–‡" : "Language: English"));
    },
    t(key, params = {}) {
        const dict = this.data[this.lang] || this.data['en'];
        let str = dict[key] || key;
        Object.keys(params).forEach(k => {
            str = str.replace(new RegExp(`{${k}}`, 'g'), params[k]);
        });
        return str;
    },
    apply() {
        const setText = (id, key) => { const el = document.getElementById(id); if(el) el.innerHTML = this.t(key); };
        const setPh = (id, key) => { const el = document.getElementById(id); if(el) el.placeholder = this.t(key); };
        // æ›¿æ¢ HTML ä¸­çš„é™æ€æ–‡æœ¬
        setText('app-title', 'hud.title');
        setText('txt-view-range', 'hud.viewLayers');
        setText('txt-layers', 'hud.layers');
        setText('txt-adjust', 'hud.adjust');
        setText('txt-visible', 'hud.visible');
        setText('txt-nodes', 'hud.nodes');
        setText('key-controls', 'hud.controls');

        setText('btn-save', 'btn.save');
        setText('btn-export', 'btn.export');
        setText('btn-reset', 'btn.reset');
        setText('btn-import', 'btn.import');
        setText('btn-lang', 'btn.language');
        setText('btn-preset', 'btn.presets');

        setPh('node-label', 'sidebar.placeholder.label');
        setPh('node-summary', 'sidebar.placeholder.summary');
        setPh('node-content', 'sidebar.placeholder.content');

        // é¢„è®¾ç¼–è¾‘å™¨
        setText('pe-title', 'preset.menuTitle');
        setText('pe-desc', 'preset.menuDesc');
        setText('pe-btn-add', 'preset.btnAdd');
        setText('pe-btn-save', 'preset.btnSave');

        App.Input.updateLinkModeIndicator(); // åˆ·æ–°è¿çº¿æ¨¡å¼æç¤º

        setPh('inp-jump', 'input.jump');
        setPh('inp-filter-node', 'input.filterNode');
        setPh('inp-filter-link', 'input.filterLink');
    }
};
// å¿«æ·æ–¹å¼ï¼Œæ–¹ä¾¿è°ƒç”¨
const t = (k, p) => App.I18n.t(k, p);

// ==========================================
// 1. Utils (å·¥å…·å‡½æ•°)
// ==========================================
App.Utils = {
    debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },
    getRandomColor() {
        const h = Math.random(); const s = Math.random(); const v = 1; let r, g, b;
        const i = Math.floor(h * 6); const f = h * 6 - i; const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break;
        }
        const toHex = (c) => Math.round(c * 255).toString(16).padStart(2, '0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    },
    findReachable(allNodes, allLinks, startNodes) {
        const reachable = new Set();
        const queue = [];
        startNodes.forEach(s => {
            if (s && !reachable.has(s.uuid)) {
                const exists = allNodes.find(n => n.uuid === s.uuid);
                if(exists) { reachable.add(s.uuid); queue.push(exists); }
            }
        });
        const adj = {};
        allLinks.forEach(l => {
            const s = l.source.uuid || l.source;
            const t = l.target.uuid || l.target;
            if(!adj[s]) adj[s] = []; adj[s].push(t);
            if(!adj[t]) adj[t] = []; adj[t].push(s);
        });
        let head = 0;
        while(head < queue.length) {
            const curr = queue[head++];
            const neighbors = adj[curr.uuid] || [];
            neighbors.forEach(nid => {
                if (!reachable.has(nid)) {
                    reachable.add(nid);
                    const nodeObj = allNodes.find(n => n.uuid === nid);
                    if(nodeObj) queue.push(nodeObj);
                }
            });
        }
        return reachable;
    }
};

// ==========================================
// 2. Store (æ•°æ®æ ¸å¿ƒ & å®‰å…¨é€»è¾‘)
// ==========================================
App.Store = {
    state: {
        nodes: [],
        links: [],
        slots: [null, null, null, null],
        focusNode: null,
        viewLayers: 1,
        navHistory: [],
        presets: [],
        filterNodeStr: "",
        filterLinkStr: "",
    },

    get DEFAULT_PRESETS () {
        return [
            { label: t('preset.default.includes'), val: 'comp', color: '#0062ff' },
            { label: t('preset.default.definedAs'), val: 'def', color: '#00ff00' },
            { label: t('preset.default.intuitive'), val: 'ins', color: '#33ffff' },
            { label: t('preset.default.calculates'), val: 'calc', color: '#ffaa00' },
            { label: t('preset.default.implies'), val: 'impl', color: '#bd00ff' },
            { label: t('preset.default.orthogonalTo'), val: 'orth', color: '#ff0055' },
        ];
    },

    pushHistory(node) {
        if(node) {
            this.state.navHistory.push(node);
            if(this.state.navHistory.length > 50) {
                this.state.navHistory.shift();
            }
        }
    },

    getBackNodeIndex() {
        let {focusNode, navHistory, nodes} = this.state;
        // ç­–ç•¥ï¼šå€’åºéå†å†å²ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªâ€œæ—¢ä¸æ˜¯å½“å‰çš„èŠ‚ç‚¹ï¼ŒåˆçœŸå®å­˜åœ¨äº nodes åˆ—è¡¨â€çš„èŠ‚ç‚¹
        for (let i = navHistory.length - 1; i >= 0; i--) {
            const hNode = navHistory[i];
            // æ’é™¤æ‰è‡ªå·±
            if (hNode.uuid === focusNode.uuid) continue;
            // ç¡®ä¿è¿™ä¸ªå†å²èŠ‚ç‚¹è¿˜â€œæ´»ç€â€
            if (nodes.find(n => n.uuid === hNode.uuid)) return i;
        }
        return -1;
    },

    loadState(payload, shouldSave = false) {
        // 1. æ¸…ç†æ—§çŠ¶æ€
        App.Runtime.clearAllStorage();
        this.state.navHistory = [];
        // 2. å¤„ç†ç©ºæ•°æ®æƒ…å†µ (å›é€€åˆ°åˆ›å»ºæ ¹èŠ‚ç‚¹)
        if (!payload || !payload.data || !payload.data.nodes) {
            this.createRoot();
            if (shouldSave) this.save();
            return;
        }
        // 3. è§£æåŸºç¡€æ•°æ®
        // å…¼å®¹ä¸¤ç§ presets å†™æ³•
        this.state.presets = (payload.presets && Array.isArray(payload.presets))
            ? payload.presets
            : this.DEFAULT_PRESETS;
        this.state.viewLayers = payload.viewLayers || 1;
        // 4. é‡å»ºå¯¹è±¡å¼•ç”¨ (æ ¸å¿ƒé€»è¾‘)
        // æ— è®ºæ•°æ®æºæ˜¯å¯¹è±¡è¿˜æ˜¯å­—ç¬¦ä¸²ï¼Œè¿™é‡Œéƒ½ç»Ÿä¸€å¤„ç†
        // ä½¿ç”¨ Map ç¡®ä¿ O(1) æŸ¥æ‰¾
        const nodeMap = new Map(payload.data.nodes.map(n => [n.uuid, { ...n }])); // æµ…æ‹·è´é˜²æ­¢æ±¡æŸ“æºæ•°æ®
        // åˆå§‹åŒ–èŠ‚ç‚¹ç‰©ç†çŠ¶æ€
        nodeMap.forEach(n => {
            if (n.x == null || isNaN(n.x)) n.x = (Math.random() - 0.5) * 50;
            if (n.y == null || isNaN(n.y)) n.y = (Math.random() - 0.5) * 50;
            n.alpha = 0; n.vx = 0; n.vy = 0; n.fx = null; n.fy = null;
            if (n.isRoot) { n.fx = 0; n.fy = 0; }
        });
        this.state.nodes = Array.from(nodeMap.values());
        // æ¢å¤è¿çº¿å¼•ç”¨
        this.state.links = (payload.data.links || []).map(l => ({
            source: nodeMap.get(typeof l.source === 'object' ? l.source.uuid : l.source) || l.source,
            target: nodeMap.get(typeof l.target === 'object' ? l.target.uuid : l.target) || l.target,
            type: l.type,
            alpha: 0
        })).filter(l => l.source && l.target && typeof l.source !== 'string' && typeof l.target !== 'string');
        // æ¢å¤æ’æ§½å¼•ç”¨
        this.state.slots = (payload.slots || [null, null, null, null])
            .map(uuid => uuid ? nodeMap.get(uuid) : null);
        // 5. è®¾ç½®ç„¦ç‚¹èŠ‚ç‚¹ (Focus Node)
        this.state.focusNode = payload.focusNodeUuid
            ? nodeMap.get(payload.focusNodeUuid)
            : (this.state.nodes.find(n => n.isRoot) || this.state.nodes[0]);
        // å…œåº•ï¼šå¦‚æœæ²¡æœ‰ç„¦ç‚¹èŠ‚ç‚¹ï¼Œåˆ›å»ºä¸€ä¸ª
        if (!this.state.focusNode) {
            this.createRoot();
        } else {
            this.state.focusNode.alpha = 1;
        }
        // 6. è®¡ç®—åˆå§‹å¯è§æ€§ (BFS)
        // è¿™ä¸€æ­¥æ˜¯ä¸ºäº†è®©é¦–å±æ¸²æŸ“ä¸è‡³äºå…¨é»‘ï¼Œä¸”ä¸éœ€è¦ç­‰ç‰©ç†æ¨¡æ‹Ÿè·‘å¤ªä¹…
        if (this.state.focusNode) {
            const initVis = new Set([this.state.focusNode.uuid]);
            const q = [{n: this.state.focusNode, d: 0}];
            let h = 0;

            // å»ºç«‹ä¸´æ—¶é‚»æ¥è¡¨åŠ é€ŸæŸ¥æ‰¾
            const adj = {};
            this.state.links.forEach(l => {
                const s = l.source.uuid, t = l.target.uuid;
                if(!adj[s]) adj[s] = []; adj[s].push(t);
                if(!adj[t]) adj[t] = []; adj[t].push(s);
            });
            while(h < q.length) {
                const {n, d} = q[h++];
                if(d >= this.state.viewLayers) continue;
                (adj[n.uuid] || []).forEach(neighborUuid => {
                    if (!initVis.has(neighborUuid)) {
                        initVis.add(neighborUuid);
                        const neighborNode = nodeMap.get(neighborUuid);
                        if (neighborNode) {
                            neighborNode.alpha = 1;
                            q.push({n: neighborNode, d: d+1});
                        }
                    }
                });
            }
        }
        // 7. é‡ç½®è§†å›¾ä½ç½® (Camera)
        if (App.Renderer.width > 0 && this.state.focusNode) {
            App.Renderer.viewX = -this.state.focusNode.x * App.Renderer.viewK + App.Renderer.width/2;
            App.Renderer.viewY = -this.state.focusNode.y * App.Renderer.viewK + App.Renderer.height/2;
        }
        // 8. åˆ·æ–° UI å’Œ æ¨¡æ‹Ÿå™¨
        App.UI.updateSidebar();
        App.UI.updateSlotUI();
        App.Renderer.adjustZoomByLayer(); // ç¡®ä¿ç¼©æ”¾çº§åˆ«æ­£ç¡®
        App.Renderer.restartSim();

        // é¢„çƒ­æ¨¡æ‹Ÿ (è®©èŠ‚ç‚¹ç¨å¾®æ•£å¼€ä¸€ç‚¹)
        for(let i=0; i<30; i++) App.Renderer.simulation.tick();
        this.save();
    },

    // åˆå§‹åŒ–ç³»ç»Ÿ
    init() {
        const saved = localStorage.getItem('stars_v5');
        if (saved) {
            try {
                const raw = JSON.parse(saved);
                this.loadState(raw, true); // æŠ½è±¡å‡ºåŠ è½½é€»è¾‘
            } catch(e) { console.error("Load error:", e); this.createRoot(); }
        } else { this.createRoot(); }

        if(!this.state.focusNode){ this.createRoot(); this.state.focusNode = this.state.nodes[0]; }
        this.state.focusNode.alpha = 1;

        App.UI.updateSidebar();
        App.UI.updateSlotUI();
        App.Renderer.adjustZoomByLayer();
        App.Renderer.restartSim();
    },

    createRoot() {
        const rootUUID = uuid.v4();
        const root = {
            uuid: rootUUID,
            label: t('fallback.origin'),
            isRoot: true,
            x: 0, y: 0,
            fx: 0, fy: 0,
            summary: t('fallback.summary'),
            content: t('fallback.content'),
            color: "#ffffff",
            alpha: 1
        };
        this.state.nodes = [root];
        this.state.links = [];
        this.state.slots = [null, null, null, null];
        this.state.focusNode = root;
        this.state.viewLayers = 1;
        this.state.navHistory = []; // æ–°å»ºæ ¹èŠ‚ç‚¹æ—¶æ¸…ç©ºå†å²è®°å½•
        this.state.presets = this.DEFAULT_PRESETS; // æ–°å»ºæ ¹èŠ‚ç‚¹æ—¶é‡ç½®é¢„è®¾
    },

    // æ ¸å¿ƒå®‰å…¨æ‰§è¡Œå™¨ (Anchor-based Safety Check)
    async executeSafeAction(simulator, onApplied = null) {
        const { nodes, focusNode, slots } = this.state;

        // 1. è·å–å½“å‰é”šç‚¹é›†åˆ (Origin + Focus + Slots)
        const getAnchorUUIDs = (nList, fNode, sList) => {
            const root = nList.find(n => n.isRoot);
            return new Set([root, fNode, ...sList].filter(n => n).map(n => n.uuid));
        };
        const currentAnchorUUIDs = getAnchorUUIDs(nodes, focusNode, slots);

        // 2. æ¨¡æ‹Ÿæœªæ¥çŠ¶æ€
        const nextState = simulator();
        const nextAnchorUUIDs = getAnchorUUIDs(nextState.nodes, nextState.nextFocus, nextState.nextSlots);

        // 3. å¿«é€Ÿæ”¾è¡Œåˆ¤å®š
        // å¦‚æœç»“æ„æœªå—æŸ(æœªåˆ èŠ‚ç‚¹/è¿çº¿) ä¸” é”šç‚¹é›†åˆå†…å®¹ä¸€è‡´(åªæ˜¯ä½ç½®äº’æ¢)
        const isStructureIntact = nextState.nodes.length >= nodes.length && nextState.links.length >= this.state.links.length;
        const isAnchorsSame = currentAnchorUUIDs.size === nextAnchorUUIDs.size && [...currentAnchorUUIDs].every(id => nextAnchorUUIDs.has(id));

        const applyState = () => {
            this.state.nodes = nextState.nodes;
            this.state.links = nextState.links;
            this.state.focusNode = nextState.nextFocus;
            this.state.slots = nextState.nextSlots;
            if (typeof onApplied === 'function') {
                onApplied();
            }
            App.UI.updateSidebar();
            App.UI.updateSlotUI();
            this.save();
            App.Renderer.restartSim();
        };

        if (isStructureIntact && isAnchorsSame) {
            applyState();
            return true;
        }

        // 4. è¿é€šæ€§æ£€æŸ¥ (Reachability)
        const anchorsObjects = nextState.nodes.filter(n => nextAnchorUUIDs.has(n.uuid));
        const reachableUUIDs = App.Utils.findReachable(nextState.nodes, nextState.links, anchorsObjects);
        const lostNodes = nextState.nodes.filter(n => !reachableUUIDs.has(n.uuid));

        if (lostNodes.length > 0) {
            const names = lostNodes.slice(0, 3).map(n => n.label).join(', ');
            const msg = t('alert.deleteConfirm', {n: lostNodes.length, label: lostNodes[0].label});
            if (await App.UI.Dialog.confirm(msg)) {
                // Apply the simulated state first
                applyState();

                // Then clean up lost nodes
                const deadSet = new Set(lostNodes.map(n => n.uuid));
                this.state.nodes = this.state.nodes.filter(n => !deadSet.has(n.uuid));
                this.state.links = this.state.links.filter(l => !deadSet.has(l.source.uuid) && !deadSet.has(l.target.uuid));
                this.state.slots = this.state.slots.map(s => (s && deadSet.has(s.uuid)) ? null : s);
                this.state.navHistory = this.state.navHistory.filter(n => !deadSet.has(n.uuid));
                lostNodes.forEach(n => App.Runtime.clearStorage(n.uuid));

                this.save();
                App.Renderer.restartSim();
                return true;
            }
            return false;
        } else {
            applyState();
            return true;
        }
    },

    save() {
        const payload = {
            data: {
                nodes: this.state.nodes.map(n => ({
                    uuid: n.uuid, label: n.label, isRoot: n.isRoot, x: n.x, y: n.y,
                    summary: n.summary, content: n.content, color: n.color
                })),
                links: this.state.links.map(l => ({
                    source: l.source.uuid,
                    target: l.target.uuid,
                    type: l.type
                }))
            },
            focusNodeUuid: this.state.focusNode ? this.state.focusNode.uuid : null,
            slots: this.state.slots.map(s => s ? s.uuid : null),
            viewLayers: this.state.viewLayers,
            presets: this.state.presets
        };
        localStorage.setItem('stars_v5', JSON.stringify(payload));
        return payload;
    },

    saveDebounced: null,

    exportData() {
        const data = this.save();

        const b = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(b);
        a.download = 'stars_v5.json';
        a.click();
    },

    importData(inp) {
        const f = inp.files[0];
        if(f) {
            const r = new FileReader();
            r.onload = e => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (importedData && importedData.data) {
                        this.loadState(importedData, true);
                        App.UI.showFlash(t('alert.importSuccess'), 'info');
                    } else { App.UI.showFlash(t('alert.importFail'), 'warn'); }
                } catch (error) {
                    console.error(t('alert.parseFail'), error);
                    App.UI.showFlash(t('alert.parseFail'), 'warn');
                };
            };
            r.readAsText(f);
            inp.value = '';
        }
    },

    async resetSystem() {
        if(await App.UI.Dialog.confirm(t('alert.resetConfirm'))) {
            App.Runtime.clearAllStorage();
            localStorage.removeItem('stars_v5');
            location.reload();
        }
    }
};
App.Store.saveDebounced = App.Utils.debounce(App.Store.save, 1000);

// ==========================================
// 3. Runtime (èŠ‚ç‚¹è„šæœ¬æ²™ç®±) - Unified Version
// ==========================================
App.Runtime = {
    activeInstances: {}, // { uuid: { unmountFn: ... } }
    mount(node, containerId) {
        // 1. æ¸…ç†æ—§å®ä¾‹
        this.unmount(node.uuid);
        const container = document.getElementById(containerId);
        if (!container) return;
        // 2. æå–å¹¶ç§»é™¤ script æ ‡ç­¾
        const scriptsToExecute = [];
        // ä½¿ç”¨ Array.from è½¬æ¢ NodeList ä»¥ä¾¿å®‰å…¨éå†
        Array.from(container.querySelectorAll('script')).forEach(script => {
            scriptsToExecute.push(script.textContent);
            script.remove();
        });
        let unmountCallbacks = [];
        // 3. åˆ›å»º API æ²™ç®±ç¯å¢ƒ
        const api = {
            // DOM æ“ä½œä»…é™äºå®¹å™¨å†…éƒ¨
            $: (sel) => container.querySelector(sel),
            $$: (sel) => container.querySelectorAll(sel),

            // æ•°æ®å­˜å‚¨
            storage: this._createStorageApi(node.uuid),

            // èŠ‚ç‚¹å…ƒæ•°æ®
            node: { uuid: node.uuid, label: node.label, color: node.color },

            // ç”Ÿå‘½å‘¨æœŸ
            onMount: (cb) => {
                try { cb(); } catch(e) { console.error(`[Node ${node.uuid}] onMount error:`, e); }
            },
            onUnmount: (cb) => { unmountCallbacks.push(cb); },
            // å…¨å±€å¯¹è±¡è®¿é—® (ä¿ç•™ VSCode ç‰ˆçš„èƒ½åŠ›ï¼Œå¦‚æœè¿½æ±‚ç»å¯¹å®‰å…¨å¯ç§»é™¤)
            window: window,
            document: document,

            // è¾…åŠ©å·¥å…·
            container: container
        };
        // 4. æ³¨å†Œé”€æ¯å‡½æ•°
        this.activeInstances[node.uuid] = {
            unmountFn: () => {
                unmountCallbacks.forEach(cb => {
                    try { cb(); } catch(e) { console.error(`[Node ${node.uuid}] onUnmount error:`, e); }
                });
                unmountCallbacks = [];
            }
        };
        // 5. æ‰§è¡Œè„šæœ¬
        scriptsToExecute.forEach((code) => {
            try {
                // ä½¿ç”¨ "use strict" æ¨¡å¼ (æ¥è‡ª VSCode ç‰ˆä¼˜åŒ–)
                new Function('api', `(function(Runtime){ "use strict"; ${code} })(arguments[0])`)(api);
            } catch (e) {
                console.error(`Script error in node ${node.uuid}:`, e);
                this._renderError(container, e.message);
            }
        });
    },
    unmount(uuid) {
        if (this.activeInstances[uuid]) {
            try {
                this.activeInstances[uuid].unmountFn();
            } catch (e) {
                console.warn(`Error unmounting node ${uuid}:`, e);
            }
            delete this.activeInstances[uuid];
        }
    },
    _renderError(container, message) {
        const errDiv = document.createElement('div');
        Object.assign(errDiv.style, {
            color: '#ff4d4f',
            fontSize: '12px',
            marginTop: '8px',
            padding: '4px',
            background: 'rgba(255,0,0,0.05)',
            borderLeft: '2px solid #ff4d4f'
        });
        errDiv.innerText = `Script Error: ${message}`;
        container.appendChild(errDiv);
    },
    _createStorageApi(uuid) {
        const prefix = `node_storage_${uuid}_`;
        // ä¿ç•™ Web ç‰ˆçš„ try-catchï¼Œé˜²æ­¢éšç§æ¨¡å¼æˆ–é…é¢å·²æ»¡å¯¼è‡´å´©æºƒ
        return {
            set: (k, v) => {
                try { localStorage.setItem(prefix + k, JSON.stringify(v)); return true; }
                catch(e) { console.warn('Storage set failed:', e); return false; }
            },
            get: (k, def) => {
                try { const i = localStorage.getItem(prefix + k); return i ? JSON.parse(i) : def; }
                catch(e) { return def; }
            },
            remove: (k) => localStorage.removeItem(prefix + k),
            clear: () => this.clearStorage(uuid)
        };
    },
    clearStorage(uuid) {
        const prefix = `node_storage_${uuid}_`;
        this._clearStorageByPrefix(prefix);
    },
    clearAllStorage() {
        this._clearStorageByPrefix("node_storage_");
    },
    // ç»Ÿä¸€çš„æ¸…ç†é€»è¾‘ (ç»“åˆ VSCode çš„ç®€æ´å’Œ Web çš„å€’åºéå†æ€æƒ³é¿å…ç´¢å¼•å¡Œé™·)
    _clearStorageByPrefix(prefix) {
        Object.keys(localStorage)
            .filter(k => k.startsWith(prefix))
            .forEach(k => localStorage.removeItem(k));
    }
};

// ==========================================
// 4. UI (ç•Œé¢ç®¡ç†)
// ==========================================
App.UI = {
    els: {
        label: document.getElementById('node-label'),
        uuid: document.getElementById('node-uuid'),
        linkStatus: document.getElementById('link-status'),
        summary: document.getElementById('node-summary'),
        content: document.getElementById('node-content'),
        colorInput: document.getElementById('node-color-input'),
        colorHex: document.getElementById('node-color-hex')
    },

    init() {
        this.initBindings();
        this.Dialog.init();
    },

    initBindings() {
        // Sidebar Bindings with Tab Cycling
        this.els.label.addEventListener('input', () => this.onNodeEdit('label', this.els.label.value));
        this.els.label.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-summary', 'node-content'));

        this.els.summary.addEventListener('input', () => this.onNodeEdit('summary', this.els.summary.value));
        this.els.summary.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-content', 'node-label'));

        this.els.content.addEventListener('input', () => this.onNodeEdit('content', this.els.content.value));
        this.els.content.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-label', 'node-summary'));

        this.els.colorInput.addEventListener('input', () => {
            this.els.colorHex.value = this.els.colorInput.value;
            this.onNodeEdit('color', this.els.colorInput.value);
            this.updateSlotUI();
        });

        this.els.colorHex.addEventListener('input', () => {
            if(/^#[0-9A-F]{6}$/i.test(this.els.colorHex.value)) {
                this.els.colorInput.value = this.els.colorHex.value;
                this.onNodeEdit('color', this.els.colorHex.value);
                this.updateSlotUI();
            }
        });

        // dialog Background Click to Close
        const dialog = document.getElementById('custom-dialog-overlay');
        dialog.addEventListener('mousedown', (e) => {
            if (e.target === dialog) App.UI.Dialog.close();
        });

        // Modal Background Click to Close
        const modal = document.getElementById('content-modal');
        modal.addEventListener('mousedown', (e) => {
            if (e.target === modal) App.UI.Modal.close();
        });

        // Slot Click Listeners (Dynamic)
        for(let i=0; i<4; i++) {
            const slotEl = document.getElementById(`slot-${i+1}`);
            if(slotEl) {
                slotEl.addEventListener('click', (e) => {
                    // Shift detection fix
                    App.Input.handleSlotClick(i, e.shiftKey);
                });
                slotEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    App.Input.clearSlot(i);
                });
            }
        }

        // Sidebar Resizer
        let isResizing = false;
        const resizer = document.getElementById('sidebar-resizer');
        resizer.addEventListener('mousedown', (e) => { isResizing = true; e.preventDefault(); App.Renderer.canvas.style.pointerEvents = 'none'; document.body.style.cursor = 'ew-resize'; });
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = Math.max(250, Math.min(window.innerWidth - e.clientX, window.innerWidth * 0.6));
            document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
            App.Renderer.resize();
        });
        document.addEventListener('mouseup', () => { if(isResizing) { isResizing = false; App.Renderer.canvas.style.pointerEvents = 'auto'; document.body.style.cursor = 'default'; } });
        window.addEventListener('resize', () => App.Renderer.resize());


        // --- æ–°å¢ï¼šç»‘å®šå³ä¸‹è§’ä¸‰ä¸ªè¾“å…¥æ¡† ---
        const inpJump = document.getElementById('inp-jump');
        const inpFilterNode = document.getElementById('inp-filter-node');
        const inpFilterLink = document.getElementById('inp-filter-link');

        // 1. è·³è½¬åŠŸèƒ½
        inpJump.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const val = inpJump.value.trim().toLowerCase();
                if (!val) return;
                // ç®€å•çš„æ¨¡ç³Šæœç´¢
                const target = App.Store.state.nodes.find(n => n.label.toLowerCase().includes(val));
                if (target) {
                    App.Input.navigate(target);
                    // å¯é€‰ï¼šæ¸…ç©ºè¾“å…¥æ¡†
                    // inpJump.value = ''; 
                    App.UI.showFlash(`Jumped to: ${target.label}`);
                    // å¤±å»ç„¦ç‚¹ï¼Œå›åˆ°ç”»å¸ƒ
                    inpJump.blur();
                    App.Renderer.canvas.focus();
                } else {
                    App.UI.showFlash("Node not found", "warn");
                }
            }
        });

        // 2. èŠ‚ç‚¹ç­›é€‰ (å›è½¦è§¦å‘)
        inpFilterNode.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                App.Store.state.filterNodeStr = inpFilterNode.value;
                // å¼ºåˆ¶åˆ·æ–°æ¸²æŸ“
                App.Renderer.visCache.lastSignature = null; 
                App.Renderer.restartSim();
                App.UI.showFlash("Node Filter Updated");
                inpFilterNode.blur();
            }
        });

        // 3. è¿çº¿ç­›é€‰ (å›è½¦è§¦å‘)
        inpFilterLink.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                App.Store.state.filterLinkStr = inpFilterLink.value;
                // å¼ºåˆ¶åˆ·æ–°æ¸²æŸ“
                App.Renderer.visCache.lastSignature = null;
                App.Renderer.restartSim();
                App.UI.showFlash("Link Filter Updated");
                inpFilterLink.blur();
            }
        });
        
        // é˜²æ­¢æŒ‰é”®äº‹ä»¶å†’æ³¡è§¦å‘å…¨å±€å¿«æ·é”® (å¦‚åˆ é™¤ã€ç§»åŠ¨ç­‰)
        [inpJump, inpFilterNode, inpFilterLink].forEach(el => {
            el.addEventListener('keydown', (e) => e.stopPropagation());
        });
    },

    onNodeEdit(field, value) {
        if(App.Store.state.focusNode) {
            App.Store.state.focusNode[field] = value;
            App.Store.saveDebounced();
        }
    },

    handleEditorTab(e, nextId, prevId) {
        if (e.key === 'Tab') {
            e.preventDefault();
            const targetId = e.shiftKey ? prevId : nextId;
            const el = document.getElementById(targetId);
            el.focus(); if(el.tagName!=='DIV') el.select();
        }
    },

    updateSidebar() {
        const node = App.Store.state.focusNode;
        if(!node) return;
        this.els.label.value = node.label;
        this.els.uuid.innerText = "UUID: " + node.uuid;
        this.els.summary.value = node.summary || "";
        this.els.content.value = node.content || "";
        this.els.colorInput.value = node.color || "#4facfe";
        this.els.colorHex.value = node.color || "#4facfe";
        const count = App.Store.state.links.filter(l => l.source.uuid === node.uuid || l.target.uuid === node.uuid).length;
        this.els.linkStatus.innerText = `Links: ${count}`;
    },

    updateSlotUI() {
        const { slots } = App.Store.state;
        for(let i=0; i<4; i++) {
            const el = document.getElementById(`slot-${i+1}`);
            const node = slots[i];
            const circle = el.querySelector('.slot-circle');
            const nameEl = el.querySelector('.slot-name');
            if (node) {
                el.classList.add('active');
                nameEl.innerText = node.label;
                circle.style.background = node.color || "#4facfe";
                circle.style.boxShadow = `0 0 8px ${node.color || "#4facfe"}`;
                circle.style.border = "1px solid rgba(255,255,255,0.3)";
            } else {
                el.classList.remove('active');
                nameEl.innerText = "-";
                circle.style.background = "#222";
                circle.style.boxShadow = "none";
                circle.style.border = "1px solid #333";
            }
        }
    },

    showFlash(msg, type = 'info') {
        const el = document.getElementById('flash-message');
        el.innerText = msg; el.className = type; el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 2000);
    },

    Dialog: {
        overlay: document.getElementById('custom-dialog-overlay'),
        msgEl: document.getElementById('custom-dialog-msg'),
        inputEl: document.getElementById('custom-dialog-input'),
        btnConfirm: document.getElementById('btn-confirm'),
        btnCancel: document.getElementById('btn-cancel'),
        isActive: false,

        // ç”¨äºå­˜å‚¨å½“å‰æ­£åœ¨è¿è¡Œçš„å…³é—­å›è°ƒï¼Œä»¥ä¾¿å¤–éƒ¨å¼ºè¡Œå…³é—­
        _currentCleanup: null,
        init() {},
        /**
         * å¼ºè¡Œå…³é—­å½“å‰å¯¹è¯æ¡†
         * è¿™ç­‰åŒäºç”¨æˆ·ç‚¹å‡»äº†â€œå–æ¶ˆâ€æŒ‰é’®
         */
        close() {
            if (this.isActive && this.btnCancel) {
                // æ¨¡æ‹Ÿç‚¹å‡»å–æ¶ˆæŒ‰é’®ï¼Œè¿™æ ·å¯ä»¥å¤ç”¨å·²æœ‰çš„ Promise resolve(false/null) é€»è¾‘
                // å¹¶ä¸”ä¼šè‡ªåŠ¨è°ƒç”¨ cleanup æ¸…ç†äº‹ä»¶ç›‘å¬
                this.btnCancel.click();
            } else if (this.isActive && this._currentCleanup) {
                // å¦‚æœ DOM è¿˜æ²¡å‡†å¤‡å¥½æˆ–è€…å‘ç”Ÿäº†å…¶ä»–å¼‚å¸¸ï¼Œä½†åœ¨é€»è¾‘ä¸Šæ˜¯ Active
                // æ­¤æ—¶ç›´æ¥è°ƒç”¨æ¸…ç†å‡½æ•°ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
                this._currentCleanup();
            }
        },
        _show(msg, needsInput = false, placeholder = '') {
            return new Promise((resolve) => {
                // å¦‚æœå½“å‰å·²ç»æœ‰ä¸€ä¸ªçª—å£æ‰“å¼€ï¼Œå…ˆå…³æ‰å®ƒï¼Œé˜²æ­¢å†²çª
                if (this.isActive) this.close();
                this.isActive = true;
                this.msgEl.innerText = msg;
                this.inputEl.style.display = needsInput ? 'block' : 'none';
                this.inputEl.value = '';
                this.inputEl.placeholder = placeholder;

                // ä½¿ç”¨ I18n è·å–æŒ‰é’®æ–‡æœ¬ (å‡è®¾ t å‡½æ•°å­˜åœ¨)
                this.btnConfirm.innerText = typeof t !== 'undefined' ? t('dialog.confirm') : 'Confirm';
                this.btnCancel.innerText = typeof t !== 'undefined' ? t('dialog.cancel') : 'Cancel';
                this.overlay.classList.add('active');
                // ç„¦ç‚¹ç®¡ç†
                if (needsInput) setTimeout(() => this.inputEl.focus(), 50);
                else setTimeout(() => this.btnConfirm.focus(), 50);
                // é”®ç›˜è¾…åŠ©å¯¼èˆª
                const handleBtnKey = (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); this.btnConfirm.click(); }
                    if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); this.btnCancel.click(); }
                };
                // æ¸…ç†ä¸å…³é—­é—­åŒ…
                const cleanup = (e) => {
                    if(e) { e.preventDefault(); e.stopPropagation(); }

                    // è§£ç»‘äº‹ä»¶
                    this.btnConfirm.onclick = null;
                    this.btnCancel.onclick = null;
                    this.inputEl.onkeydown = null;
                    this.btnConfirm.removeEventListener('keydown', handleBtnKey);
                    this.btnCancel.removeEventListener('keydown', handleBtnKey);

                    // éšè— UI
                    this.overlay.classList.remove('active');
                    this.isActive = false;
                    this._currentCleanup = null; // æ¸…ç©ºå¼•ç”¨
                    // å½’è¿˜ç„¦ç‚¹
                    if (App && App.Renderer && App.Renderer.canvas) {
                        App.Renderer.canvas.focus();
                    }
                };
                // å°† cleanup æš´éœ²ç»™å®ä¾‹ï¼Œä»¥é˜²ä¸‡ä¸€éœ€è¦å¼ºåˆ¶ç›´æ¥è°ƒç”¨
                this._currentCleanup = () => { cleanup(); resolve(needsInput ? null : false); };
                // äº‹ä»¶ç»‘å®š
                this.btnConfirm.onclick = (e) => {
                    const val = this.inputEl.value;
                    cleanup(e);
                    resolve(needsInput ? val : true);
                };

                this.btnCancel.onclick = (e) => {
                    cleanup(e);
                    resolve(needsInput ? null : false);
                };
                this.inputEl.onkeydown = (e) => {
                    if(e.key === 'Enter') { e.preventDefault(); this.btnConfirm.click(); }
                    if(e.key === 'Escape') { e.preventDefault(); this.btnCancel.click(); }
                };
                // é˜²æ­¢ ESC å…³é—­å¼¹çª—æ—¶è¯¯è§¦å…¶ä»–é€»è¾‘
                this.btnConfirm.addEventListener('keydown', handleBtnKey);
                this.btnCancel.addEventListener('keydown', handleBtnKey);
            });
        },
        confirm(msg) { return this._show(msg, false); },
        prompt(msg, ph = '') { return this._show(msg, true, ph); }
    },

    Modal: {
        el: document.getElementById('content-modal'),
        body: document.getElementById('modal-body'),
        show() {
            const node = App.Store.state.focusNode;
            if (!node) return;
            // Unmount previous if exists (safety)
            if(App.Runtime.activeInstances[node.uuid]) App.Runtime.unmount(node.uuid);

            this.body.innerHTML = ''; // æ¸…ç©º

            const raw = node.content || t('modal.noContent');
            const html = typeof marked !== 'undefined' ? marked.parse(raw) : raw;
            const containerId = `node-content-host-${node.uuid}`;

            this.body.innerHTML = `
                <div style="font-size:2em; font-weight:bold; color:#4facfe; margin-bottom:10px;">${node.label}</div>
                <div style="color:#666; font-style:italic; margin-bottom:20px; border-left:3px solid #555; padding-left:10px;">
                    ${node.summary ? (typeof marked !== 'undefined' ? marked.parse(node.summary) : node.summary) : ''}
                </div>
                <hr style="border:0; border-bottom:1px solid #333; margin-bottom:20px;">
                <div id="${containerId}" class="node-content-host" style="line-height:1.8; font-size:16px;">${html}</div>
                <div id="modal-close-btn" style="margin-top:50px; text-align:center; font-size:12px; color:#444; cursor:pointer;">
                    ${t('modal.close')} (Esc)
                </div>
            `;

            document.getElementById('modal-close-btn').addEventListener('click', () => App.UI.Modal.close());

            if (typeof hljs !== 'undefined') this.body.querySelectorAll('pre code').forEach(b => hljs.highlightElement(b));

            // Mount scripts
            App.Runtime.mount(node, containerId);

            this.el.classList.add('active');

            // Temporary Key Listener for ESC inside modal
            this._escHandler = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault(); e.stopPropagation();
                    this.close();
                }
            };
            window.addEventListener('keydown', this._escHandler);
        },
        close() {
            this.el.classList.remove('active');
            const node = App.Store.state.focusNode;
            if(node) App.Runtime.unmount(node.uuid);
            this.body.innerHTML = '';
            if(this._escHandler) window.removeEventListener('keydown', this._escHandler);
        }
    },

    RelationPicker: {
        el: document.getElementById('relation-picker'),
        active: false, resolve: null, reject: null, allowDelete: false,
        show(allowDelete = false) {
            this.allowDelete = allowDelete;
            return new Promise((res, rej) => {
                const presets = App.Store.state.presets;
                const delFrag = allowDelete ? t('preset.delete') : '';
                let html = `<div class="menu-title">${t('preset.title', {deleteFragment: delFrag})}</div>`;
                html += presets.slice(0, 9).map((p, i) =>
                    `<div class="menu-opt" onclick="App.UI.RelationPicker.pick('${p.val}')"><span class="menu-key" style="color:${p.color}">[${i+1}]</span>${p.label || p.val}</div>`
                ).join('');
                if (presets.length > 9) html += `<div class="menu-title" style="margin-top:10px;">${t('preset.more')}</div>` + presets.slice(9).map(p => `<div class="menu-opt" onclick="App.UI.RelationPicker.pick('${p.val}')"><span class="menu-key" style="visibility:hidden;">[]</span>${p.label}</div>`).join('');
                if (allowDelete) html += `<div class="menu-opt delete-opt" style="margin-top:5px; border-top:1px solid #333" onclick="App.UI.RelationPicker.pick('DELETE')"><span class="menu-key" style="color:#e74c3c">[D]</span><span style="color:#e74c3c">${t('linkMode.deleteLabel')}</span></div>`;

                this.el.innerHTML = html; this.el.classList.add('active'); this.active = true;
                this.resolve = res; this.reject = rej;
            });
        },
        handleInput(e) {
            if(!this.active) return;
            const num = parseInt(e.key);
            const presets = App.Store.state.presets;
            if (!isNaN(num) && num >= 1 && num <= Math.min(9, presets.length)) { e.preventDefault(); this.pick(presets[num-1].val); }
            else if (e.key === ' ') { e.preventDefault(); this.pick('CUSTOM'); }
            else if (e.key === 'Enter' && presets.length>0) { e.preventDefault(); this.pick(presets[0].val); }
            else if (this.allowDelete && ['x','X','Delete'].includes(e.key)) { e.preventDefault(); this.pick('DELETE'); }
            else if (e.key === 'Escape') { e.preventDefault(); this.reject(); this.close(); }
        },
        pick(val) {
            // 1. å…ˆè§£å†³ Promise (æˆåŠŸ)
            if(this.resolve) {
                this.resolve({ val });
                // å…³é”®ï¼šæ¸…ç©ºå›è°ƒï¼Œé˜²æ­¢ close() è¯¯åˆ¤ä¸ºå–æ¶ˆ
                this.resolve = null;
                this.reject = null;
            }
            // 2. å†å…³é—­ UI
            this.close();
        },
        close() {
            this.el.classList.remove('active');
            this.active = false;
            // 3. é˜²å¾¡é€»è¾‘ï¼šå¦‚æœèµ°åˆ°è¿™é‡Œ resolve/reject è¿˜æ²¡è¢«æ¸…ç†ï¼Œè¯´æ˜æ˜¯æ„å¤–å…³é—­ï¼ˆç‚¹ç©ºç™½å¤„/Escï¼‰ï¼Œè§†ä¸ºå–æ¶ˆ
            if(this.reject) {
                this.reject();
                this.resolve = null; this.reject = null;
            }
        }
    },

    PresetEditor: {
        el: document.getElementById('preset-editor'),
        listEl: document.getElementById('preset-list-container'),
        active: false, tempPresets: [],
        open() {
            if(this.active) return;
            this.tempPresets = JSON.parse(JSON.stringify(App.Store.state.presets));
            this.renderList();
            this.el.classList.add('active'); this.active = true;
        },
        renderList() {
            this.listEl.innerHTML = '';
            this.tempPresets.forEach((p, i) => {
                const row = document.createElement('div'); row.className = 'preset-row';
                row.innerHTML = `
                    <span class="preset-idx">${i+1}</span>
                    <input type="color" class="preset-color" value="${p.color}" onchange="App.UI.PresetEditor.update(${i}, 'color', this.value)">
                    <input type="text" class="preset-input" style="width:120px" placeholder="${t('preset.input.label')}" value="${p.label}" oninput="App.UI.PresetEditor.update(${i}, 'label', this.value)">
                    <input type="text" class="preset-input" style="flex:1; color:#aaa;" placeholder="${t('preset.input.value')}" value="${p.val}" oninput="App.UI.PresetEditor.update(${i}, 'val', this.value)">
                    <span class="preset-del" onclick="App.UI.PresetEditor.remove(${i})">âœ•</span>`;
                this.listEl.appendChild(row);
            });
        },
        update(idx, field, val) { this.tempPresets[idx][field] = val; },
        remove(idx) { this.tempPresets.splice(idx, 1); this.renderList(); },
        add() {
            this.tempPresets.push({label:t('fallback.newRelationship'), val:'new', color: App.Utils.getRandomColor()});
            this.renderList();
            setTimeout(() => this.listEl.scrollTop = this.listEl.scrollHeight, 10);
        },
        saveAndClose() {
            // 1. æ£€æŸ¥ç©ºå€¼
            if (this.tempPresets.some(p => !p.val || !p.val.trim())) {
                App.UI.showFlash(t('alert.presetValueEmpty'), 'warn');
                return;
            }
            // 2. æ£€æŸ¥é‡å¤å€¼
            const values = this.tempPresets.map(p => p.val.trim());
            if (new Set(values).size !== values.length) {
                App.UI.showFlash(t('alert.presetValueDuplicate'), 'warn');
                return;
            }

            // æ‰§è¡Œä¿å­˜
            App.Store.state.presets = JSON.parse(JSON.stringify(this.tempPresets));
            App.Store.save();
            App.Renderer.restartSim();
            this.close();
            App.UI.showFlash(t('flash.presetUpdated'));
        },
        close() { this.el.classList.remove('active'); this.active = false; }
    }
};

// ==========================================
// 5. Renderer (æ¸²æŸ“ä¸ç‰©ç†æ¨¡æ‹Ÿ - æœ€ç»ˆä¼˜åŒ–æ³¨é‡Šç‰ˆ)
// ==========================================
App.Renderer = {
    // --- æ ¸å¿ƒ DOM å¼•ç”¨ ---
    canvas: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),

    // --- è§†å£ä¸ç›¸æœºçŠ¶æ€ ---
    width: 0, height: 0,        // ç”»å¸ƒçš„é€»è¾‘å®½é«˜
    viewX: 0, viewY: 0,         // ç›¸æœºå½“å‰ä½ç½®ï¼ˆä¸–ç•Œåæ ‡çš„åç§»é‡ï¼‰
    viewK: 1,                   // ç›¸æœºç¼©æ”¾æ¯”ä¾‹ (Scale)
    viewRotation: 0,            // å½“å‰è§†å£çš„æ—‹è½¬è§’åº¦ (å¼§åº¦)
    targetRotation: 0,          // ç›®æ ‡æ—‹è½¬è§’åº¦ (ç”¨äºå¹³æ»‘åŠ¨ç”»)

    // --- ç‰©ç†å¼•æ“ç›¸å…³ ---
    simulation: null,           // D3 åŠ›å¯¼å‘å›¾å®ä¾‹
    pointerForce: null,         // é¼ æ ‡æ‹–æ‹½äº§ç”Ÿçš„å¼•åŠ›

    // --- åŠ¨ç”»å¾ªç¯å˜é‡ ---
    lastRenderTime: 0,          // ä¸Šä¸€å¸§çš„æ—¶é—´æˆ³ (ç”¨äºè®¡ç®— deltaTime)
    cameraLookAtX: undefined,   // ç›¸æœºæ­£åœ¨ç›¯ç€çš„ç›®æ ‡ç‚¹ X (ç”¨äºå¹³æ»‘é£è¡Œ)
    cameraLookAtY: undefined,   // ç›¸æœºæ­£åœ¨ç›¯ç€çš„ç›®æ ‡ç‚¹ Y

    // --- [ä¼˜åŒ–] DOM å…ƒç´ ç¼“å­˜ ---
    // é¿å…åœ¨æ¯å¸§ render å¾ªç¯ä¸­åå¤è°ƒç”¨ document.getElementByIdï¼Œæé«˜æ€§èƒ½
    uiRefs: {
        layerIndicator: null,   // å·¦ä¸‹è§’æ˜¾ç¤ºçš„å±‚çº§æ•° DOM
        visibleCount: null      // å·¦ä¸‹è§’æ˜¾ç¤ºçš„å¯è§èŠ‚ç‚¹æ•° DOM
    },

    // --- [ä¼˜åŒ–] å¯è§†æ€§è®¡ç®—ç¼“å­˜ (è„æ£€æŸ¥æœºåˆ¶) ---
    // åªæœ‰å½“ç„¦ç‚¹ã€é¼ æ ‡æ‚¬åœæˆ–æ•°æ®å‘ç”Ÿå˜åŒ–æ—¶ï¼Œæ‰é‡æ–°è®¡ç®— BFSï¼Œè€Œä¸æ˜¯æ¯å¸§éƒ½ç®—
    visCache: {
        nodes: new Set(),       // å½“å‰å¯è§èŠ‚ç‚¹çš„ UUID é›†åˆ
        links: new Set(),       // å½“å‰å¯è§è¿çº¿çš„å¯¹è±¡é›†åˆ
        lastSignature: ""       // çŠ¶æ€æŒ‡çº¹ï¼Œç”¨äºæ¯”å¯¹æ˜¯å¦éœ€è¦æ›´æ–°
    },

    // --- [ä¿®å¤] æ ·å¼æ˜ å°„è¡¨ ---
    // å°†æ•°ç»„æ ¼å¼çš„ presets è½¬æ¢ä¸º Mapï¼Œä½¿é¢œè‰²æŸ¥æ‰¾ä» O(n) å˜ä¸º O(1)
    presetMap: new Map(),
    lastPresetsRef: null,       // ç”¨äºæ£€æµ‹æ•°æ®æºæ˜¯å¦å‘ç”Ÿå˜æ›´

    // --- å¸¸é‡é…ç½® ---
    FADE_DURATION: 400,         // èŠ‚ç‚¹æ˜¾ç¤º/éšè—çš„æ¸å˜æ—¶é—´ (æ¯«ç§’)
    DEFAULT_NODE_COLOR: "#4facfe",
    LINK_DISTANCE: 220,         // ç‰©ç†è¿çº¿çš„ç†æƒ³é•¿åº¦
    MIN_NODE_PIXEL_SIZE: 3,     // èŠ‚ç‚¹åœ¨å±å¹•ä¸Šçš„æœ€å°åƒç´ å°ºå¯¸ (é˜²æ¶ˆå¤±)
    MIN_FOCUS_NODE_PIXEL_SIZE: 6,     // èŠ‚ç‚¹åœ¨å±å¹•ä¸Šçš„æœ€å°åƒç´ å°ºå¯¸ (é˜²æ¶ˆå¤±)
    PROXIMITY_RANGE: 300,       // é¼ æ ‡æ¥è¿‘æ—¶çš„æ„Ÿåº”åŠå¾„
    HOVER_STOP_RANGE: 30,       // é¼ æ ‡è¿›å…¥æ­¤åŠå¾„åï¼ŒèŠ‚ç‚¹ä¿æŒæœ€å¤§æ”¾å¤§å€æ•°
    MAX_SCALE_MULT: 1.8,        // é¼ æ ‡æ¥è¿‘æ—¶çš„æœ€å¤§æ”¾å¤§å€æ•°

    // ==========================================
    // åˆå§‹åŒ–å‡½æ•°
    // ==========================================
    init() {
        // 1. ç¼“å­˜ UI å…ƒç´ å¼•ç”¨
        this.uiRefs.layerIndicator = document.getElementById('layer-indicator');
        this.uiRefs.visibleCount = document.getElementById('visible-count');

        // 2. åˆå§‹åŒ–ç”»å¸ƒå¤§å° (å¤„ç†é«˜æ¸…å±)
        this.resize();

        // 3. åˆå§‹åŒ– D3 ç‰©ç†æ¨¡æ‹Ÿå¼•æ“
        // forceLink: è¿çº¿æ‹‰åŠ›
        // forceCharge: èŠ‚ç‚¹é—´çš„æ–¥åŠ› (è´Ÿå€¼è¡¨ç¤ºæ’æ–¥)
        // forceCollide: é˜²æ­¢èŠ‚ç‚¹é‡å 
        this.simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.uuid).distance(this.LINK_DISTANCE).strength(0.1))
            .force("charge", d3.forceManyBody().strength(-80))
            .force("collide", d3.forceCollide(10))
            .alphaDecay(0.05).alphaMin(0.05); // è¡°å‡ç³»æ•°ï¼Œå†³å®šäº†ç‰©ç†åœæ­¢çš„å¿«æ…¢

        // 4. è‡ªå®šä¹‰é¼ æ ‡åŠ› (è®©è¢«æ‹–æ‹½çš„èŠ‚ç‚¹è·Ÿéšé¼ æ ‡)
        const force = (() => {
            let node, target, strength = 0.02;
            function f(alpha) {
                if (!node || !target) return;
                const dx = target.x - node.x, dy = target.y - node.y;
                // ä½¿ç”¨æŒ‡æ•°è¡°å‡å…¬å¼ï¼Œè®©æ‹–æ‹½æ‰‹æ„Ÿæ›´åƒæ©¡çš®ç­‹
                const k = strength * (1 - Math.exp(-Math.hypot(dx, dy) / 120));
                node.vx += dx * k; node.vy += dy * k;
            }
            f.initialize = () => {};
            f.node = (n) => { node = n; return f; };
            f.target = (x, y) => { target = {x,y}; return f; };
            return f;
        })();
        this.pointerForce = force;
        this.simulation.force('pointerDrag', this.pointerForce);

        // 5. å¯åŠ¨æ¸²æŸ“å¾ªç¯
        requestAnimationFrame((t) => this.render(t));
    },

    // ==========================================
    // çª—å£å¤§å°è°ƒæ•´ (å¤„ç†é«˜æ¸…å± DPR)
    // ==========================================
    resize() {
        const sidebarW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width')) || 340;
        const logicalWidth = window.innerWidth - sidebarW;
        const logicalHeight = window.innerHeight;

        // é€»è¾‘å®½é«˜ (CSS åƒç´ )
        this.width = logicalWidth;
        this.height = logicalHeight;

        // ç‰©ç†åƒç´  (è®¾å¤‡åƒç´  = é€»è¾‘åƒç´  * DPR)
        // è¿™ä¸€æ­¥æ˜¯ä¸ºäº†è®© Canvas åœ¨ Retina å±å¹•ä¸Šä¸æ¨¡ç³Š
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = logicalWidth * dpr;
        this.canvas.height = logicalHeight * dpr;

        // å¼ºåˆ¶ CSS å°ºå¯¸åŒ¹é…é€»è¾‘å°ºå¯¸
        this.canvas.style.width = `${logicalWidth}px`;
        this.canvas.style.height = `${logicalHeight}px`;

        // ç¼©æ”¾ Contextï¼Œä½¿å¾—åç»­ç»˜å›¾å¯ä»¥ç›´æ¥ä½¿ç”¨é€»è¾‘åæ ‡
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.scale(dpr, dpr);
    },

    // æ ¹æ®å±‚çº§è‡ªåŠ¨è°ƒæ•´ç¼©æ”¾æ¯”ä¾‹ (å±‚çº§è¶Šæ·±ï¼Œçœ‹çš„è¶Šè¿œ/è¶Šå°)
    adjustZoomByLayer() {
        this.viewK = 2.0 / Math.pow(App.Store.state.viewLayers, 0.7);
    },

    // ==========================================
    // é‡å¯ç‰©ç†æ¨¡æ‹Ÿ (æ€§èƒ½ä¼˜åŒ–ç‰ˆ)
    // ==========================================
    restartSim() {
        // ä¸ºäº†æ€§èƒ½ï¼Œç‰©ç†å¼•æ“åªè®¡ç®—â€œå½“å‰å…³æ³¨ç‚¹â€é™„è¿‘çš„èŠ‚ç‚¹
        // è¿œå¤„çš„èŠ‚ç‚¹ä¸éœ€è¦ç‰©ç†è®¡ç®—ï¼ŒèŠ‚çœ CPU
        const SIM_LAYERS = Math.max(7, App.Store.state.viewLayers);
        const targets = new Set();
        const { nodes, links, focusNode } = App.Store.state;

        // å›ºå®šæ ¹èŠ‚ç‚¹ä½ç½®
        const root = nodes.find(n => n.isRoot);
        if (root) { root.fx = 0; root.fy = 0; }

        // ä» FocusNode å¼€å§‹ï¼Œæ‰¾å‡ºå‘¨å›´ N å±‚èŠ‚ç‚¹åŠ å…¥ç‰©ç†æ¨¡æ‹Ÿ
        if (focusNode) {
            targets.add(focusNode.uuid);
            let queue = [{n: focusNode, d: 0}], head = 0;

            // ä¸´æ—¶æ„å»ºé‚»æ¥è¡¨åŠ é€ŸæŸ¥æ‰¾ (O(Edges))
            const adj = {};
            for (let i = 0; i < links.length; i++) {
                const l = links[i];
                const s = l.source.uuid||l.source;
                const t = l.target.uuid||l.target;
                if(!adj[s]) adj[s]=[]; adj[s].push(t);
                if(!adj[t]) adj[t]=[]; adj[t].push(s);
            }

            // BFS æœç´¢
            while(head < queue.length) {
                const {n, d} = queue[head++];
                if (d >= SIM_LAYERS) continue;
                const neighbors = adj[n.uuid] || [];
                for (let i = 0; i < neighbors.length; i++) {
                    const nid = neighbors[i];
                    if(!targets.has(nid)) {
                        targets.add(nid);
                        const obj = nodes.find(x=>x.uuid===nid);
                        if(obj) queue.push({n:obj, d:d+1});
                    }
                }
            }
        }

        const activeNodes = nodes.filter(n => targets.has(n.uuid));
        const activeLinks = links.filter(l => targets.has(l.source.uuid) && targets.has(l.target.uuid));

        // å°†æ´»è·ƒèŠ‚ç‚¹æ³¨å…¥ D3
        this.simulation.nodes(activeNodes);
        this.simulation.force("link").links(activeLinks);
    },

    // ==========================================
    // [æ ¸å¿ƒä¼˜åŒ–] å¯è§†æ€§è®¡ç®— (BFS + ç¼“å­˜)
    // ==========================================
    updateVisibility(focusNode, hoverNode, previewNode, viewLayers, nodes, links) {
        // è·å–ç­›é€‰æ­£åˆ™å­—ç¬¦ä¸²
        const { filterNodeStr, filterLinkStr } = App.Store.state;

        // 1. ç”ŸæˆçŠ¶æ€ç­¾å (Signature)
        // åŒ…æ‹¬ï¼šå…³é”®èŠ‚ç‚¹IDã€å±‚çº§ã€æ•°æ®é•¿åº¦ã€‚å¦‚æœè¿™äº›éƒ½æ²¡å˜ï¼Œè¯´æ˜å¯è§†èŒƒå›´æ²¡å˜ã€‚
        // åŠ å…¥ filterNodeStr å’Œ filterLinkStr åˆ°ç­¾åä¸­ï¼Œä»¥ä¾¿å˜åŒ–æ—¶é‡æ–°è®¡ç®—
        const focusId = focusNode ? focusNode.uuid : 'null';
        const hoverId = hoverNode ? hoverNode.uuid : 'null';
        const previewId = previewNode ? previewNode.uuid : 'null';
        const signature = `${focusId}|${hoverId}|${previewId}|${viewLayers}|${links.length}|${nodes.length}|${filterNodeStr}|${filterLinkStr}`;

        // 2. è„æ£€æŸ¥ï¼šå¦‚æœç­¾åä¸€è‡´ï¼Œç›´æ¥å¤ç”¨ä¸Šæ¬¡è®¡ç®—ç»“æœï¼Œè·³è¿‡ BFS
        if (this.visCache.lastSignature === signature) {
            return;
        }

        const visibleNodes = new Set();
        const visibleLinks = new Set();

        // 3. [ä¼˜åŒ–] æ„å»ºä¸´æ—¶é‚»æ¥è¡¨
        // åŸç”Ÿéå† Links æ˜¯ O(N*L)ï¼Œæ„å»ºé‚»æ¥è¡¨åæ˜¯ O(N+L)ï¼Œåœ¨å¤§æ•°æ®é‡ä¸‹å¿«å‡ åå€
        const adj = new Map();
        for (let i = 0; i < links.length; i++) {
            const l = links[i];
            const src = l.source;
            const tgt = l.target;

            if (!adj.has(src.uuid)) adj.set(src.uuid, []);
            if (!adj.has(tgt.uuid)) adj.set(tgt.uuid, []);

            // ä¿å­˜ Link å¯¹è±¡çš„å¼•ç”¨ï¼Œä»¥ä¾¿ç¨åç›´æ¥æ ‡è®° Link å¯è§
            adj.get(src.uuid).push({ node: tgt, link: l });
            adj.get(tgt.uuid).push({ node: src, link: l });
        }

        // 4. æ‰§è¡Œ BFS (å¹¿åº¦ä¼˜å…ˆæœç´¢)
        const queue = [];
        const runBFS = (startNode, maxDepth) => {
            if (!startNode) return;
            visibleNodes.add(startNode.uuid);
            queue.length = 0;
            queue.push({ n: startNode, d: 0 });

            let head = 0;
            while(head < queue.length) {
                const { n, d } = queue[head++];
                if (d >= maxDepth) continue;

                const neighbors = adj.get(n.uuid);
                if (neighbors) {
                    for (let i = 0; i < neighbors.length; i++) {
                        const { node: neighbor, link } = neighbors[i];

                        // åªè¦è¿åˆ°äº†å½“å‰å¯è§èŠ‚ç‚¹ï¼Œè¿™æ¡çº¿å°±åº”è¯¥æ˜¾ç¤º
                        visibleLinks.add(link);

                        // å¦‚æœé‚»å±…è¿˜æ²¡éå†è¿‡ï¼ŒåŠ å…¥é˜Ÿåˆ—
                        if (!visibleNodes.has(neighbor.uuid)) {
                            visibleNodes.add(neighbor.uuid);
                            queue.push({ n: neighbor, d: d + 1 });
                        }
                    }
                }
            }
        };

        // å¯¹ä¸‰ä¸ªå…³é”®ç‚¹åˆ†åˆ«è¿è¡Œ BFS
        if(focusNode) runBFS(focusNode, viewLayers);
        if(hoverNode && hoverNode !== focusNode) runBFS(hoverNode, 1);
        if(previewNode && previewNode !== focusNode) runBFS(previewNode, 1);

        // ==========================================
        // æ–°å¢ï¼šåŸºäºæ­£åˆ™è¡¨è¾¾å¼çš„â€œå‡æ³•â€ç­›é€‰
        // ==========================================
        
        // 5.1 èŠ‚ç‚¹æ­£åˆ™ç­›é€‰
        if (filterNodeStr && filterNodeStr.trim() !== "") {
            try {
                const nodeRegex = new RegExp(filterNodeStr, 'i'); // 'i' å¿½ç•¥å¤§å°å†™
                // éå†å½“å‰å¯è§èŠ‚ç‚¹ï¼Œä¸ç¬¦åˆçš„å‰”é™¤
                // æ³¨æ„ï¼šä¸èƒ½ç›´æ¥åœ¨è¿™ä¸ªå¾ªç¯é‡Œåˆ  visibleNodesï¼Œå› ä¸ºåé¢è¦å¤„ç†è¿çº¿
                const toRemoveNodes = new Set();
                visibleNodes.forEach(uuid => {
                    const node = nodes.find(n => n.uuid === uuid);
                    // å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨æˆ–è€…ä¸åŒ¹é…æ­£åˆ™ (ä¸”ä¸æ˜¯ç„¦ç‚¹èŠ‚ç‚¹ï¼Œç„¦ç‚¹èŠ‚ç‚¹é€šå¸¸ä¸åº”è¯¥è¢«ç­›é€‰æ‰)
                    if (node && node !== focusNode && !nodeRegex.test(node.label)) {
                        toRemoveNodes.add(uuid);
                    }
                });
                toRemoveNodes.forEach(uuid => visibleNodes.delete(uuid));
            } catch (e) { console.warn("Invalid Node Regex", e); }
        }

        // 5.2 è¿çº¿æ­£åˆ™ç­›é€‰
        if (filterLinkStr && filterLinkStr.trim() !== "") {
            try {
                const linkRegex = new RegExp(filterLinkStr, 'i');
                const toRemoveLinks = new Set();
                visibleLinks.forEach(l => {
                    // è·å–è¿çº¿çš„æ˜¾ç¤ºåç§° (ä¼˜å…ˆ Preset Labelï¼Œå¦åˆ™ç”¨ raw type)
                    const preset = this.presetMap.get(l.type);
                    const label = preset ? preset.label : l.type;
                    if (!linkRegex.test(label)) {
                        toRemoveLinks.add(l);
                    }
                });
                toRemoveLinks.forEach(l => visibleLinks.delete(l));
            } catch (e) { console.warn("Invalid Link Regex", e); }
        }

        // 5.3 ä¸€è‡´æ€§æ¸…ç†ï¼šå¦‚æœèŠ‚ç‚¹è¢«éšè—äº†ï¼Œè¿æ¥è¯¥èŠ‚ç‚¹çš„çº¿ä¹Ÿå¿…é¡»éšè—
        // è¿™ä¸€æ­¥å¿…é¡»æœ€ååš
        const finalLinksToRemove = new Set();
        visibleLinks.forEach(l => {
            if (!visibleNodes.has(l.source.uuid) || !visibleNodes.has(l.target.uuid)) {
                finalLinksToRemove.add(l);
            }
        });
        finalLinksToRemove.forEach(l => visibleLinks.delete(l));

        // 6. æ›´æ–°ç¼“å­˜
        this.visCache.nodes = visibleNodes;
        this.visCache.links = visibleLinks;
        this.visCache.lastSignature = signature;
    },

    // ==========================================
    // [æ ¸å¿ƒ] ä¸»æ¸²æŸ“å¾ªç¯ (æ¯ç§’çº¦ 60 æ¬¡)
    // ==========================================
    render(currentTime) {
        // è·å–è¾“å…¥çŠ¶æ€å’Œ Store æ•°æ®
        const { keyState, dragNode, mouseX, mouseY, hoverNode, previewNode, linkMode } = App.Input.state;
        const { nodes, links, focusNode, viewLayers, slots, presets } = App.Store.state;

        // --- [ä¿®å¤] å¼‚æ­¥æ•°æ®åŒæ­¥ ---
        // å› ä¸º presets æ•°æ®å¯èƒ½æ˜¯å¼‚æ­¥åŠ è½½çš„ï¼Œè¿™é‡Œæ£€æµ‹å¼•ç”¨å˜åŒ–ï¼ŒåŠ¨æ€æ›´æ–° Map
        if (presets && presets !== this.lastPresetsRef) {
            this.presetMap.clear();
            presets.forEach(p => {
                this.presetMap.set(p.val, { color: p.color, label: p.label });
            });
            this.lastPresetsRef = presets;
        }

        // --- å¤„ç†é”®ç›˜æ—‹è½¬ ---
        if (keyState['<'] || keyState['Q']) {
            this.targetRotation += 0.05;
            // æ—‹è½¬æ—¶éšè—ä¸´æ—¶çš„é¢„è§ˆæç¤ºï¼Œé¿å…çœ¼èŠ±
            if(previewNode) { App.Input.state.previewNode = null; App.Input.hideTooltip(); }
        }
        if (keyState['>'] || keyState['E']) {
            this.targetRotation -= 0.05;
            if(previewNode) { App.Input.state.previewNode = null; App.Input.hideTooltip(); }
        }

        // --- è®¡ç®—æ—¶é—´å¢é‡ (Delta Time) ---
        // ä½¿å¾—åŠ¨ç”»é€Ÿåº¦åœ¨ä¸åŒåˆ·æ–°ç‡çš„æ˜¾ç¤ºå™¨ä¸Šä¿æŒä¸€è‡´
        if (!this.lastRenderTime) this.lastRenderTime = currentTime;
        const deltaTime = currentTime - this.lastRenderTime;
        this.lastRenderTime = currentTime;

        // --- ç‰©ç†äº¤äº’æ›´æ–° ---
        // [ä¼˜åŒ–] ä¼˜å…ˆå°†é¼ æ ‡å±å¹•åæ ‡ -> ä¸–ç•Œåæ ‡
        const wMouse = this.screenToWorld(mouseX, mouseY);
        if (dragNode) {
            this.pointerForce.node(dragNode).target(wMouse.x, wMouse.y);
        }

        // --- ç›¸æœºå¹³æ»‘é£è¡Œé€»è¾‘ ---
        const halfW = this.width / 2;
        const halfH = this.height / 2;

        if(focusNode) {
            // åˆå§‹åŒ–ç›¸æœºä½ç½®
            if (this.cameraLookAtX === undefined) {
                this.cameraLookAtX = focusNode.x;
                this.cameraLookAtY = focusNode.y;
            }
            // ç¼“åŠ¨å…¬å¼: å½“å‰ += (ç›®æ ‡ - å½“å‰) * é€Ÿåº¦ç³»æ•°
            this.cameraLookAtX += (focusNode.x - this.cameraLookAtX) * 0.1;
            this.cameraLookAtY += (focusNode.y - this.cameraLookAtY) * 0.1;

            // è®¡ç®—æœ€ç»ˆ View åç§» (ç›¸æœºåœ¨ä¸–ç•Œåæ ‡çš„åæ–¹å‘)
            this.viewX = -this.cameraLookAtX * this.viewK + halfW;
            this.viewY = -this.cameraLookAtY * this.viewK + halfH;
        }

        // æ—‹è½¬è§’åº¦ç¼“åŠ¨
        let diff = this.targetRotation - this.viewRotation;
        // ç¡®ä¿æŒ‰æœ€è¿‘è·¯å¾„æ—‹è½¬ (æ¯”å¦‚ä» 350åº¦ åˆ° 10åº¦ï¼Œåªè½¬20åº¦è€Œä¸æ˜¯340åº¦)
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        this.viewRotation += diff * 0.1;

        // --- Canvas ç»˜åˆ¶å‡†å¤‡ ---
        const ctx = this.ctx;
        ctx.save();
        ctx.clearRect(0, 0, this.width, this.height);

        // åº”ç”¨å…¨å±€å˜æ¢çŸ©é˜µ (Transform Matrix)
        // é¡ºåºï¼šç§»åˆ°ä¸­å¿ƒ -> æ—‹è½¬ -> ç§»å› -> å¹³ç§» -> ç¼©æ”¾
        ctx.translate(halfW, halfH);
        ctx.rotate(this.viewRotation);
        ctx.translate(-halfW, -halfH);
        ctx.translate(this.viewX, this.viewY);
        ctx.scale(this.viewK, this.viewK);

        // --- æ›´æ–°å¯è§æ€§ ---
        this.updateVisibility(focusNode, hoverNode, previewNode, viewLayers, nodes, links);
        const { nodes: visibleNodeSet, links: visibleLinkSet } = this.visCache;

        // ==========================================
        // ç»˜åˆ¶è¿çº¿ (Links)
        // ==========================================
        const fadeStep = deltaTime / this.FADE_DURATION;
        const linksLen = links.length;

        for (let i = 0; i < linksLen; i++) {
            const l = links[i];
            const isVis = visibleLinkSet.has(l);

            // Alpha æ¸å˜æ’å€¼
            if(isVis && l.alpha < 1) l.alpha += fadeStep;
            else if(!isVis && l.alpha > 0) l.alpha -= fadeStep;
            // é’³ä½ (Clamp) é˜²æ­¢è¶Šç•Œ
            if (l.alpha > 1) l.alpha = 1;
            if (l.alpha < 0) l.alpha = 0;

            // åªç»˜åˆ¶å¯è§åº¦ > 1% çš„çº¿
            if(l.alpha > 0.01) {
                const src = l.source, tgt = l.target;

                // åˆ¤æ–­æ˜¯å¦éœ€è¦é«˜äº®
                const isFocusLink = (src===focusNode || tgt===focusNode);
                const isHigh = (hoverNode && (src===hoverNode||tgt===hoverNode)) ||
                               (previewNode && (src===previewNode||tgt===previewNode));

                // è°ƒæ•´é€æ˜åº¦å’Œçº¿å®½
                const mult = isFocusLink ? 1.0 : (isHigh ? 0.7 : 0.4);
                ctx.globalAlpha = l.alpha * mult;
                ctx.lineWidth = (isFocusLink || isHigh) ? 2.5 : 1.5;

                // [ä¼˜åŒ–] O(1) æŸ¥æ‰¾é¢œè‰²
                const preset = this.presetMap.get(l.type);
                const typeColor = preset ? preset.color : '#666';

                // ç»˜åˆ¶æ¸å˜çº¿
                const grad = ctx.createLinearGradient(src.x, src.y, tgt.x, tgt.y);
                grad.addColorStop(0, typeColor);
                grad.addColorStop(1, "#88888888"); // å°¾ç«¯åŠé€æ˜

                ctx.strokeStyle = grad;
                ctx.beginPath();
                ctx.moveTo(src.x, src.y);
                ctx.lineTo(tgt.x, tgt.y);
                ctx.stroke();

                // å¦‚æœæ˜¯ç„¦ç‚¹ç›¸å…³çš„çº¿ï¼Œç»˜åˆ¶æ–‡å­—æ ‡ç­¾
                if (l.type && isFocusLink) {
                     const mx = (src.x+tgt.x)/2, my = (src.y+tgt.y)/2;
                     ctx.save();
                     ctx.translate(mx, my);
                     ctx.rotate(-this.viewRotation); // æ–‡å­—å§‹ç»ˆä¿æŒæ°´å¹³ï¼ŒæŠµæ¶ˆç”»å¸ƒæ—‹è½¬
                     ctx.fillStyle = typeColor;
                     ctx.font = "11px Arial";
                     ctx.textAlign="center";
                     // ä¼˜å…ˆæ˜¾ç¤º Labelï¼Œæ²¡æœ‰åˆ™æ˜¾ç¤º Type
                     ctx.fillText(preset ? preset.label : l.type, 0, -8);
                     ctx.restore();
                }
            }
        }
        ctx.restore(); // è¿çº¿ç»˜åˆ¶å®Œæ¯•ï¼Œæ¢å¤çŸ©é˜µ

        // ==========================================
        // ç»˜åˆ¶èŠ‚ç‚¹ (Nodes)
        // ==========================================
        // [ä¼˜åŒ–] é¢„è®¡ç®—ä¸‰è§’å‡½æ•°ï¼Œä¾›å¾ªç¯å†…ä½¿ç”¨
        const cos = Math.cos(this.viewRotation);
        const sin = Math.sin(this.viewRotation);
        // å‘¼å¸ç¯æ•ˆæœ (Sine Wave)
        const pulse = Math.sin(currentTime * 0.002) * 0.5 + 1;
        let visibleCount = 0;

        const sqrtViewK = Math.sqrt(this.viewK);
        const stopRangeScaled = this.HOVER_STOP_RANGE;
        const rangeDiff = this.PROXIMITY_RANGE - stopRangeScaled;

        const nodesLen = nodes.length;
        for (let i = 0; i < nodesLen; i++) {
            const n = nodes[i];
            const isVis = visibleNodeSet.has(n.uuid);

            // ç„¦ç‚¹æ°¸è¿œä¸é€æ˜ï¼Œå…¶ä»–èŠ‚ç‚¹æ¸å˜
            if(n === focusNode) n.alpha = 1;
            else {
                if(isVis && n.alpha < 1) n.alpha += fadeStep;
                else if(!isVis && n.alpha > 0) n.alpha -= fadeStep;
                if (n.alpha > 1) n.alpha = 1;
                if (n.alpha < 0) n.alpha = 0;
            }

            if (n.alpha > 0.01) {
                visibleCount++;

                // --- [å…³é”®ä¼˜åŒ–] æ‰‹åŠ¨è®¡ç®—å±å¹•åæ ‡ ---
                // ä¸ºä»€ä¹ˆä¸è®© canvas å¤„ç†ï¼Ÿå› ä¸ºæˆ‘ä»¬éœ€è¦ n._screenX æ¥åšé¼ æ ‡äº¤äº’æ£€æµ‹å’Œæ–‡å­—æ’ç‰ˆ
                // å…¬å¼: å…ˆç¼©æ”¾å¹³ç§» -> å†ç»•ä¸­å¿ƒç‚¹æ—‹è½¬
                const p_unrotated_x = n.x * this.viewK + this.viewX;
                const p_unrotated_y = n.y * this.viewK + this.viewY;
                const p_shifted_x = p_unrotated_x - halfW;
                const p_shifted_y = p_unrotated_y - halfH;

                // æ—‹è½¬å˜æ¢å…¬å¼: x' = x*cos - y*sin
                const screen_x_rotated = p_shifted_x * cos - p_shifted_y * sin;
                const screen_y_rotated = p_shifted_x * sin + p_shifted_y * cos;
                n._screenX = screen_x_rotated + halfW;
                n._screenY = screen_y_rotated + halfH;

                // çŠ¶æ€åˆ¤æ–­
                const isFocus = (n === focusNode);
                const isPreview = (n === previewNode);
                const isHover = (n === hoverNode);
                const isSlot = slots.includes(n);

                // --- é¼ æ ‡æ¥è¿‘æ”¾å¤§ç®—æ³• ---
                let proximityScale = 1.0;
                if (isFocus) {
                    proximityScale = 1.0; // ç„¦ç‚¹æœ¬èº«ä¸æ”¾å¤§
                } else if (isPreview) {
                    proximityScale = this.MAX_SCALE_MULT; // é”®ç›˜é€‰ä¸­æ—¶æœ€å¤§åŒ–
                } else {
                    // è®¡ç®—é¼ æ ‡è·ç¦»
                    const dx = n._screenX - mouseX;
                    const dy = n._screenY - mouseY;
                    const dist = Math.hypot(dx, dy) / sqrtViewK;

                    if (dist < stopRangeScaled) {
                        // è¿›å…¥æ ¸å¿ƒåŒºï¼Œæœ€å¤§æ”¾å¤§
                        proximityScale = this.MAX_SCALE_MULT;
                    } else if (dist < this.PROXIMITY_RANGE) {
                        // åœ¨æ„Ÿåº”åŒºï¼Œä½¿ç”¨æ’å€¼å¹³æ»‘æ”¾å¤§
                        const effectiveDist = dist - stopRangeScaled;
                        const ratio = 1 - (effectiveDist / rangeDiff);
                        // ä¹˜å¹³æ–¹è®©å˜åŒ–æ›²çº¿æ›´é¡ºæ»‘
                        proximityScale = 1 + (this.MAX_SCALE_MULT - 1) * (ratio * ratio);
                    }
                }

                // --- åŠå¾„ä¸å…‰æ™•è®¡ç®— ---
                let baseRadius = isFocus ? 20 : 10;
                let rawRadius = baseRadius * this.viewK;
                // ç¡®ä¿èŠ‚ç‚¹ä¸ä¼šç¼©åˆ°çœ‹ä¸è§
                let coreRadius = isFocus
                    ? (rawRadius < this.MIN_FOCUS_NODE_PIXEL_SIZE ? this.MIN_FOCUS_NODE_PIXEL_SIZE : rawRadius)
                    : ((rawRadius < this.MIN_NODE_PIXEL_SIZE ? this.MIN_NODE_PIXEL_SIZE : rawRadius));

                let baseBlur = isFocus ? 35 : 15;
                let minBlur = isFocus ? 10 : 5;
                let glowRadius = baseBlur * this.viewK;
                if (glowRadius < minBlur) glowRadius = minBlur;

                // åº”ç”¨é¼ æ ‡æ”¾å¤§
                coreRadius *= proximityScale;
                glowRadius *= proximityScale;
                n._renderRadius = coreRadius + (glowRadius * 0.2); // ä¾›å¤–éƒ¨ä½¿ç”¨çš„äº¤äº’åŠå¾„

                // --- ç»˜åˆ¶åœ†å½¢ä¸é˜´å½± ---
                ctx.globalAlpha = (isFocus ? 1 : n.alpha);
                ctx.beginPath();
                ctx.arc(n._screenX, n._screenY, coreRadius, 0, 2*Math.PI);
                ctx.fillStyle = n.color || this.DEFAULT_NODE_COLOR;

                // å…‰æ™•å¤„ç† (ShadowBlur è¾ƒè€—æ€§èƒ½ï¼Œä½†æ•ˆæœå¥½)
                if(isFocus && linkMode.active) {
                    ctx.shadowBlur = glowRadius * pulse; // è¿çº¿æ¨¡å¼ä¸‹å‘¼å¸
                    ctx.shadowColor = linkMode.color || '#fff';
                } else {
                    ctx.shadowBlur = glowRadius;
                    ctx.shadowColor = (isFocus || isPreview) ? ctx.fillStyle : (n.color || this.DEFAULT_NODE_COLOR);
                }

                // è¾¹æ¡†ç»˜åˆ¶
                if (isFocus && linkMode.active) {
                    ctx.strokeStyle = linkMode.color || '#fff'; ctx.lineWidth = 3; ctx.stroke();
                }
                if(isSlot && !isFocus) {
                    ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke();
                }

                ctx.fill(); // å¡«å……å®å¿ƒåœ†
                ctx.shadowBlur = 0; // é‡ç½®é˜´å½±ï¼Œé¿å…å½±å“æ–‡å­—

                // --- æ–‡å­—ç»˜åˆ¶ (æ€§èƒ½ä¼˜åŒ–) ---
                // åªæœ‰å½“èŠ‚ç‚¹è¶³å¤Ÿå¤§ï¼Œæˆ–è€…é¼ æ ‡é è¿‘æ—¶æ‰ç”»å­—ï¼Œå¦åˆ™åªç”»åœ†ç‚¹
                const showText = (this.viewK > 0.4) || (proximityScale > 1.1) || isFocus || isPreview;
                if (showText) {
                    ctx.fillStyle = (isFocus || isPreview || isHover) ? "#fff" : "rgba(200,200,200,0.8)";

                    let baseFontSize = isFocus ? 22 : 11;
                    const scaledFontSize = baseFontSize * sqrtViewK * proximityScale;

                    if(scaledFontSize > 5) { // å­—ä½“å¤ªå°å°±ä¸æ¸²æŸ“äº†
                        const fontWeight = (isFocus) ? "bold" : "normal";
                        ctx.font = `${fontWeight} ${scaledFontSize}px Arial`;
                        ctx.textAlign = "center";
                        const textY = n._screenY + coreRadius + scaledFontSize + 2;
                        ctx.fillText(n.label, n._screenX, textY);

                        // ç»˜åˆ¶å¿«æ·é”®æ§½ä½ç´¢å¼• [1], [2]...
                        if (isSlot) {
                            const sIdx = slots.indexOf(n);
                            if (sIdx >= 0) {
                                ctx.fillStyle = "#4facfe";
                                ctx.font = `bold ${scaledFontSize}px monospace`;
                                ctx.fillText(`[${sIdx+1}]`, n._screenX, n._screenY - coreRadius - (scaledFontSize*0.5));
                            }
                        }
                    }
                }
            }
        }

        // --- æ›´æ–° DOM è®¡æ•°å™¨ ---
        if (this.uiRefs.layerIndicator) this.uiRefs.layerIndicator.innerText = viewLayers;
        if (this.uiRefs.visibleCount) this.uiRefs.visibleCount.innerText = visibleCount;

        // ä¿æŒç‰©ç†å¼•æ“æ´»è·ƒ (å®ç°æ— é™é£˜åŠ¨æ•ˆæœ)
        if (this.simulation.alpha() < 0.1) this.simulation.alpha(0.1).restart();

        // è¯·æ±‚ä¸‹ä¸€å¸§
        requestAnimationFrame((t) => this.render(t));
    },

    // ==========================================
    // åæ ‡è½¬æ¢: å±å¹•(é¼ æ ‡) -> ä¸–ç•Œ(ç‰©ç†)
    // ==========================================
    screenToWorld(sx, sy) {
        const rect = this.canvas.getBoundingClientRect();
        const halfW = this.width / 2;
        const halfH = this.height / 2;

        // 1. å½’ä¸€åŒ–åˆ°ä»¥ Canvas ä¸­å¿ƒä¸ºåŸç‚¹
        let x = (sx - rect.left) - halfW;
        let y = (sy - rect.top) - halfH;

        // 2. é€†å‘æ—‹è½¬ (World = Screen * ReverseRotation)
        const cos = Math.cos(-this.viewRotation);
        const sin = Math.sin(-this.viewRotation);
        let rx = x * cos - y * sin;
        let ry = x * sin + y * cos;

        // 3. é€†å‘å¹³ç§»å’Œç¼©æ”¾
        return {
            x: (rx + halfW - this.viewX) / this.viewK,
            y: (ry + halfH - this.viewY) / this.viewK
        };
    },

    // è®¾ç½®ç›®æ ‡æ—‹è½¬è§’åº¦ (ä¾›å¤–éƒ¨è°ƒç”¨)
    setTargetRotation(rad) {
        let diff = rad - this.targetRotation;
        // ç¡®ä¿èµ°æœ€çŸ­æ—‹è½¬è·¯å¾„
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        this.targetRotation += diff;
    }
};

// ==========================================
// 6. Input (äº¤äº’æ§åˆ¶)
// ==========================================
App.Input = {
    state: {
        hoverNode: null,
        previewNode: null,
        linkMode: { active: false, source: null, type: null, color: null },
        dragNode: null,
        click: { startTime: 0, startX: 0, startY: 0 },
        keyState: {},
        keyControlsVisible: true,
        mouseX: 0,
        mouseY: 0,
    },

    init() {
        const C = App.Renderer.canvas;
        C.addEventListener('mousedown', this.onMouseDown.bind(this));
        C.addEventListener('mouseup', this.onMouseUp.bind(this));
        C.addEventListener('mousemove', this.onMouseMove.bind(this));
        C.addEventListener('dblclick', this.onMouseDoubleClick.bind(this));
        C.addEventListener('wheel', this.onWheel.bind(this), {passive:false});
        C.addEventListener('contextmenu', this.onContextMenu.bind(this));
        window.addEventListener('keydown', this.onKeyDown.bind(this));
        window.addEventListener('keyup', (e) => {
            this.state.keyState[e.key] = false;
            if(e.key==='Shift') this.state.keyState['Shift'] = false;
        });
    },

    // --- Action Handlers ---

    safeNavigate(node, recordHistory = true) {
        if (!node) return;
        if (this.state.linkMode.active && this.state.linkMode.type === 'DELETE') {
            const { focusNode, nodes, links } = App.Store.state;
            const linkIndex = links.findIndex(l =>
                (l.source.uuid===focusNode.uuid && l.target.uuid===node.uuid) ||
                (l.source.uuid===node.uuid && l.target.uuid===focusNode.uuid)
            );
            if (linkIndex !== -1) {
                App.Store.executeSafeAction(() => ({
                    nodes: nodes,
                    links: links.filter(l => l !== links[linkIndex]),
                    nextFocus: node,
                    nextSlots: App.Store.state.slots
                }), () => {
                    if (recordHistory) App.Store.pushHistory(focusNode);
                    this.exitLinkMode();
                });
                return;
            } else {
                this.exitLinkMode();
            }
        }
        if (this.state.linkMode.active) {
            this.navigate(node, recordHistory);
            return;
        }
        // Wrap in Safe Action
        const { focusNode } = App.Store.state;
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes,
            links: App.Store.state.links,
            nextFocus: node,
            nextSlots: App.Store.state.slots
        }), () => {
            if (recordHistory) {
                App.Store.pushHistory(focusNode);
            }
            this.state.previewNode = null;
            this.hideTooltip();
        });
        // Note: executeSafeAction will call navigateTo if safe via its applyState
    },

    navigate(node, recordHistory = true) {
        if(!node) return;
        const { linkMode } = this.state;
        // Link Mode Logic
        if (linkMode.active && linkMode.source && linkMode.source.uuid !== node.uuid) {
            this.executeLinkAction(linkMode.source, node);
            this.exitLinkMode();
            // Note: Does NOT return, continues to navigate
        }

        const { focusNode } = App.Store.state;
        if(recordHistory) {
            App.Store.pushHistory(focusNode);
        }

        App.Store.state.focusNode = node;
        node.alpha = 1;
        this.state.previewNode = null;
        this.hideTooltip();

        App.UI.updateSidebar();
        App.Store.save();
        App.Renderer.restartSim();
    },

    executeLinkAction(source, target) {
        const { links } = App.Store.state;
        const existing = links.find(l =>
            (l.source.uuid === source.uuid && l.target.uuid === target.uuid) ||
            (l.source.uuid === target.uuid && l.target.uuid === source.uuid)
        );
        const { type } = this.state.linkMode;

        if (type === 'DELETE') {
            if(existing) {
                App.Store.executeSafeAction(() => ({
                    nodes: App.Store.state.nodes,
                    links: links.filter(l => l!==existing),
                    nextFocus: target,
                    nextSlots: App.Store.state.slots
                }));
            } else App.UI.showFlash(t('alert.noLinkToBreak'), 'info');
        } else {
            if(existing) { existing.type = type; existing.source = source; existing.target = target; }
            else { links.push({source, target, type, alpha: 0}); }
            App.Renderer.restartSim();
        }
    },

    async enterLinkMode() {
        if(this.state.linkMode.active) return;
        try {
            const res = await App.UI.RelationPicker.show(true);
            const mode = { active: true, source: App.Store.state.focusNode, type: res.val, color: '#fff' };

            if (res.val === 'CUSTOM') {
                const cLabel = await App.UI.Dialog.prompt(t('linkMode.prompt'), t('linkMode.promptPlaceholder'));
                if(!cLabel) { this.exitLinkMode(); return; }
                const preset = App.Store.state.presets.find(p=>p.label===cLabel);
                mode.type = preset ? preset.val : cLabel;
            } else if (res.val === 'DELETE') {
                mode.color = '#ff4d4d';
            } else {
                const p = App.Store.state.presets.find(x => x.val === res.val);
                if(p) mode.color = p.color;
            }

            this.state.linkMode = mode;
            this.updateLinkModeIndicator();
        } catch(e) { this.exitLinkMode(); }
    },

    exitLinkMode() {
        this.state.linkMode = { active: false, source: null, type: null, color: null };
        this.updateLinkModeIndicator();
    },

    updateLinkModeIndicator() {
        const el = document.getElementById('link-mode-indicator');
        if (this.state.linkMode.active) {
            el.innerHTML = t('linkMode.typeIndicator', {color: this.state.linkMode.color, type: this.state.linkMode.type});
            el.classList.add('active');
            el.style.display = 'inline-block';
        } else {
            el.innerHTML = t('hud.linkMode');
            el.classList.remove('active');
            el.style.display = 'none';
        }
    },

    handleSlotClick(idx, isShift) {
        if (isShift) this.handleSlotStore(idx);
        else this.handleSlot(idx);
    },

    handleSlot(idx) {
        const { slots, focusNode } = App.Store.state;
        const slotNode = slots[idx];
        if (slotNode === focusNode) return;

        if (slotNode) {
            slots[idx] = focusNode;
            App.UI.updateSlotUI();
            this.navigate(slotNode, true);
        } else {
            // Store logic
            slots[idx] = focusNode;
            App.UI.updateSlotUI();
            App.Store.save();
        }
    },

    clearSlot(idx) {
        const { slots, nodes, links, focusNode } = App.Store.state;
        if(!slots[idx]) return;
        App.Store.executeSafeAction(() => ({
            nodes,
            links,
            nextFocus: focusNode,
            nextSlots: slots.map((s,i)=>i===idx?null:s)
        }));
    },

    handleSlotStore(idx) {
        const { slots, focusNode, nodes, links } = App.Store.state;
        if(slots[idx]===focusNode) return;
        App.Store.executeSafeAction(() => ({
            nodes,
            links,
            nextFocus: focusNode,
            nextSlots: slots.map((s,i)=>i===idx?focusNode:s)
        }));
    },

    // --- Mouse Events ---

    onMouseDown(e) {
        if(App.UI.Dialog.isActive) return;
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(e.button===3) { e.preventDefault(); this.safeNavigateBack(); return; }
        if(e.button===4) { e.preventDefault(); this.enterLinkMode(); return; }
        if(e.button!==0) return;

        const node = this.pickNode(e.clientX, e.clientY);
        this.state.mouseX = e.clientX;
        this.state.mouseY = e.clientY;
        this.state.dragNode = node;
        this.state.click = {
            startX: e.clientX, startY: e.clientY,
            startTime: performance.now(),
        };

        if(node) {
            this.state.hoverNode = null;
            this.state.previewNode = null;
            this.hideTooltip();
            App.Renderer.canvas.style.cursor = 'grabbing';
        } else {
            App.UI.RelationPicker.close();
            App.UI.PresetEditor.close();
        }
    },

    onMouseMove(e) {
        // æ— è®ºä»€ä¹ˆæƒ…å†µï¼Œå…ˆæ›´æ–°å±å¹•åæ ‡
        this.state.mouseX = e.clientX;
        this.state.mouseY = e.clientY;
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(this.state.dragNode) return;
        const node = this.pickNode(e.clientX, e.clientY);
        if(node) {
            this.state.hoverNode = node;
            this.state.previewNode = null;
            const html = typeof marked!=='undefined'
                ? marked.parse(node.summary||'')
                : node.summary;
            this.showTooltip(t('tooltip.nodeHover', {label: node.label, summary: html}), e.clientX, e.clientY, 'mouse');
        } else {
            this.state.hoverNode = null;
            if(!this.state.previewNode) this.hideTooltip();
        }
    },

    onMouseUp(e) {
        if(e.button!==0 || !this.state.dragNode) return;

        // æ¸…ç†ç‰©ç†çŠ¶æ€ (è™½ç„¶ render é‡Œä¸å†æ›´æ–°äº†ï¼Œä½†æ˜¾å¼æ–­å¼€å¼•ç”¨æ˜¯ä¸ªå¥½ä¹ æƒ¯)
        const node = this.state.dragNode;
        if(node) {
            App.Renderer.pointerForce.node(null).target(null);
            App.Store.save();
            App.Renderer.canvas.style.cursor = 'crosshair';
        }
        this.state.dragNode = null; // å…³é”®ï¼šè¿™ä¸€è¡Œä¼šè®© render å¾ªç¯åœæ­¢æ›´æ–°ç‰©ç†åŠ›

        // Click Threshold Logic
        const {startTime, startX, startY} = this.state.click;
        move = Math.hypot(e.clientX - startX, e.clientY - startY);
        if(performance.now() - startTime < 200 && move < 8) {
            const target = node || this.pickNode(e.clientX, e.clientY);
            if(target) {
                if(target !== App.Store.state.focusNode) this.safeNavigate(target);
                else App.UI.Modal.show();
            }
        }
    },

    onMouseDoubleClick(e) {
        console.log("awa")
        if(App.UI.Modal.el.classList.contains('active') || App.UI.Dialog.isActive) return;
        if(e.button===3) { e.preventDefault(); this.safeNavigateBack(); return; }
        if(e.button===4) { e.preventDefault(); this.enterLinkMode(); return; }
        if(e.button!==0) return;

        const node = this.pickNode(e.clientX, e.clientY);

        if(node) {
        } else {
            this.createDefaultLinkedNode(App.Renderer.screenToWorld(e.clientX, e.clientY));
        }
    },

    onContextMenu(e) {
        e.preventDefault();
        const node = this.pickNode(e.clientX, e.clientY);
        if(node) { this.deleteNode(node); return; }
        const link = this.pickLink(e.clientX, e.clientY);
        if(link) { this.deleteLink(link); return; }
    },

    onWheel(e) {
        e.preventDefault();
        const scaleFactor = 1.05;
        App.Renderer.viewK = Math.min(10,
            App.Renderer.viewK * (e.deltaY < 0 ? scaleFactor : (1/scaleFactor))
        );
    },

    // --- Keyboard Events ---

    onKeyDown(e) {
        if(App.UI.Dialog.isActive) return;
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(App.UI.PresetEditor.active) { if(e.key==='Escape' || e.key==='`') App.UI.PresetEditor.close(); return; }
        if(App.UI.RelationPicker.active) { App.UI.RelationPicker.handleInput(e); return; }

        if(['INPUT','TEXTAREA'].includes(e.target.tagName)) {
            if(e.key==='Escape') { e.target.blur(); }
            if(e.key==='Enter' && e.target.id==='node-label') {
                e.preventDefault();
                e.target.blur();
            }
            return;
        }

        this.state.keyState[e.key] = true; if(e.shiftKey) this.state.keyState['Shift']=true;

        const isSlot = (e.key>='1' && e.key<='4');
        if(['!','@','#','$'].includes(e.key)) { this.handleSlotStore({'!':0,'@':1,'#':2,'$':3}[e.key]); return; }
        if(e.shiftKey && isSlot) { this.handleSlotStore(parseInt(e.key)-1); return; }
        if(isSlot) { this.handleSlot(parseInt(e.key)-1); return; }

        switch(e.key) {
            // FIX: Use safeNavigate
            case '/': this.jumpDirection(-Math.PI/2, true); break;
            case '?': this.jumpDirection(Math.PI/2, true); break;
            case 'w': case 'W': case 'ArrowUp': this.jumpDirection(-Math.PI/2, e.shiftKey); break;
            case 's': case 'S': case 'ArrowDown': this.jumpDirection(Math.PI/2, e.shiftKey); break;
            case 'a': case 'A': case 'ArrowLeft': this.jumpDirection(Math.PI, e.shiftKey); break;
            case 'd': case 'D': case 'ArrowRight': this.jumpDirection(0, e.shiftKey); break;
            case 'q': case ',': this.cyclePreview(-1); break;
            case 'e': case '.': this.cyclePreview(1); break;
            case '=': case '+': App.Store.state.viewLayers = Math.max(1, App.Store.state.viewLayers-1); App.Renderer.restartSim(); break;
            case '-': case '_': App.Store.state.viewLayers = App.Store.state.viewLayers+1; App.Renderer.restartSim(); break;
            case 'Tab': e.preventDefault(); this.createDefaultLinkedNode(); break;
            case 'n': case 'N': e.preventDefault(); this.createNode(); break;
            case 'F2': e.preventDefault(); App.UI.els.label.focus(); App.UI.els.label.select(); break;
            case ' ': e.preventDefault(); App.UI.els.label.focus(); App.UI.els.label.select(); break;
            case 'Enter': if(App.Store.state.focusNode) App.UI.Modal.show(); break;
            case 'l': case 'L': this.enterLinkMode(); break;
            case 'h': case 'H': const root = App.Store.state.nodes.find(n=>n.isRoot); if(root) this.safeNavigate(root); break;
            case 'Escape': if(this.state.linkMode.active) this.exitLinkMode(); break;
            case 'b': case 'B': this.safeNavigateBack(); break;
            case 'Delete': case 'x': case 'X': this.deleteNode(); break;
            case 'i': case 'I': e.preventDefault(); this.state.keyControlsVisible=!this.state.keyControlsVisible; document.getElementById('key-controls').style.display=this.state.keyControlsVisible?'block':'none'; break;
            case '`': e.preventDefault(); App.UI.PresetEditor.open(); break;
        }
    },

    // --- Complex Logic Helpers ---

    createDefaultLinkedNode(node) {
        const { focusNode, presets } = App.Store.state;
        if (!focusNode) return;
        // 1. è·å–ç¬¬ä¸€ä¸ªé¢„è®¾å…³ç³» (å¯¹åº” "å›è½¦é€‰æ‹©ç¬¬ä¸€ä¸ª")
        // å¦‚æœæ²¡æœ‰é¢„è®¾ï¼Œå…œåº•ä½¿ç”¨ "comp"
        const defaultPreset = presets.length > 0
            ? presets[0]
            : App.Store.DEFAULT_PRESETS[0];
        // 2. æ‰‹åŠ¨æ¿€æ´»è¿çº¿æ¨¡å¼çŠ¶æ€ (å¯¹åº” "æŒ‰L")
        // æˆ‘ä»¬ä¸éœ€è¦çœŸçš„æ‰“å¼€UIï¼Œåªéœ€è¦è®¾ç½®çŠ¶æ€ï¼Œå› ä¸º createNode ä¼šè¯»å–è¿™ä¸ªçŠ¶æ€
        if (!this.state.linkMode.active) {
            this.state.linkMode = {
                active: true,
                source: focusNode,
                type: defaultPreset.val,
                color: defaultPreset.color
            };
        }
        // 3. è°ƒç”¨åŸæœ‰çš„åˆ›å»ºé€»è¾‘ (å¯¹åº” "æŒ‰N")
        // createNode å†…éƒ¨æ£€æµ‹åˆ° linkMode.active ä¸º true æ—¶ï¼Œ
        // ä¼šè‡ªåŠ¨å»ºç«‹è¿æ¥ã€é€€å‡ºè¿çº¿æ¨¡å¼å¹¶è·³è½¬ç„¦ç‚¹
        this.createNode(node);
    },

    createNode(node) {
        const { focusNode, nodes, links, slots } = App.Store.state;

        // å›ºå®šé•¿åº¦éšæœºä¸€ä¸ªè§’åº¦è¿›è¡Œåç§»
        const distance = App.Renderer.LINK_DISTANCE;
        const angle = Math.random() * 2 * Math.PI;
        const [ offsetX, offsetY ] = [ distance * Math.cos(angle), distance * Math.sin(angle) ];

        const newNode = {
            uuid: uuid.v4(), label: t('fallback.newNode'),
            x: focusNode.x + offsetX, y: focusNode.y + offsetY,
            summary: "", content: "", color: App.Utils.getRandomColor(), alpha: 0,
            ...node,
        };

        // If LinkMode, we skip safe check because we create a link immediately
        if (this.state.linkMode.active && this.state.linkMode.type !== 'DELETE') {
            nodes.push(newNode);
            App.Renderer.restartSim();
            this.executeLinkAction(this.state.linkMode.source, newNode);
            this.exitLinkMode();
            this.navigate(newNode, true);
            // setTimeout(() => { App.UI.els.label.focus(); App.UI.els.label.select(); }, 50);
        } else {
            // Safe Create
            const { focusNode } = App.Store.state;
            App.Store.executeSafeAction(() => ({
                nodes: [...nodes, newNode],
                links,
                nextFocus: newNode,
                nextSlots: slots
            }),  () => {
                App.Store.pushHistory(focusNode);
                // setTimeout(() => { App.UI.els.label.focus(); App.UI.els.label.select(); }, 50);
            });
        }
    },

    deleteNode(target = null) {
        const node = target || App.Store.state.focusNode;
        if(node.isRoot) { App.UI.showFlash(t('alert.rootCannotDelete'), 'warn'); return; }

        const { focusNode, navHistory, nodes, links, slots } = App.Store.state;

        let nextFocus = null;
        if (focusNode && node !== focusNode) {
            nextFocus = focusNode;
        } else {
            // --- é¢„åˆ¤ä¸‹ä¸€è·³ ---
            const backIdx = App.Store.getBackNodeIndex();

            if (backIdx >= 0) {
                // ç”¨å†å²è®°å½•çš„ UUID å»æ‰¾â€œæ´»ä½“â€èŠ‚ç‚¹ï¼Œé˜²æ­¢ä½¿ç”¨è¿‡æœŸçš„å†å²å¿«ç…§
                const uuid = navHistory[backIdx].uuid;
                nextFocus = nodes.find(n => n.uuid === uuid);
            }

            // å…œåº•é€»è¾‘
            if (!nextFocus) {
                nextFocus = nodes.find(n => n.isRoot) || nodes.find(n => n.uuid !== node.uuid);
            }
        }

        App.Store.executeSafeAction(
            () => ({
                nodes: nodes.filter(n => n.uuid !== node.uuid),
                links: links.filter(l => l.source.uuid !== node.uuid && l.target.uuid !== node.uuid),
                nextFocus: nextFocus,
                nextSlots: slots.map(s => (s && s.uuid === node.uuid) ? null : s)
            }),
            () => {
                App.Store.state.navHistory = App.Store.state.navHistory.filter(n => n.uuid !== node.uuid);
            }
        );
    },

    deleteLink(link) {
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes,
            links: App.Store.state.links.filter(l=>l!==link),
            nextFocus: App.Store.state.focusNode,
            nextSlots: App.Store.state.slots
        }));
    },

    safeNavigateBack() {
        const backIdx = App.Store.getBackNodeIndex();
        const { navHistory, nodes } = App.Store.state;

        if (backIdx >= 0) {
            const targetUUID = navHistory[backIdx].uuid;
            App.Store.state.navHistory.splice(backIdx + 1);
            const targetNode = nodes.find(n => n.uuid === targetUUID)
            if (targetNode) {
                this.safeNavigate(targetNode, false);
            }
        } else {
            App.UI.showFlash(t('flash.noHistory'), 'info');
        }
    },

    // --- Radar/Preview Logic ---

    getNeighbors() {
        const { links, focusNode } = App.Store.state;
        const list = [];
        links.forEach(l => {
            let other = null;
            if(l.source.uuid===focusNode.uuid) other = l.target;
            else if(l.target.uuid===focusNode.uuid) other = l.source;
            if(other) {
                const dx = other.x - focusNode.x, dy = other.y - focusNode.y;
                const rawAng = Math.atan2(dy, dx);
                let vAng = rawAng + App.Renderer.viewRotation;
                while(vAng > Math.PI) vAng -= 2*Math.PI; while(vAng <= -Math.PI) vAng += 2*Math.PI;
                list.push({ node: other, vAngle: vAng, rawAngle: rawAng });
            }
        });
        return list.sort((a,b) => a.vAngle - b.vAngle);
    },

    cyclePreview(dir) {
        const neighbors = this.getNeighbors();
        if(!neighbors.length) return;
        this.hideTooltip();

        const UP = -Math.PI/2;
        const THRESHOLD = 0.087; // approx 5 deg
        const exact = neighbors.find(n => Math.abs(n.vAngle - UP) < THRESHOLD);

        // Logic: Exact Top Priority
        const currentIsExact = exact && this.state.previewNode && this.state.previewNode.uuid === exact.node.uuid;

        if (exact && !currentIsExact) {
            this.setPreview(exact);
            return;
        }

        let target = null;
        if (dir > 0) { // Clockwise
            target = neighbors.find(n => n.vAngle > UP && (!exact || n.node.uuid !== exact.node.uuid));
            if (!target) target = neighbors.find(n => (!exact || n.node.uuid !== exact.node.uuid)); // Wrap
        } else { // Counter-Clockwise
            // Find last one smaller than UP
            for(let i=neighbors.length-1; i>=0; i--) {
                if(neighbors[i].vAngle < UP && (!exact || neighbors[i].node.uuid !== exact.node.uuid)) { target=neighbors[i]; break; }
            }
            if(!target) { // Wrap to end
                for(let i=neighbors.length-1; i>=0; i--) {
                    if(!exact || neighbors[i].node.uuid !== exact.node.uuid) { target=neighbors[i]; break; }
                }
            }
        }

        if(target) this.setPreview(target);
    },

    setPreview(targetWrapper) {
        this.state.previewNode = targetWrapper.node;
        App.Renderer.setTargetRotation(-Math.PI/2 - targetWrapper.rawAngle);
        const html = (typeof marked!=='undefined' ? marked.parse(this.state.previewNode.summary||'') : this.state.previewNode.summary) || '';
        this.showTooltip(t('tooltip.preview', {label: this.state.previewNode.label, summary: html}), 0, 0, 'fixed');
    },

    jumpDirection(targetAng, shiftKey) {
        const neighbors = this.getNeighbors();
        let best = null, minDiff = 1.2; // Threshold ~68 deg
        let rawAngle = 0, vAngle = 0;
        neighbors.forEach(n => {
            let diff = Math.abs(n.vAngle - targetAng);
            if (diff > Math.PI) diff = 2*Math.PI - diff;
            if (diff < minDiff) {
                minDiff = diff;
                best = n.node;
                rawAngle = n.rawAngle;
                vAngle = n.vAngle;
            }
        });
        if(best) {
            if (shiftKey) {
                App.Renderer.setTargetRotation(targetAng - rawAngle);
            }
            this.safeNavigate(best);
        }
    },

    // --- Helpers ---


    pickNode(sx, sy) {
        const nodes = App.Store.state.nodes;
        // è·å–é¼ æ ‡ç›¸å¯¹äº Canvas å…ƒç´ çš„åæ ‡ (CSS åƒç´ )
        const rect = App.Renderer.canvas.getBoundingClientRect();
        const mouseCanvasX = sx - rect.left;
        const mouseCanvasY = sy - rect.top;
        // å€’åºéå†ï¼šä»æœ€ä¸Šå±‚çš„èŠ‚ç‚¹å¼€å§‹åˆ¤æ–­
        for(let i = nodes.length - 1; i >= 0; i--) {
            const n = nodes[i];
            // 1. è¿‡æ»¤ä¸å¯è§èŠ‚ç‚¹ (alpha <= 0.01 ä¹Ÿå¯ä»¥ï¼Œæ ¹æ®éœ€è¦è°ƒæ•´)
            if(n.alpha <= 0.01) continue;
            // 2. å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿èŠ‚ç‚¹å·²ç»ç»è¿‡è‡³å°‘ä¸€æ¬¡æ¸²æŸ“ï¼Œæ‹¥æœ‰ _screenX å’Œ _renderRadius
            if (n._screenX === undefined || n._renderRadius === undefined) continue;
            // 3. è®¡ç®—é¼ æ ‡ç‚¹å‡»ä½ç½®ä¸èŠ‚ç‚¹ã€å±å¹•ä½ç½®ã€‘çš„è·ç¦»
            const dx = mouseCanvasX - n._screenX;
            const dy = mouseCanvasY - n._screenY;
            const distSq = dx * dx + dy * dy; // ä½¿ç”¨å¹³æ–¹è·ç¦»ï¼Œé¿å… Math.sqrtï¼Œæ€§èƒ½æ›´å¥½
            // 4. è·å–åˆ¤å®šåŠå¾„ (å·²ç»åœ¨ render ä¸­è€ƒè™‘äº†ç¼©æ”¾å’Œäº¤äº’å› ç´ ï¼Œæ˜¯èŠ‚ç‚¹å½“å‰çš„è§†è§‰åŠå¾„)
            const hitRadius = n._renderRadius;
            // 5. åˆ¤å®šï¼šå¦‚æœé¼ æ ‡è·ç¦»èŠ‚ç‚¹ä¸­å¿ƒå°äºæˆ–ç­‰äºå…¶è§†è§‰åŠå¾„
            if (distSq <= hitRadius * hitRadius) {
                return n; // è¿”å›è¢«ç‚¹å‡»çš„èŠ‚ç‚¹
            }
        }
        return null; // æ²¡æœ‰èŠ‚ç‚¹è¢«ç‚¹å‡»
    },


    pickLink(sx, sy) {
        const w = App.Renderer.screenToWorld(sx, sy);
        const links = App.Store.state.links;
        for(let l of links) {
            if(l.alpha < 0.3) continue;
            const x1 = l.source.x, y1 = l.source.y, x2 = l.target.x, y2 = l.target.y;
            const A = x2-x1, B = y2-y1;
            const lenSq = A*A+B*B;
            let t = ((w.x-x1)*A + (w.y-y1)*B) / lenSq;
            t = Math.max(0, Math.min(1, t));
            const dist = Math.hypot(w.x - (x1+t*A), w.y - (y1+t*B));
            if(dist < 10/App.Renderer.viewK) return l;
        }
        return null;
    },

    showTooltip(html, x, y, mode) {
        const t = document.getElementById('tooltip');
        t.innerHTML = html; t.style.opacity = 1;
        if(mode==='mouse') { t.className=''; t.style.left=(x+15)+'px'; t.style.top=(y+15)+'px'; t.style.transform='none'; }
        else { t.className='fixed-mode'; }
    },
    hideTooltip() {
        const t = document.getElementById('tooltip');
        t.style.opacity=0; t.className=''; t.style.left=''; t.style.top=''; t.style.transform='';
    }
};

// ==========================================
// Main Initialization
// ==========================================
window.onload = () => {
    App.I18n.init();
    // 1. åˆå§‹åŒ– Renderer (ç¡®ä¿ simulation å­˜åœ¨)
    App.Renderer.init();
    // 2. åˆå§‹åŒ– Store (ä¼šä¾èµ– Renderer çš„æ–¹æ³•)
    App.Store.init();
    // 3. åˆå§‹åŒ– UI
    App.UI.init();
    // 4. åˆå§‹åŒ– Input (ä¼šä¾èµ– Store å’Œ Renderer çš„æ–¹æ³•)
    App.Input.init();
};

</script>
</body>
</html>