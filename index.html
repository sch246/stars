<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>星罗 (Stars v4.1 Refined)</title>
    <!-- 引入 D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- 引入 UUID -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <!-- 引入 Marked.js 用于 Markdown 渲染 -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        /* --- 基础样式 --- */
        body { margin: 0; overflow: hidden; background-color: #050508; font-family: 'Segoe UI', sans-serif; color: #ddd; }
        #canvas { display: block; width: calc(100vw - var(--sidebar-width, 340px)); height: 100vh; cursor: crosshair; outline: none; }

        /* --- 侧边栏 --- */
        #sidebar {
            position: fixed; right: 0; top: 0; 
            width: var(--sidebar-width, 340px); /* 使用 CSS 变量控制宽度 */
            height: 100vh;
            background: #111114; border-left: 1px solid #2a2a30;
            padding: 25px; box-sizing: border-box; display: flex; flex-direction: column; z-index: 10;
            box-shadow: -5px 0 20px rgba(0,0,0,0.8);
        }
        /* 拖动条样式 */
        #sidebar-resizer {
            position: fixed; 
            right: var(--sidebar-width, 340px); /* 位于侧边栏左侧 */
            top: 0; 
            width: 8px; /* 拖动条宽度 */
            height: 100vh;
            background: #050508; /* 与边框颜色保持一致或稍深 */
            cursor: ew-resize; /* 左右拖动光标 */
            z-index: 11; /* 比侧边栏高一点，确保可点击 */
            transition: background 0.2s; /* 悬停效果 */
        }
        #sidebar-resizer:hover {
            background: #4facfe; /* 悬停时高亮 */
        }
        input, textarea { background: transparent; border: none; color: #eee; outline: none; width: 100%; display: block; font-family: 'Segoe UI', sans-serif; }
        input::placeholder, textarea::placeholder { color: #444; font-style: italic; }
        
        #node-label { font-size: 28px; font-weight: 700; margin-bottom: 8px; color: #4facfe; border-bottom: 2px solid #2a2a30; padding-bottom: 8px; }
        #node-label:focus { border-bottom-color: #4facfe; }
        
        #node-uuid { font-size: 10px; color: #444; font-family: monospace; margin-bottom: 5px; user-select: all;}
        
        #link-status { font-size: 12px; font-family: monospace; margin-bottom: 15px; color: #666; font-weight: bold; display: flex; justify-content: space-between;}
        #link-status.full { color: #ff4d4d; }
        
        /* 总结改为多行文本域 */
        #node-summary { 
            font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; 
            background: #0d0d0f; border: 1px solid transparent; border-radius: 4px; padding: 5px;
            height: 60px; resize: vertical; 
        }
        #node-summary:focus { border-color: #333; background: #151518; }

        #node-content { 
            flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 15px; 
            resize: none; font-family: 'Consolas', 'Courier New', monospace; line-height: 1.7; 
            border-radius: 6px; font-size: 13px; color: #ccc; 
        }
        #node-content:focus { border-color: #4facfe; }

        #node-color-container { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        #node-color-input { width: 30px; height: 30px; background: transparent; border: none; cursor: pointer; padding: 0; }
        #node-color-hex { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 8px 10px; border-radius: 6px; font-size: 13px; color: #ccc; text-transform: uppercase; }

        /* --- HUD & Slots --- */
        #hud { position: fixed; top: 20px; left: 25px; pointer-events: none; z-index: 5; opacity: 0.9; display: flex; flex-direction: column; gap: 20px;}
        h1 { margin: 0; font-size: 18px; color: #555; letter-spacing: 2px; text-transform: uppercase; }
        .controls { font-size: 12px; color: #444; line-height: 1.6; font-family: monospace; }
        .key { color: #4facfe; font-weight: bold; background: rgba(79, 172, 254, 0.1); padding: 2px 4px; border-radius: 3px;}

        /* 槽位样式 */
        #slot-bar { display: flex; gap: 15px; pointer-events: auto; margin-top: 5px;}
        .slot { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; opacity: 0.6; transition: 0.3s; width: 60px; }
        .slot:hover { opacity: 1; transform: scale(1.1); }
        .slot.active { opacity: 1; }
        .slot-circle {
            width: 24px; height: 24px; border-radius: 50%; background: #333; border: 2px solid transparent;
            box-shadow: 0 0 5px rgba(0,0,0,0.5); transition: 0.3s; position: relative;
        }
        .slot-num {
            position: absolute; top: -5px; left: -5px; font-size: 10px; font-weight: bold; color: #666; background: #050508; padding: 1px 3px; border-radius: 4px;
        }
        .slot.active .slot-num { color: #4facfe; }
        .slot-name { font-size: 11px; color: #888; text-align: center; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .slot.active .slot-name { color: #ddd; font-weight: bold; }

        #view-controls { font-family: monospace; color: #666; font-size: 12px; }
        #layer-indicator { color: #4facfe; font-weight: bold; }

        /* --- 菜单通用样式 --- */
        .overlay-menu {
            position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateX(-170px);
            background: #1a1a1d; border: 1px solid #444; padding: 15px; border-radius: 8px;
            display: none; flex-direction: column; gap: 6px; z-index: 50; box-shadow: 0 10px 30px rgba(0,0,0,1); min-width: 260px;
        }
        .overlay-menu.active { display: flex; }
        .menu-title { font-size: 12px; color: #888; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        .menu-opt { font-size: 13px; color: #ccc; padding: 8px 10px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: background 0.2s;}
        .menu-opt:hover, .menu-opt.selected { background: #333; color: #fff; }
        .menu-key { color: #4facfe; font-weight: bold; font-family: monospace; margin-right: 12px; min-width: 20px;}
        .menu-del { color: #e74c3c; font-size: 11px; margin-left: auto; }

        #tooltip { position: absolute; opacity: 0; background: rgba(0, 0, 0, 0.9); padding: 10px 14px; border-radius: 4px; border-left: 3px solid #4facfe; pointer-events: none; color: #ddd; font-size: 12px; transition: opacity 0.15s; z-index: 100; max-width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.6);}
        #tooltip.fixed-mode { top: 70%; left: 50%; transform: translate(-50%, 0) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); text-align: center; border-left: none; border-top: 3px solid #4facfe; }

        /* --- 弹窗提示 --- */
        #flash-message {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) translateX(calc(-1 * var(--sidebar-width, 340px) / 2));
            background: rgba(255, 0, 0, 0.15); color: #ff4d4d; border: 1px solid #ff4d4d;
            padding: 15px 30px; border-radius: 8px; font-weight: bold; font-size: 14px;
            opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 200; box-shadow: 0 0 30px rgba(255, 0, 0, 0.2);
            text-transform: uppercase; letter-spacing: 1px;
        }

        /* --- 内容渲染模态框 --- */
        #content-modal {
            display: none; position: fixed; top: 0; left: 0; width: calc(100vw - 340px); height: 100vh;
            background: rgba(0,0,0,0.85); z-index: 300; justify-content: center; align-items: center;
        }
        #content-modal.active { display: flex; }
        #modal-body {
            background: #161619; width: 800px; max-width: 90%; height: 85%; border: 1px solid #333; border-radius: 8px;
            padding: 40px; box-sizing: border-box; overflow-y: auto; color: #ccc;
            box-shadow: 0 0 50px rgba(0,0,0,1);
        }
        /* Markdown 样式微调 */
        #modal-body h1, #modal-body h2, #modal-body h3 { color: #fff; border-bottom: 1px solid #333; padding-bottom: 5px; margin-top: 20px;}
        #modal-body a { color: #4facfe; text-decoration: none; }
        #modal-body code { background: #222; padding: 2px 5px; border-radius: 3px; font-family: monospace; color: #ff7675; }
        #modal-body pre { background: #111; padding: 15px; border-radius: 5px; overflow-x: auto; }
        #modal-body pre code { background: transparent; color: #ddd; padding: 0; }
        #modal-body blockquote { border-left: 4px solid #444; margin: 0; padding-left: 15px; color: #888; }
        #modal-body img { max-width: 100%; border-radius: 4px; }

        #io-controls { position: fixed; bottom: 20px; left: 25px; z-index: 5; display: flex; gap: 10px; }
        button { background: #1a1a1d; color: #777; border: 1px solid #333; padding: 6px 12px; cursor: pointer; font-size: 11px; border-radius: 3px; transition: 0.2s; }
        button:hover { background: #333; color: #fff; border-color: #555; }

        /* --- 预设编辑器样式 --- */
        #preset-editor {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #161619; border: 1px solid #333; border-radius: 8px;
            padding: 20px; width: 500px; max-width: 90%; z-index: 400;
            display: none; flex-direction: column; gap: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        }
        #preset-editor.active { display: flex; }
        .preset-list { max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .preset-row { display: flex; gap: 10px; align-items: center; background: #0a0a0c; padding: 5px; border-radius: 4px; border: 1px solid #222; }
        .preset-row:hover { border-color: #444; }
        .preset-input { background: transparent; border: none; color: #ddd; font-family: monospace; font-size: 12px; padding: 4px; border-bottom: 1px solid transparent; }
        .preset-input:focus { border-bottom-color: #4facfe; }
        .preset-color { width: 25px; height: 25px; border: none; background: none; cursor: pointer; padding: 0; }
        .preset-idx { color: #4facfe; font-weight: bold; font-family: monospace; width: 20px; text-align: center; user-select: none; }
        .preset-del { color: #e74c3c; cursor: pointer; font-weight: bold; padding: 0 5px; user-select: none; }
        .preset-del:hover { color: #ff6b6b; }
        .preset-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px; }
        .btn-primary { background: #2980b9; color: white; border-color: #3498db; }
        .btn-primary:hover { background: #3498db; }

    </style>
</head>
<body>

<div id="hud">
    <h1>星罗 <span style="font-size:10px; opacity:0.5">v4.1 Refined</span></h1>
    <div id="slot-bar">
        <div class="slot" id="slot-1" onclick="handleSlot(0)"><div class="slot-circle"><span class="slot-num">1</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-2" onclick="handleSlot(1)"><div class="slot-circle"><span class="slot-num">2</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-3" onclick="handleSlot(2)"><div class="slot-circle"><span class="slot-num">3</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-4" onclick="handleSlot(3)"><div class="slot-circle"><span class="slot-num">4</span></div><span class="slot-name">-</span></div>
    </div>
    <div id="view-controls">视野范围: <span id="layer-indicator">1</span> 层 (按 +/- 调整)<br>当前可见: <span id="visible-count">0</span> 节点</div>
    <div id="key-controls" class="controls">
        <span class="key">Tab</span> <span class="key">N</span> 关联新建 <span class="key">Shift+Tab</span> <span class="key">Shift+N</span> 独立新建 <span class="key">D</span> <span class="key">Del</span> 删除<br>
        <span class="key">F2</span> 改名 <span class="key">Space</span> 编辑 <span class="key">Enter</span> 查看 <span class="key">E</span> 连线管理<br>
        <span class="key">L</span> 连接 <span class="key">Shift+L</span> 连接上一个 <span class="key">1-4</span> 交换 <span class="key">Shift+1-4</span> 存入<br>
        <span class="key">↑↓←→ /?</span> 移动 <span class="key">H</span> 回家 <span class="key">B</span> <span class="key">Esc</span> 历史后退<br>
        <span class="key">, .</span> 预览扫描(旋转) <span class="key">&lt; &gt;</span> 自由旋转<br>
        <span class="key">`</span> 预设管理<br>
        <span class="key">I</span> 隐藏此提示
    </div>
</div>

<div id="flash-message"></div>
<div id="relation-picker" class="overlay-menu"></div>
<div id="link-manager" class="overlay-menu" style="bottom: 150px;"></div>
<div id="slot-picker" class="overlay-menu" style="bottom: 250px;"></div>

<!-- 新增的预设编辑器 -->
<div id="preset-editor">
    <div class="menu-title">预设关系编辑器 <span style="float:right; cursor:pointer" onclick="presetEditor.close()">✕</span></div>
    <div class="controls" style="margin-bottom:10px; color:#666;">定义常用的连接类型。Value是存入数据的标识，Label是显示名称。</div>
    <div class="preset-list" id="preset-list-container">
        <!-- Rows injected by JS -->
    </div>
    <div class="preset-actions">
        <button onclick="presetEditor.add()">+ 新增预设</button>
        <button class="btn-primary" onclick="presetEditor.saveAndClose()">保存并应用</button>
    </div>
</div>
<!-- 预设编辑器结束 -->

<div id="content-modal" onclick="closeContentModal()"><div id="modal-body" onclick="event.stopPropagation()"></div></div>

<div id="io-controls">
    <button onclick="saveToLocal()">保存</button>
    <button onclick="exportData()">导出</button>
    <button onclick="resetSystem()">重置系统</button>
    <input type="file" id="importFile" style="display:none" onchange="importData(this)">
    <button onclick="document.getElementById('importFile').click()">导入</button>
    <!-- 新增的预设管理按钮 -->
    <button onclick="presetEditor.open()">预设管理</button>
</div>

<div id="sidebar">
    <input type="text" id="node-label" placeholder="概念名称">
    <div id="node-uuid">UUID: -</div>
    <div id="link-status">连接数: -/-</div>
    <textarea id="node-summary" placeholder="简短摘要 (Markdown/HTML)..."></textarea>
    <div id="node-color-container">
        <input type="color" id="node-color-input">
        <input type="text" id="node-color-hex" placeholder="#FFFFFF">
    </div>
    <textarea id="node-content" placeholder="详细笔记 (Markdown支持)..."></textarea>
</div>
<div id="sidebar-resizer"></div> 
<div id="tooltip"></div>
<canvas id="canvas"></canvas>

<script>
    // --- 1. Config ---
    // 默认预设 (val即desc，统一处理)
    const DEFAULT_PRESETS = [
        { label: '包含...', val: 'comp', color: '#0062ff' },
        { label: '定义为...', val: 'def', color: '#00ff00' },
        { label: '直观理解', val: 'ins', color: '#33ffff' },
        { label: '计算...', val: 'calc', color: '#ffaa00' },
        { label: '意味着...', val: 'impl', color: '#bd00ff' },
        { label: '与...正交', val: 'orth', color: '#ff0055' },
    ];
    let RELATION_PRESETS = JSON.parse(JSON.stringify(DEFAULT_PRESETS)); // Mutable copy
    
    const DEFAULT_NODE_COLOR = "#4facfe";
    const MAX_VIEW_LAYERS = 7;
    const MIN_VIEW_LAYERS = 1;
    const MAX_LINKS_PER_NODE = 9;

    let data = { nodes: [], links: [] };
    let slots = [null, null, null, null];
    let viewLayers = 1;
    let focusNode = null, hoverNode = null, previewNode = null;
    let navHistory = [];
    let viewX = 0, viewY = 0, viewK = 1, viewRotation = 0, targetRotation = 0;
    let lastRenderTime = 0;
    const FADE_DURATION = 400;
    const keyState = {};

    let hudVisible = true; // 默认可见

    function initSystem() {
        const saved = localStorage.getItem('stars_v4');
        if (saved) {
            try {
                const raw = JSON.parse(saved);
                data = raw.data;
                
                // --- 新增：加载自定义预设 ---
                if (raw.presets && Array.isArray(raw.presets)) {
                    RELATION_PRESETS = raw.presets;
                }
                // ------------------------

                const nodeMap = new Map(data.nodes.map(n => [n.uuid, n]));
                data.links.forEach(l => {
                    if(typeof l.source === 'string') l.source = nodeMap.get(l.source) || l.source;
                    if(typeof l.target === 'string') l.target = nodeMap.get(l.target) || l.target;
                    l.alpha = 0;
                });
                data.nodes.forEach(n => { n.alpha = 0; });
                slots = raw.slots.map(uuid => uuid ? nodeMap.get(uuid) : null);
                viewLayers = raw.viewLayers || 1;
                focusNode = data.nodes.find(n => n.isRoot) || data.nodes[0];
            } catch(e) { console.error("Failed to load saved data:", e); createRoot(); } // 添加错误日志
        } else { createRoot(); }

        if(!focusNode) createRoot();
        focusNode.alpha = 1;
        updateUI(); updateSlotUI(); restartSim(); adjustZoomByLayer();
    }

    function createRoot() {
        const rootUUID = uuid.v4();
        const root = { uuid: rootUUID, label: "Origin", isRoot: true, x: 0, y: 0, summary: "初始奇点", color: "#ffffff", alpha: 1 };
        data = { nodes: [root], links: [] };
        slots = [null, null, null, null];
        focusNode = root; viewLayers = 1;
    }

    function resetSystem() {
        if(confirm("重置系统将清空所有数据，确定吗？")) {
            localStorage.removeItem('stars_v4'); location.reload();
        }
    }

    // --- 2. Core Logic ---

    function getNodeLinkCount(nodeUuid) {
        return data.links.filter(l => l.source.uuid === nodeUuid || l.target.uuid === nodeUuid).length;
    }

    function showFlashMessage(msg) {
        const el = document.getElementById('flash-message');
        el.innerText = msg; el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 2000);
    }

    // 安全性检查：防止操作导致节点孤立
    function findReachable(allNodes, allLinks, startNodes) {
        const reachable = new Set();
        const queue = [];
        startNodes.forEach(s => {
            if (s && !reachable.has(s.uuid)) {
                const exists = allNodes.find(n => n.uuid === s.uuid);
                if(exists) { reachable.add(s.uuid); queue.push(exists); }
            }
        });
        const adj = {};
        allLinks.forEach(l => {
            const s = l.source.uuid || l.source;
            const t = l.target.uuid || l.target;
            if(!adj[s]) adj[s] = []; adj[s].push(t);
            if(!adj[t]) adj[t] = []; adj[t].push(s);
        });
        let head = 0;
        while(head < queue.length) {
            const curr = queue[head++];
            const neighbors = adj[curr.uuid] || [];
            neighbors.forEach(nid => {
                if (!reachable.has(nid)) {
                    reachable.add(nid);
                    const nodeObj = allNodes.find(n => n.uuid === nid);
                    if(nodeObj) queue.push(nodeObj);
                }
            });
        }
        return reachable;
    }

    function executeSafeAction(simulator, executor) {
        const proposed = simulator();
        const { nodes, links, nextFocus, nextSlots } = proposed;
        const anchors = [];
        const root = nodes.find(n => n.isRoot);
        if (root) anchors.push(root);
        if (nextFocus) anchors.push(nextFocus);
        nextSlots.forEach(s => { if(s) anchors.push(s); });

        const reachableUUIDs = findReachable(nodes, links, anchors);
        const lostNodes = nodes.filter(n => !reachableUUIDs.has(n.uuid));

        if (lostNodes.length > 0) {
            if (confirm(`警告：此操作将导致 ${lostNodes.length} 个节点丢失（如 ${lostNodes[0].label}...）。是否继续？`)) {
                executor();
                const deadUUIDs = new Set(lostNodes.map(n => n.uuid));
                data.nodes = data.nodes.filter(n => !deadUUIDs.has(n.uuid));
                data.links = data.links.filter(l => !deadUUIDs.has(l.source.uuid) && !deadUUIDs.has(l.target.uuid));
                navHistory = navHistory.filter(n => !deadUUIDs.has(n.uuid));
                slots = slots.map(s => (s && deadUUIDs.has(s.uuid)) ? null : s);
                restartSim();
                return true;
            }
            return false;
        } else {
            executor();
            restartSim();
            return true;
        }
    }

    // --- Action Handlers ---

    function handleSlot(index) {
        const slotNode = slots[index];
        const currentFocus = focusNode;
        if (slotNode === currentFocus) return;
        if (slotNode) {
            executeSafeAction(
                () => ({ nodes: data.nodes, links: data.links, nextFocus: slotNode, nextSlots: slots.map((s,i)=>i===index?currentFocus:s) }),
                () => { slots[index] = currentFocus; navigateTo(slotNode, true, false); updateSlotUI(); }
            );
        } else {
            slots[index] = currentFocus; updateSlotUI(); saveToLocal();
        }
    }

    function handleSlotStore(index) {
        const currentFocus = focusNode;
        if (slots[index] === currentFocus) return;
        executeSafeAction(
            () => ({ nodes: data.nodes, links: data.links, nextFocus: currentFocus, nextSlots: slots.map((s,i)=>i===index?currentFocus:s) }),
            () => { slots[index] = currentFocus; updateSlotUI(); saveToLocal(); }
        );
    }

    function safeNavigate(targetNode, isHistoryBack = false) {
        if(!targetNode) return;
        executeSafeAction(
            () => ({ nodes: data.nodes, links: data.links, nextFocus: targetNode, nextSlots: slots }),
            () => { navigateTo(targetNode, !isHistoryBack, false); }
        );
    }

    function safeDeleteNode() {
        if (focusNode.isRoot) { alert("初始奇点不可删除。"); return; }
        let fallback = navHistory.length > 0 ? navHistory[navHistory.length - 1] : null;
        if (fallback && fallback.uuid === focusNode.uuid) fallback = null;
        if (!fallback) fallback = data.nodes.find(n => n.isRoot);

        executeSafeAction(
            () => ({
                nodes: data.nodes.filter(n => n.uuid !== focusNode.uuid),
                links: data.links.filter(l => l.source.uuid !== focusNode.uuid && l.target.uuid !== focusNode.uuid),
                nextFocus: fallback,
                nextSlots: slots.map(s => (s && s.uuid === focusNode.uuid) ? null : s)
            }),
            () => {
                const del = focusNode;
                slots = slots.map(s => (s && s.uuid === del.uuid) ? null : s);
                data.links = data.links.filter(l => l.source.uuid !== del.uuid && l.target.uuid !== del.uuid);
                data.nodes = data.nodes.filter(n => n.uuid !== del.uuid);
                navigateTo(fallback, false, false);
                updateSlotUI();
            }
        );
    }

    function safeDeleteLink(link) {
        executeSafeAction(
            () => ({ nodes: data.nodes, links: data.links.filter(l => l !== link), nextFocus: focusNode, nextSlots: slots }),
            () => { data.links = data.links.filter(l => l !== link); restartSim(); }
        );
    }

    function updateSlotUI() {
        for(let i=0; i<4; i++) {
            const el = document.getElementById(`slot-${i+1}`);
            const node = slots[i];
            const circle = el.querySelector('.slot-circle');
            const nameEl = el.querySelector('.slot-name');
            if (node) {
                el.classList.add('active');
                nameEl.innerText = node.label;
                circle.style.background = node.color || DEFAULT_NODE_COLOR;
                circle.style.boxShadow = `0 0 8px ${node.color || DEFAULT_NODE_COLOR}`;
                circle.style.border = "1px solid rgba(255,255,255,0.3)";
            } else {
                el.classList.remove('active');
                nameEl.innerText = "-";
                circle.style.background = "#222";
                circle.style.boxShadow = "none";
                circle.style.border = "1px solid #333";
            }
        }
    }

    // --- 3. D3 & Render ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width = window.innerWidth - 340, height = window.innerHeight;
    canvas.width = width; canvas.height = height;

    const simulation = d3.forceSimulation()
        .force("link", d3.forceLink().id(d => d.uuid).distance(220).strength(0.1))
        .force("charge", d3.forceManyBody().strength(-200))
        .force("collide", d3.forceCollide(10))
        .force("center", d3.forceCenter(0, 0))
        .alphaDecay(0.05)
        .alphaMin(0.05);;

    // 拖拽力
    const POINTER_FORCE_STRENGTH = 0.25; // 可调：吸引强度（越大越“跟手”）
    const pointerForce = (() => {
        let node = null;       // 当前被“吸引”的节点
        let target = null;     // 鼠标对应的世界坐标
        let strength = POINTER_FORCE_STRENGTH;
        function force(alpha) {
            if (!node || !target) return;
            // 向目标施加加速度（通过修改 vx/vy ），不是直接设置位置
            const dx = target.x - node.x;
            const dy = target.y - node.y;
            // 距离衰减（近处更柔和，远处更明显），避免抖动
            const dist = Math.hypot(dx, dy);
            const falloff = 1 - Math.exp(-dist / 120); // 可调半径 120
            const k = strength * falloff * alpha; // alpha 参与，越“热”越强烈
            node.vx += dx * k;
            node.vy += dy * k;
        }
        force.initialize = () => {}; // 这里无需初始化节点列表
        force.node = function(n) { node = n || null; return force; };
        force.target = function(x, y) { target = (x!=null && y!=null) ? {x, y} : null; return force; };
        force.strength = function(s) { strength = s; return force; };
        return force;
    })();
    // 注册到模拟器
    simulation.force('pointerDrag', pointerForce);

    function adjustZoomByLayer() {
        const targetK = 1.0 / (Math.pow(viewLayers, 0.7));
        viewK = Math.max(0.15, Math.min(2.5, targetK));
    }

    function render(currentTime) {
        if (!lastRenderTime) lastRenderTime = currentTime;
        const deltaTime = currentTime - lastRenderTime;
        lastRenderTime = currentTime;

        const targetX = width/2; const targetY = height/2;
        viewX += ((-focusNode.x * viewK + targetX) - viewX) * 0.1;
        viewY += ((-focusNode.y * viewK + targetY) - viewY) * 0.1;
        if (keyState['<']) targetRotation += 0.05;
        if (keyState['>']) targetRotation -= 0.05;
        if ((keyState['<'] || keyState['>']) && previewNode) {
            previewNode = null;
            hideTooltip();
        }
        let diff = targetRotation - viewRotation;
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        viewRotation += diff * 0.1;

        ctx.save();
        ctx.clearRect(0, 0, width, height);
        ctx.translate(width/2, height/2); ctx.rotate(viewRotation); ctx.translate(-width/2, -height/2);
        ctx.translate(viewX, viewY); ctx.scale(viewK, viewK);

        const visibleTargets = new Set();
        const visibleLinksTarget = new Set();

        const addNeighbors = (startNode, depth) => {
            if(!startNode) return;
            let queue = [{n: startNode, d: 0}];
            visibleTargets.add(startNode.uuid);
            let head = 0;
            while(head < queue.length) {
                const {n, d} = queue[head++];
                if (d >= depth) continue;
                data.links.forEach(l => {
                    const s = l.source, t = l.target;
                    if (s.uuid === n.uuid) {
                        if(!visibleTargets.has(t.uuid)) { visibleTargets.add(t.uuid); queue.push({n: t, d: d+1}); }
                        visibleLinksTarget.add(`${s.uuid}-${t.uuid}`);
                    } else if (t.uuid === n.uuid) {
                        if(!visibleTargets.has(s.uuid)) { visibleTargets.add(s.uuid); queue.push({n: s, d: d+1}); }
                        visibleLinksTarget.add(`${s.uuid}-${t.uuid}`);
                    }
                });
            }
        };

        if (focusNode) addNeighbors(focusNode, viewLayers);
        if (hoverNode && hoverNode !== focusNode) addNeighbors(hoverNode, 1);
        if (previewNode && previewNode !== focusNode) addNeighbors(previewNode, 1);

        // 动态更新模拟范围（计算更大范围以保持稳定）
        const SIMULATION_LAYERS = 7; // 始终计算 7 层节点
        const simulationTargets = new Set();
        const addSimulationNeighbors = (startNode, depth) => {
            if(!startNode) return;
            let queue = [{n: startNode, d: 0}];
            simulationTargets.add(startNode.uuid);
            let head = 0;
            while(head < queue.length) {
                const {n, d} = queue[head++];
                if (d >= depth) continue;
                data.links.forEach(l => {
                    const s = l.source, t = l.target;
                    if (s.uuid === n.uuid) {
                        if(!simulationTargets.has(t.uuid)) { 
                            simulationTargets.add(t.uuid); 
                            queue.push({n: t, d: d+1}); 
                        }
                    } else if (t.uuid === n.uuid) {
                        if(!simulationTargets.has(s.uuid)) { 
                            simulationTargets.add(s.uuid); 
                            queue.push({n: s, d: d+1}); 
                        }
                    }
                });
            }
        };
        if (focusNode) addSimulationNeighbors(focusNode, SIMULATION_LAYERS);
        const activeNodes = data.nodes.filter(n => simulationTargets.has(n.uuid));
        const activeLinks = data.links.filter(l => 
            simulationTargets.has(l.source.uuid) && simulationTargets.has(l.target.uuid)
        );
        simulation.nodes(activeNodes);
        simulation.force("link").links(activeLinks);
        // 温和重启
        if (simulation.alpha() < 0.1) {
            simulation.alpha(0.3).restart();
        }

        let visibleCount = 0;

        data.links.forEach(link => {
            const key = `${link.source.uuid}-${link.target.uuid}`;
            const keyRev = `${link.target.uuid}-${link.source.uuid}`;
            const isTargetVisible = visibleLinksTarget.has(key) || visibleLinksTarget.has(keyRev);

            if (isTargetVisible && link.alpha < 1) link.alpha += deltaTime / FADE_DURATION;
            else if (!isTargetVisible && link.alpha > 0) link.alpha -= deltaTime / FADE_DURATION;
            link.alpha = Math.max(0, Math.min(1, link.alpha));

            if (link.alpha > 0.01) {
                const src = link.source, tgt = link.target;
                const isFocusLink = (src === focusNode || tgt === focusNode);
                ctx.globalAlpha = link.alpha * (isFocusLink ? 0.9 : 0.2);
                ctx.lineWidth = isFocusLink ? 2.5 : 1;
                // 使用 RELATION_PRESETS 中的 color
                const typeColor = RELATION_PRESETS.find(p=>p.val===link.type)?.color || '#666';

                const grad = ctx.createLinearGradient(src.x, src.y, tgt.x, tgt.y);
                grad.addColorStop(0, typeColor); grad.addColorStop(0.7, "#444"); grad.addColorStop(1, "#222");
                ctx.strokeStyle = grad;
                ctx.beginPath(); ctx.moveTo(src.x, src.y); ctx.lineTo(tgt.x, tgt.y); ctx.stroke();
                
                if (link.type && isFocusLink) {
                     const mx = (src.x+tgt.x)/2, my = (src.y+tgt.y)/2;
                     ctx.save(); ctx.translate(mx, my); ctx.rotate(-viewRotation);
                     ctx.fillStyle = typeColor; ctx.font = "11px Arial"; ctx.textAlign="center";
                     // 显示 label
                     const linkLabel = RELATION_PRESETS.find(p=>p.val===link.type)?.label || link.type;
                     ctx.fillText(linkLabel, 0, -8); ctx.restore();
                }
            }
        });

        data.nodes.forEach(node => {
            const isTargetVisible = visibleTargets.has(node.uuid);
            if (node === focusNode) node.alpha = 1;
            else {
                if (isTargetVisible && node.alpha < 1) node.alpha += deltaTime / FADE_DURATION;
                else if (!isTargetVisible && node.alpha > 0) node.alpha -= deltaTime / FADE_DURATION;
                node.alpha = Math.max(0, Math.min(1, node.alpha));
            }

            if (node.alpha > 0.01) {
                visibleCount++;
                const isSlot = slots.includes(node);
                const isFocus = (node === focusNode);
                const isPreview = (node === previewNode || node === hoverNode);
                const linkCount = getNodeLinkCount(node.uuid);
                const isFull = linkCount >= MAX_LINKS_PER_NODE;

                ctx.globalAlpha = isFocus ? 1 : node.alpha;
                ctx.beginPath();
                let r = isFocus ? 20 : (isSlot ? 14 : 10);
                if (viewK < 0.5) r = r / viewK * 0.5;

                ctx.arc(node.x, node.y, r, 0, 2*Math.PI);
                ctx.fillStyle = node.color || DEFAULT_NODE_COLOR;

                if(isFocus) {
                    ctx.shadowBlur = 35; ctx.shadowColor = isFull ? "#ff4d4d" : ctx.fillStyle;
                } else if(isPreview) {
                    ctx.shadowBlur = 20; ctx.shadowColor = ctx.fillStyle;
                }

                if (isFull && isFocus) { ctx.strokeStyle = "#ff4d4d"; ctx.lineWidth = 3; ctx.stroke(); }
                else if(isSlot && !isFocus) { ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.stroke(); }

                ctx.fill(); ctx.shadowBlur=0; ctx.strokeStyle = "transparent";

                if (isFocus || isPreview || node.alpha > 0.5) {
                    ctx.save(); ctx.translate(node.x, node.y); ctx.rotate(-viewRotation);
                    ctx.fillStyle = (isFocus || isPreview) ? "#fff" : "rgba(200,200,200,0.7)";
                    ctx.font = (isFocus || isPreview) ? "bold 14px Arial" : "11px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(node.label, 0, r + 16);
                    const sIdx = slots.indexOf(node);
                    if (sIdx >= 0) { ctx.fillStyle = "#4facfe"; ctx.font = "bold 11px monospace"; ctx.fillText(`[${sIdx+1}]`, 0, -r - 6); }
                    ctx.restore();
                }
            }
        });
        ctx.restore();
        document.getElementById('visible-count').innerText = visibleCount;
        requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

    // --- 4. Interaction ---

    function getNeighborsWithAngle() {
        const neighbors = [];
        data.links.forEach(l => {
            let other = null; const sId = l.source.uuid, tId = l.target.uuid, fId = focusNode.uuid;
            if(sId === fId) other = l.target; if(tId === fId) other = l.source;
            if(other) {
                const rawAngle = Math.atan2(other.y - focusNode.y, other.x - focusNode.x);
                let visualAngle = rawAngle + viewRotation;
                while(visualAngle > Math.PI) visualAngle -= 2*Math.PI; while(visualAngle <= -Math.PI) visualAngle += 2*Math.PI;
                neighbors.push({ node: other, vAngle: visualAngle, rawAngle: rawAngle });
            }
        });
        neighbors.sort((a,b) => a.vAngle - b.vAngle);
        return neighbors;
    }

    function cyclePreview(dir) {
        const neighbors = getNeighborsWithAngle();
        if (neighbors.length === 0) return;
        
        // 重置 tooltip 位置（清除之前的鼠标模式定位）
        hideTooltip()
        
        const UP_ANGLE = -Math.PI / 2; // 屏幕正上方的角度
        const EXACT_THRESHOLD = 5 * Math.PI / 180; // 5度的容差
        
        // 检查是否有节点正好在正上方
        const exactMatch = neighbors.find(n => Math.abs(n.vAngle - UP_ANGLE) < EXACT_THRESHOLD);
        
        // 如果当前正在预览正上方的节点，且用户再次按下预览键，应该跳过它
        const shouldSkipExact = exactMatch && previewNode && previewNode.uuid === exactMatch.node.uuid;
        
        // 如果有正上方的节点，且当前没在预览它（或应该跳过），优先选择它
        if (exactMatch && !shouldSkipExact) {
            previewNode = exactMatch.node;
            setTargetRotation(-Math.PI/2 - exactMatch.rawAngle);
            showTooltip(`<strong>预览: ${previewNode.label}</strong><br>${previewNode.summary||''}<br><span style='color:#af4cae'>按 <span class="key">↑</span> <span class="key">/</span> 跳转</span>`, 0, 0, 'fixed');
            return;
        }
        
        // 否则，按方向查找下一个节点
        // dir = 1: 顺时针（找角度更大的）, dir = -1: 逆时针（找角度更小的）
        let targetNode = null;
        
        if (dir > 0) {
            // 顺时针：找第一个角度 > UP_ANGLE 的节点
            targetNode = neighbors.find(n => n.vAngle > UP_ANGLE && (!shouldSkipExact || n.node.uuid !== exactMatch.node.uuid));
            // 如果没找到，循环到开头
            if (!targetNode) {
                targetNode = neighbors.find(n => (!shouldSkipExact || !exactMatch || n.node.uuid !== exactMatch.node.uuid));
            }
        } else {
            // 逆时针：找最后一个角度 < UP_ANGLE 的节点
            for (let i = neighbors.length - 1; i >= 0; i--) {
                if (neighbors[i].vAngle < UP_ANGLE && (!shouldSkipExact || neighbors[i].node.uuid !== exactMatch.node.uuid)) {
                    targetNode = neighbors[i];
                    break;
                }
            }
            // 如果没找到，循环到末尾
            if (!targetNode) {
                for (let i = neighbors.length - 1; i >= 0; i--) {
                    if (!shouldSkipExact || !exactMatch || neighbors[i].node.uuid !== exactMatch.node.uuid) {
                        targetNode = neighbors[i];
                        break;
                    }
                }
            }
        }
        
        if (targetNode) {
            previewNode = targetNode.node;
            setTargetRotation(-Math.PI/2 - targetNode.rawAngle);
            showTooltip(`<strong>预览: ${previewNode.label}</strong><br>${previewNode.summary||''}<br><span style='color:#af4cae'>按 <span class="key">↑</span> <span class="key">/</span> 跳转</span>`, 0, 0, 'fixed');
        }
    }

    function setTargetRotation(target) {
        let current = targetRotation; let diff = target - current;
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        targetRotation = current + diff;
    }

    const tooltipEl = document.getElementById('tooltip');
    function showTooltip(html, x, y, mode) {
        tooltipEl.innerHTML = html; tooltipEl.style.opacity = 1;
        if (mode === 'mouse') {
            tooltipEl.className = ''; tooltipEl.style.left = (x + 15) + 'px'; tooltipEl.style.top = (y + 15) + 'px'; tooltipEl.style.transform = 'none';
        } else { tooltipEl.className = 'fixed-mode'; }
    }
    function hideTooltip() {
        tooltipEl.style.opacity = 0;
        tooltipEl.className = '';
        tooltipEl.style.left = '';
        tooltipEl.style.top = '';
        tooltipEl.style.transform = '';
    }

    // 还原准确的屏幕转世界坐标函数
    function screenToWorld(sx, sy) {
        let x = sx - width/2, y = sy - height/2;
        // 逆向旋转
        const cos = Math.cos(-viewRotation), sin = Math.sin(-viewRotation);
        let rx = x * cos - y * sin; let ry = x * sin + y * cos;
        // 逆向位移和缩放
        return { x: (rx + width/2 - viewX) / viewK, y: (ry + height/2 - viewY) / viewK };
    }
    
    // --- Drag state & helpers ---
    const DRAG_CLICK_MAX_TIME = 200;   // ms，点击判定最大按住时间
    const DRAG_CLICK_MAX_DIST = 8;     // px，点击判定最大位移（屏幕空间）
    const DRAG_HIT_RADIUS2 = 600;      // 与 hover 命中一致（约 24px 半径）
    let drag = {
        active: false,      // 是否处于按下期间（不一定是拖拽）
        node: null,         // 被拖拽的节点（如果按下时在节点上）
        startSX: 0,         // 按下时屏幕坐标 X
        startSY: 0,         // 按下时屏幕坐标 Y
        startTime: 0,       // 按下时刻（performance.now）
        maxMove: 0          // 按下-抬起期间的最大位移（屏幕空间）
    };
    // 命中测试：给定鼠标屏幕坐标，返回命中的可见节点
    function pickNodeAtScreen(sx, sy, alphaThresh = 0.5) {
        const pos = screenToWorld(sx, sy);
        return data.nodes.find(n => {
            if (n.alpha <= alphaThresh) return false;
            const dx = n.x - pos.x, dy = n.y - pos.y;
            return (dx*dx + dy*dy) < DRAG_HIT_RADIUS2;
        });
    }
    // 鼠标事件
    canvas.addEventListener('mousemove', e => {
        if (document.getElementById('content-modal').classList.contains('active')) return;
        if (drag.active) {
            const dx = e.clientX - drag.startSX;
            const dy = e.clientY - drag.startSY;
            drag.maxMove = Math.max(drag.maxMove, Math.hypot(dx, dy));
            if (drag.node) {
                const w = screenToWorld(e.clientX, e.clientY);
                pointerForce.target(w.x, w.y); // 仅更新目标，不固定位置
                // alphaTarget 在按下时已设置，这里无需重复 set
                hoverNode = null;
                previewNode = null;
                hideTooltip();
            }
            return;
        }
        // 非拖拽时保持原 hover 逻辑
        const pos = screenToWorld(e.clientX, e.clientY);
        const found = data.nodes.find(n => n.alpha > 0.5 && ((n.x-pos.x)**2 + (n.y-pos.y)**2) < 600);
        if (found) {
            hoverNode = found;
            previewNode = null;
            const summaryText = found.summary || '';
            const summaryHtml = typeof marked !== 'undefined' ? marked.parseInline(summaryText) : summaryText;
            showTooltip(`<strong>${found.label}</strong><br>${summaryHtml}<br><span style='color:#666'>点击跳转</span>`, e.clientX, e.clientY, 'mouse');
        } else {
            hoverNode = null;
            if (!previewNode) hideTooltip();
        }
    });
    canvas.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        if (document.getElementById('content-modal').classList.contains('active')) return;
        const node = pickNodeAtScreen(e.clientX, e.clientY);
        drag.active = true;
        drag.node = node || null;
        drag.startSX = e.clientX;
        drag.startSY = e.clientY;
        drag.startTime = performance.now();
        drag.maxMove = 0;
        if (drag.node) {
            const w = screenToWorld(e.clientX, e.clientY);
            pointerForce.node(drag.node).target(w.x, w.y); // 激活吸引力
            simulation.alphaTarget(0.3).restart();         // 保持系统“热”
            hoverNode = null;
            previewNode = null;
            hideTooltip();
            canvas.style.cursor = 'grabbing';
        }
    });
    canvas.addEventListener('mouseup', e => {
        if (e.button !== 0) return;
        if (!drag.active) return;
        const elapsed = performance.now() - drag.startTime;
        const moved = drag.maxMove;
        const node = drag.node;
        if (node) {
            pointerForce.node(null).target(null); // 关闭吸引力
            simulation.alphaTarget(0);            // 让系统冷却回稳
            saveToLocal();
            canvas.style.cursor = 'crosshair';
        }
        // 点击判定（不动也可能触发，但若时间超过阈值就不会触发）
        if (elapsed < DRAG_CLICK_MAX_TIME && moved < DRAG_CLICK_MAX_DIST) {
            const target = node || pickNodeAtScreen(e.clientX, e.clientY);
            if (target && target !== focusNode) {
                safeNavigate(target);
            }
        }
        drag.active = false;
        drag.node = null;
    });

    canvas.addEventListener('wheel', e => { e.preventDefault(); viewK -= e.deltaY * 0.001; viewK = Math.max(0.1, Math.min(5, viewK)); }, { passive: false });

    // 键盘事件处理
    window.addEventListener('keydown', e => {
        if (modal.classList.contains('active')) {
            e.preventDefault(); // 阻止所有按键的默认行为（例如浏览器快捷键）
            // 这里无需处理 Esc，因为它会被 closeModalHandler 处理并停止传播。
            // 对于其他键，我们直接返回，不执行任何全局逻辑。
            return;
        }

        // 编辑器激活时，允许输入，但 ESC 关闭
        if (presetEditor.active) {
            if (e.key === 'Escape') presetEditor.close();
            return; // 关键：在编辑器打开时，停止处理底层的快捷键
        }

        const tag = e.target.tagName;
        const isInput = (tag === 'INPUT' || tag === 'TEXTAREA');

        if (relationPicker.active || slotPicker.active || linkManager.active) {
             if (relationPicker.active) relationPicker.handleInput(e);
             if (slotPicker.active) slotPicker.handleInput(e);
             if (linkManager.active) linkManager.handleInput(e);
             return; // 模态菜单激活时，阻止其他键
        }

        // --- 编辑器内的特殊行为 ---
        if (isInput) {
            // Esc: 失去焦点，回到 Canvas
            if (e.key === 'Escape') {
                e.target.blur();
                canvas.focus();
                return;
            }
            // Title Input Enter: 返回 Canvas
            if (e.key === 'Enter' && e.target.id === 'node-label') {
                e.preventDefault();
                e.target.blur();
                canvas.focus();
                return;
            }
            // 允许默认 Tab 在输入框间切换（浏览器默认行为），但要阻止全局 Tab 触发创建节点
            if (e.key === 'Tab') {
                // 不做任何阻止，让它自然切换，但要在下方阻止全局逻辑
                return;
            }
            return; // 其他输入框内的按键不触发全局快捷键
        }

        // --- 全局快捷键 (非输入状态) ---
        keyState[e.key] = true; if (e.shiftKey) keyState['Shift'] = true;
        
        // ` 键：预设管理
        if (e.key === '`') {
            e.preventDefault();
            presetEditor.open();
            return;
        }


        const isSlotKey = (e.key >= '1' && e.key <= '4');
        const isShiftSymbol = ['!', '@', '#', '$'].includes(e.key);

        if (isShiftSymbol) { handleSlotStore({'!':0, '@':1, '#':2, '$':3}[e.key]); return; }
        if (e.shiftKey && isSlotKey) { handleSlotStore(parseInt(e.key) - 1); return; }
        if (!e.shiftKey && isSlotKey) { handleSlot(parseInt(e.key) - 1); return; }

        const neighbors = getNeighborsWithAngle();
        switch(e.key) {
            case 'ArrowUp': case '/':
                if (previewNode) safeNavigate(previewNode);
                else jumpDirection(-Math.PI/2, neighbors);
                break;
            case 'ArrowDown': case '?': jumpDirection(Math.PI/2, neighbors); break;
            case 'ArrowLeft': jumpDirection(-Math.PI, neighbors); break;
            case 'ArrowRight': jumpDirection(0, neighbors); break;
            case '.': cyclePreview(1); break; case ',': cyclePreview(-1); break;
            case '=': case '+': viewLayers = Math.max(MIN_VIEW_LAYERS, viewLayers - 1); adjustZoomByLayer(); document.getElementById('layer-indicator').innerText = viewLayers; break;
            case '-': case '_': viewLayers = Math.min(MAX_VIEW_LAYERS, viewLayers + 1); adjustZoomByLayer(); document.getElementById('layer-indicator').innerText = viewLayers; break;
            
            // 新按键映射
            case 'Tab': 
            case 'n': case 'N':
                e.preventDefault();
                if(e.shiftKey) createIndependentNodeFlow(); // Shift+Tab
                else createConnectedNodeFlow(); // Tab
                break;
            case 'F2': 
                e.preventDefault(); 
                const labelInp = document.getElementById('node-label');
                labelInp.focus(); labelInp.select();
                break;
            case ' ': // Space -> Summary
                e.preventDefault();
                const sumInp = document.getElementById('node-summary');
                sumInp.focus(); sumInp.select();
                break;
            case 'Enter': // Enter -> Content Modal
                if(!isInput && focusNode) showContentModal();
                break;
            
            case 'l': case 'L': 
                if(e.shiftKey) linkToBackFlow(); // Shift+L
                else linkToSlotFlow(); // L
                break;
            case 'e': case 'E': linkManager.open(); break;
            case 'h': case 'H': 
                const root = data.nodes.find(n=>n.isRoot);
                if(root) safeNavigate(root);
                break;
            case 'Escape': case 'b': case 'B':
                if(navHistory.length) {
                    let target = null;
                    // 找到上一个不同的节点
                    for(let i = navHistory.length - 1; i >= 0; i--) {
                        if(data.nodes.find(n => n.uuid === navHistory[i].uuid) && navHistory[i].uuid !== focusNode.uuid) {
                            target = navHistory[i]; break;
                        }
                    }
                    if(target) safeNavigate(target, true);
                }
                break;
            case 'Delete': case 'd': case 'D': safeDeleteNode(); break;
            case 'i': case 'I':
                e.preventDefault();
                hudVisible = !hudVisible;
                document.getElementById('key-controls').style.display = hudVisible ? 'block' : 'none';
                break;
        }
    });
    window.addEventListener('keyup', e => { keyState[e.key] = false; if(e.key==='Shift') keyState['Shift']=false; });

    function jumpDirection(targetAng, neighbors) {
        let best = null, minDiff = Infinity;
        neighbors.forEach(n => {
            let diff = Math.abs(n.vAngle - targetAng); if (diff > Math.PI) diff = 2*Math.PI - diff;
            if (diff < minDiff) { minDiff = diff; best = n.node; }
        });
        if (best && minDiff < 1.2) safeNavigate(best);
    }
    
    function navigateTo(node, record, resetRot) {
        if(!node) return;
        if(focusNode && record && focusNode !== node) { navHistory.push(focusNode); if(navHistory.length>50) navHistory.shift(); }
        focusNode = node; focusNode.alpha = 1; previewNode = null; hideTooltip();
        if(resetRot) targetRotation = 0;
        updateUI(); saveToLocal();
    }

    // --- Overlay Menus ---
    const relationPicker = {
        el: document.getElementById('relation-picker'), active: false, resolve: null, reject: null, customMode: false,
        show: function() {
            return new Promise((res, rej) => {
                let html = `<div class="menu-title">选择连接类型 <span style="font-weight:normal; color:#888;">(Space 自定义)</span></div>`;
                // 动态生成索引 [1]..[9] (最多9个)
                html += RELATION_PRESETS.slice(0, 9).map((p, i) => { // 只处理前9个预设
                    const idxKey = i + 1;
                    // 兼容旧逻辑，val即type
                    return `<div class="menu-opt" onclick="relationPicker.pick('${p.val}')"><span class="menu-key" style="color:${p.color}">[${idxKey}]</span>${p.label}</div>`;
                }).join('');

                // 如果有超过9个预设，显示额外的列表项，但不再提供数字快捷键
                if (RELATION_PRESETS.length > 9) {
                    html += `<div class="menu-title" style="margin-top:10px;">更多 (无快捷键)</div>`;
                    html += RELATION_PRESETS.slice(9).map((p, i) => {
                        return `<div class="menu-opt" onclick="relationPicker.pick('${p.val}')"><span class="menu-key" style="visibility:hidden;">[]</span>${p.label}</div>`;
                    }).join('');
                }

                this.el.innerHTML = html; this.el.classList.add('active'); this.active = true; this.customMode = false;
                this.resolve = res; this.reject = rej;
            });
        },
        handleInput: function(e) {
            const num = parseInt(e.key);
            // 限制数字键只能选择前 9 个预设
            if (!isNaN(num) && num >= 1 && num <= Math.min(9, RELATION_PRESETS.length)) { 
                e.preventDefault(); 
                this.pick(RELATION_PRESETS[num-1].val); 
            }
            else if (e.key === ' ') { e.preventDefault(); this.customMode = true; this.close(); this.resolve('CUSTOM'); }
            else if (e.key === 'Enter') { e.preventDefault(); if(RELATION_PRESETS.length>0) this.pick(RELATION_PRESETS[0].val); }
            else if (e.key === 'Escape') { e.preventDefault(); this.reject(); this.close(); }
        },
        pick: function(val) { this.close(); this.resolve(val); },
        close: function() { this.el.classList.remove('active'); this.active = false; }
    };
    const slotPicker = {
        el: document.getElementById('slot-picker'), active: false, resolve: null, reject: null,
        show: function() { return new Promise((res, rej) => {
                let html = `<div class="menu-title">按 [1-4] 选择要链接的槽位节点</div>`;
                slots.forEach((s, i) => { const label = s ? s.label : "<空>"; html += `<div class="menu-opt" onclick="slotPicker.pick(${i})"><span class="menu-key">[${i+1}]</span> ${label}</div>`; });
                this.el.innerHTML = html; this.el.classList.add('active'); this.active = true;
                this.resolve = res; this.reject = rej;
        });},
        handleInput: function(e) {
            if (e.key >= '1' && e.key <= '4') { e.preventDefault(); this.pick(parseInt(e.key)-1); }
            else if (e.key === 'Escape') { e.preventDefault(); this.reject(); this.close(); }
        },
        pick: function(idx) { this.close(); this.resolve(idx); },
        close: function() { this.el.classList.remove('active'); this.active = false; }
    };
    const linkManager = {
        el: document.getElementById('link-manager'), active: false, currentLinks: [],
        open: function() {
            if (!focusNode) return;
            const links = data.links.filter(l => l.source.uuid === focusNode.uuid || l.target.uuid === focusNode.uuid);
            if (links.length === 0) { alert("没有可编辑的链接。"); return; }
            let html = `<div class="menu-title">管理链接（按数字键编辑/删除）</div>`;
            const displayLinks = links.slice(0, 9);
            displayLinks.forEach((l, i) => {
                const other = l.source.uuid === focusNode.uuid ? l.target : l.source;
                const linkPreset = RELATION_PRESETS.find(p=>p.val===l.type);
                const linkColor = linkPreset?.color || '#666';
                const linkLabel = linkPreset?.label || l.type; // 显示 label
                const dir = l.source.uuid === focusNode.uuid ? "→" : "←";
                html += `<div class="menu-opt" onclick="linkManager.handle(${i})"><span class="menu-key">[${i+1}]</span><span style="color:#666; margin-right:5px;">${dir}</span><span style="flex-grow:1;">${other.label}</span><span style="color:${linkColor}; font-size:10px;">(${linkLabel})</span><span class="menu-del">✕</span></div>`;
            });
            this.el.innerHTML = html; this.el.classList.add('active'); this.active = true; this.currentLinks = displayLinks;
        },
        handleInput: function(e) {
            if (e.key >= '1' && e.key <= Math.min(9, this.currentLinks.length).toString()) { e.preventDefault(); this.handle(parseInt(e.key) - 1); }
            if (e.key === 'Escape') { e.preventDefault(); this.close(); }
        },
        handle: function(idx) {
            const link = this.currentLinks[idx];
            const other = link.source.uuid === focusNode.uuid ? link.target : link.source;
            const currentPreset = RELATION_PRESETS.find(p => p.val === link.type);
            const action = prompt(`链接到 [${other.label}]\n输入新关系名称，或 'del' 删除:`, currentPreset?.label || link.type); // 提示显示 label
            if (action === 'del' || action === 'd') { safeDeleteLink(link); }
            else if (action) { 
                // 查找用户输入的新关系名对应的 val
                const newPreset = RELATION_PRESETS.find(p => p.label === action);
                link.type = newPreset ? newPreset.val : action; // 如果找到预设，用预设的val，否则直接用输入作为type
                restartSim(); 
            }
            this.close();
        },
        close: function() { this.el.classList.remove('active'); this.active = false; }
    };
    
    // --- 新增的预设编辑器 ---
    const presetEditor = {
        el: document.getElementById('preset-editor'),
        listEl: document.getElementById('preset-list-container'),
        active: false,
        tempPresets: [], // 编辑时的临时数据

        open: function() {
            if (this.active) return;
            // 深度拷贝当前配置用于编辑
            this.tempPresets = JSON.parse(JSON.stringify(RELATION_PRESETS));
            this.renderList();
            this.el.classList.add('active');
            this.active = true;
        },

        renderList: function() {
            this.listEl.innerHTML = '';
            this.tempPresets.forEach((p, i) => {
                const row = document.createElement('div');
                row.className = 'preset-row';
                row.innerHTML = `
                    <span class="preset-idx">${i+1}</span>
                    <input type="color" class="preset-color" value="${p.color}" onchange="presetEditor.update(${i}, 'color', this.value)">
                    <input type="text" class="preset-input" style="width:120px" placeholder="显示名称 (Label)" value="${p.label}" oninput="presetEditor.update(${i}, 'label', this.value)">
                    <input type="text" class="preset-input" style="flex:1; color:#aaa;" placeholder="数据值 (Value)" value="${p.val}" oninput="presetEditor.update(${i}, 'val', this.value)">
                    <span class="preset-del" onclick="presetEditor.remove(${i})">✕</span>
                `;
                this.listEl.appendChild(row);
            });
        },

        update: function(idx, field, value) {
            this.tempPresets[idx][field] = value;
        },

        add: function() {
            const MAX_PRESET_COUNT = 9; // 设置预设的最大数量
            if (this.tempPresets.length >= MAX_PRESET_COUNT) {
                alert(`最多只能设置 ${MAX_PRESET_COUNT} 个预设关系。`);
                return;
            }
            this.tempPresets.push({ label: '新关系', val: 'new_rel', color: getRandomColor() });
            this.renderList();
            // 滚动到底部
            setTimeout(() => this.listEl.scrollTop = this.listEl.scrollHeight, 10);
        },

        remove: function(idx) {
            this.tempPresets.splice(idx, 1);
            this.renderList();
        },

        saveAndClose: function() {
            // 验证：Value 不能为空
            if (this.tempPresets.some(p => !p.val.trim())) {
                alert("预设的 Value (数据值) 不能为空。"); return;
            }
            // 验证：Value 是否重复
            const values = this.tempPresets.map(p => p.val.trim());
            const hasDuplicate = new Set(values).size !== values.length;
            if (hasDuplicate) {
                alert("预设的 Value (数据值) 不能重复。"); return;
            }

            RELATION_PRESETS = JSON.parse(JSON.stringify(this.tempPresets));
            saveToLocal();
            restartSim(); // 重绘以应用新颜色和可能的新链接标签
            this.close();
            showFlashMessage("预设已更新");
        },

        close: function() {
            this.el.classList.remove('active');
            this.active = false;
        }
    };
    // 预设编辑器结束 ---

    // --- Resize Sidebar ---

    let currentSidebarWidth = 340; // 默认侧边栏宽度

    // 设置初始 CSS 变量
    document.documentElement.style.setProperty('--sidebar-width', `${currentSidebarWidth}px`);
    // 拖动逻辑
    let isResizing = false;
    document.getElementById('sidebar-resizer').addEventListener('mousedown', (e) => {
        isResizing = true;
        // 阻止选择文本等默认行为
        e.preventDefault();
        // 鼠标拖动时，禁用 canvas 上的事件，避免拖动冲突
        canvas.style.pointerEvents = 'none';
        document.body.style.cursor = 'ew-resize'; // 拖动时改变光标
    });
    document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;
        // 计算新的侧边栏宽度
        // 鼠标位置 e.clientX 距离屏幕右侧的距离就是侧边栏的新宽度
        const newWidth = window.innerWidth - e.clientX;
        
        // 限制最小和最大宽度
        const minWidth = 250; 
        const maxWidth = window.innerWidth * 0.6; // 最大不超过屏幕宽度的60%
        currentSidebarWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
        // 更新 CSS 变量
        document.documentElement.style.setProperty('--sidebar-width', `${currentSidebarWidth}px`);
        
        // 同时更新 canvas 内部的宽度变量，用于D3渲染计算
        width = window.innerWidth - currentSidebarWidth;
        canvas.width = width; // 重新设置 canvas 元素的物理宽度
        // 注意：这里的 width 和 height 变量在 D3 渲染函数中会被使用
    });
    document.addEventListener('mouseup', () => {
        if (!isResizing) return;
        isResizing = false;
        canvas.style.pointerEvents = 'auto'; // 恢复 canvas 上的事件
        document.body.style.cursor = 'default'; // 恢复默认光标
    });
    // 窗口大小调整时，也要更新 canvas 的宽度和 sidebar-resizer 的位置
    window.addEventListener('resize', () => { 
        canvas.width = window.innerWidth - currentSidebarWidth;
        canvas.height = window.innerHeight; // 高度始终是视口高度
    });

    // --- 5. New Logic Implementation ---
    // [Tab] 关联新建
    async function createConnectedNodeFlow() {
        if (getNodeLinkCount(focusNode.uuid) >= MAX_LINKS_PER_NODE) {
            showFlashMessage(`连接已满 - 无法创建`); return;
        }
        try {
            let type = await relationPicker.show();
            if (type === 'CUSTOM') { 
                let customType = prompt("请输入链接关系名称:"); 
                if (!customType) return; 
                // 检查自定义类型是否与某个预设的 label 匹配
                const matchedPreset = RELATION_PRESETS.find(p => p.label === customType);
                type = matchedPreset ? matchedPreset.val : customType;
            }
            
            const newNode = { 
                uuid: uuid.v4(), label: "新概念", 
                x: focusNode.x + (Math.random()-.5)*100, y: focusNode.y + (Math.random()-.5)*100, 
                summary: "", content: "", color: getRandomColor(), alpha: 0 
            };
            data.nodes.push(newNode);
            data.links.push({ source: focusNode, target: newNode, type: type, alpha: 0 });
            restartSim();
            navigateTo(newNode, true, false);
            focusTitle(); // 自动跳转编辑标题
        } catch(e) { /* Cancelled */ }
    }
    // [Shift+Tab] 独立新建
    function createIndependentNodeFlow() {
        const newNode = { 
            uuid: uuid.v4(), label: "独立概念", 
            x: focusNode.x + 150, y: focusNode.y + 50, 
            summary: "", content: "", color: getRandomColor(), alpha: 0 
        };
        data.nodes.push(newNode);
        restartSim();
        navigateTo(newNode, true, false);
        focusTitle(); // 自动跳转编辑标题
    }
    // [Shift+L] 连接到上一个历史节点
    async function linkToBackFlow() {
        let target = null;
        for(let i = navHistory.length - 1; i >= 0; i--) {
            if(data.nodes.find(n => n.uuid === navHistory[i].uuid) && navHistory[i].uuid !== focusNode.uuid) {
                target = navHistory[i]; break;
            }
        }
        if (!target) { showFlashMessage("没有有效的历史节点"); return; }
        await createLinkProcess(target);
    }
    // [L] 连接到槽位
    async function linkToSlotFlow() {
        try {
            const slotIdx = await slotPicker.show();
            const target = slots[slotIdx];
            if (!target) { showFlashMessage("槽位为空"); return; }
            if (target.uuid === focusNode.uuid) { showFlashMessage("无法自连接"); return; }
            await createLinkProcess(target);
        } catch (e) {}
    }
    // 通用连接处理（含覆盖逻辑）
    async function createLinkProcess(target) {
        // 检查是否存在现有链接（无论方向）
        const existingLink = data.links.find(l => 
            (l.source.uuid === focusNode.uuid && l.target.uuid === target.uuid) || 
            (l.source.uuid === target.uuid && l.target.uuid === focusNode.uuid)
        );
        if (existingLink) {
            // 计算当前请求的方向是否与现有链接相反
            // 现有: existingLink.source -> existingLink.target
            // 请求: focusNode -> target
            const isReverse = existingLink.source.uuid === target.uuid;
            const directionStr = isReverse ? " (反向覆盖)" : "";
            const currentPreset = RELATION_PRESETS.find(p => p.val === existingLink.type);
            const currentLinkLabel = currentPreset ? currentPreset.label : existingLink.type;

            if (confirm(`已存在与 [${target.label}] 的链接 (${currentLinkLabel}).\n要覆盖它吗？${directionStr}`)) {
                try {
                    let type = await relationPicker.show();
                    if (type === 'CUSTOM') { 
                        let customType = prompt("请输入链接关系名称:", currentLinkLabel); 
                        if (!customType) return; 
                        const matchedPreset = RELATION_PRESETS.find(p => p.label === customType);
                        type = matchedPreset ? matchedPreset.val : customType;
                    }
                    
                    // 更新类型
                    existingLink.type = type;
                    
                    // 如果方向相反，需要交换 source 和 target 以更新方向
                    if (isReverse) {
                        existingLink.source = focusNode;
                        existingLink.target = target;
                    }
                    showFlashMessage("链接关系及方向已更新");
                    restartSim();
                } catch(e) {}
            }
            return;
        }
        // 新建链接的逻辑...
        if (getNodeLinkCount(focusNode.uuid) >= MAX_LINKS_PER_NODE || getNodeLinkCount(target.uuid) >= MAX_LINKS_PER_NODE) {
            showFlashMessage(`连接数已满`); return;
        }
        try {
            let type = await relationPicker.show();
            if (type === 'CUSTOM') { 
                let customType = prompt("请输入链接关系名称:"); 
                if (!customType) return; 
                const matchedPreset = RELATION_PRESETS.find(p => p.label === customType);
                type = matchedPreset ? matchedPreset.val : customType;
            }
            data.links.push({ source: focusNode, target: target, type: type, alpha: 0 });
            restartSim();
        } catch(e) {}
    }
    // 聚焦标题并全选
    function focusTitle() {
        setTimeout(() => {
            const el = document.getElementById('node-label');
            el.focus(); el.select();
        }, 50);
    }
    // --- Content Modal ---
    const modal = document.getElementById('content-modal');
    const modalBody = document.getElementById('modal-body');
    function showContentModal() {
        if(!focusNode) return;
        // 使用 marked.js 渲染 Markdown
        const htmlContent = marked.parse(focusNode.content || "*暂无正文内容*");
        modalBody.innerHTML = `
            <div style="font-size:2em; font-weight:bold; color:#4facfe; margin-bottom:10px;">${focusNode.label}</div>
            <div style="color:#666; font-style:italic; margin-bottom:20px; border-left:3px solid #555; padding-left:10px;">
                ${focusNode.summary ? marked.parse(focusNode.summary) : '无摘要'}
            </div>
            <hr style="border:0; border-bottom:1px solid #333; margin-bottom:20px;">
            <div style="line-height:1.8; font-size:16px;">${htmlContent}</div>
            <div style="margin-top:50px; text-align:center; font-size:12px; color:#444;">按 ESC 关闭</div>
        `;
        modal.classList.add('active');
        
        // 模态框内的按键监听
        const closeModalHandler = (e) => {
            if (e.key === 'Escape') {
                closeContentModal();
                e.stopPropagation(); // 阻止事件冒泡到 window 上的其他监听器
                e.preventDefault(); // 阻止任何潜在的默认行为
                window.removeEventListener('keydown', closeModalHandler);
            }
        };
        window.addEventListener('keydown', closeModalHandler);
    }
    function closeContentModal() {
        modal.classList.remove('active');
    }
    // --- Helpers & UI ---
    function getRandomColor() {
        const h = Math.random(); const s = 1; const v = 1; let r, g, b;
        const i = Math.floor(h * 6); const f = h * 6 - i; const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break;
        }
        const toHex = (c) => Math.round(c * 255).toString(16).padStart(2, '0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    const ui = { 
        label: document.getElementById('node-label'), 
        uuid: document.getElementById('node-uuid'), 
        linkStatus: document.getElementById('link-status'), 
        summary: document.getElementById('node-summary'), 
        content: document.getElementById('node-content'), 
        colorInput: document.getElementById('node-color-input'), 
        colorHex: document.getElementById('node-color-hex') 
    };
    function updateUI() {
        if(!focusNode) return;
        ui.label.value = focusNode.label;
        ui.uuid.innerText = "UUID: " + focusNode.uuid;
        ui.summary.value = focusNode.summary || "";
        ui.content.value = focusNode.content || "";
        ui.colorInput.value = focusNode.color || DEFAULT_NODE_COLOR;
        ui.colorHex.value = focusNode.color || DEFAULT_NODE_COLOR;
        const count = getNodeLinkCount(focusNode.uuid);
        ui.linkStatus.innerText = `Links: ${count} / ${MAX_LINKS_PER_NODE}`;
        if(count >= MAX_LINKS_PER_NODE) ui.linkStatus.classList.add('full'); else ui.linkStatus.classList.remove('full');
    }
    // 自定义编辑器 Tab 切换逻辑
    function handleEditorTab(e, nextId, prevId) {
        if (e.key === 'Tab') {
            e.preventDefault();
            const targetId = e.shiftKey ? prevId : nextId;
            if (targetId) {
                const el = document.getElementById(targetId);
                el.focus();
                // 如果是文本输入框，全选内容
                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') el.select();
            }
        }
    }
    ui.label.addEventListener('input', () => { if(focusNode) { focusNode.label = ui.label.value; updateSlotUI(); saveToLocal(); } });
    ui.label.addEventListener('keydown', (e) => handleEditorTab(e, 'node-summary', 'node-content'));
    ui.summary.addEventListener('input', () => { if(focusNode) { focusNode.summary = ui.summary.value; saveToLocal(); } });
    ui.summary.addEventListener('keydown', (e) => handleEditorTab(e, 'node-content', 'node-label'));
    ui.content.addEventListener('input', () => { if(focusNode) { focusNode.content = ui.content.value; saveToLocal(); } });
    ui.content.addEventListener('keydown', (e) => handleEditorTab(e, 'node-label', 'node-summary'));
    ui.colorInput.addEventListener('input', () => { if(focusNode) { focusNode.color = ui.colorInput.value; ui.colorHex.value = ui.colorInput.value; saveToLocal(); updateSlotUI(); } });
    
    function restartSim() { simulation.nodes(data.nodes); simulation.force("link").links(data.links); simulation.alpha(1).restart(); saveToLocal(); updateUI(); }
    
    function saveToLocal() {
        const payload = { 
            data: { 
                nodes: data.nodes.map(n => ({ uuid: n.uuid, label: n.label, isRoot: n.isRoot, x: n.x, y: n.y, summary: n.summary, content: n.content, color: n.color })), 
                links: data.links.map(l => ({ source: l.source.uuid, target: l.target.uuid, type: l.type })) 
            }, 
            slots: slots.map(s => s ? s.uuid : null), 
            viewLayers: viewLayers,
            presets: RELATION_PRESETS // --- 新增：保存预设 ---
        };
        localStorage.setItem('stars_v4', JSON.stringify(payload));
    }
    
    function exportData() { saveToLocal(); const b = new Blob([localStorage.getItem('stars_v4')], {type:'application/json'}); const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'stars_v4.json'; a.click(); }
    
    function importData(inp) { const f = inp.files[0]; if(f) { const r = new FileReader(); r.onload = e => { localStorage.setItem('stars_v4', e.target.result); location.reload(); }; r.readAsText(f); } }
    
    window.addEventListener('resize', () => { width=window.innerWidth-340; height=window.innerHeight; canvas.width=width; canvas.height=height; });
    
    // Start
    initSystem();
</script>
</body>
</html>