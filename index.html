<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ˜Ÿç½— (Stars v5.0 Refactored)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.3.0/lib/marked.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css">
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body { margin: 0; overflow: hidden; background-color: #050508; font-family: 'Segoe UI', sans-serif; color: #ddd; }
        #canvas { display: block; width: calc(100vw - var(--sidebar-width, 340px)); height: 100vh; cursor: crosshair; outline: none; }
        #sidebar { position: fixed; right: 0; top: 0; width: var(--sidebar-width, 340px); height: 100vh; background: #111114; border-left: 1px solid #2a2a30; padding: 25px; box-sizing: border-box; display: flex; flex-direction: column; z-index: 10; box-shadow: -5px 0 20px rgba(0,0,0,0.8); }
        #sidebar-resizer { position: fixed; right: var(--sidebar-width, 340px); top: 0; width: 8px; height: 100vh; background: #050508; cursor: ew-resize; z-index: 11; transition: background 0.2s; }
        #sidebar-resizer:hover { background: #4facfe; }
        input, textarea { background: transparent; border: none; color: #eee; outline: none; width: 100%; display: block; font-family: 'Segoe UI', sans-serif; }
        input::placeholder, textarea::placeholder { color: #444; font-style: italic; }
        #node-label { font-size: 28px; font-weight: 700; margin-bottom: 8px; color: #4facfe; border-bottom: 2px solid #2a2a30; padding-bottom: 8px; }
        #node-label:focus { border-bottom-color: #4facfe; }
        #node-uuid { font-size: 10px; color: #444; font-family: monospace; margin-bottom: 5px; user-select: all;}
        #link-status { font-size: 12px; font-family: monospace; margin-bottom: 15px; color: #666; font-weight: bold; display: flex; justify-content: space-between;}
        #node-summary { font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; background: #0d0d0f; border: 1px solid transparent; border-radius: 4px; padding: 5px; height: 60px; resize: vertical; }
        #node-summary:focus { border-color: #333; background: #151518; }
        #node-content { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 15px; resize: none; font-family: 'Consolas', 'Courier New', monospace; line-height: 1.7; border-radius: 6px; font-size: 13px; color: #ccc; }
        #node-content:focus { border-color: #4facfe; }
        #node-color-container { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        #node-color-input { width: 30px; height: 30px; background: transparent; border: none; cursor: pointer; padding: 0; }
        #node-color-hex { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 8px 10px; border-radius: 6px; font-size: 13px; color: #ccc; text-transform: uppercase; }
        #hud { position: fixed; top: 20px; left: 25px; pointer-events: none; z-index: 5; opacity: 0.9; display: flex; flex-direction: column; gap: 20px;}
        h1 { margin: 0; font-size: 18px; color: #555; letter-spacing: 2px; text-transform: uppercase; }
        .controls { font-size: 12px; color: #444; line-height: 1.6; font-family: monospace; }
        .key { color: #4facfe; font-weight: bold; background: rgba(79, 172, 254, 0.1); padding: 2px 4px; border-radius: 3px;}
        #slot-bar { display: flex; gap: 15px; pointer-events: auto; margin-top: 5px;}
        .slot { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; opacity: 0.6; transition: 0.3s; width: 60px; }
        .slot:hover { opacity: 1; transform: scale(1.1); }
        .slot.active { opacity: 1; }
        .slot-circle { width: 24px; height: 24px; border-radius: 50%; background: #333; border: 2px solid transparent; box-shadow: 0 0 5px rgba(0,0,0,0.5); transition: 0.3s; position: relative; }
        .slot-num { position: absolute; top: -5px; left: -5px; font-size: 10px; font-weight: bold; color: #666; background: #050508; padding: 1px 3px; border-radius: 4px; }
        .slot.active .slot-num { color: #4facfe; }
        .slot-name { font-size: 11px; color: #888; text-align: center; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .slot.active .slot-name { color: #ddd; font-weight: bold; }
        #view-controls { font-family: monospace; color: #666; font-size: 12px; }
        #layer-indicator { color: #4facfe; font-weight: bold; }
        #link-mode-indicator { display: none; font-size: 14px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); margin-top: 5px; }
        #link-mode-indicator.active { display: inline-block; animation: pulse-text 2s infinite; }
        @keyframes pulse-text { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
        .overlay-menu { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateX(-170px); background: #1a1a1d; border: 1px solid #444; padding: 15px; border-radius: 8px; display: none; flex-direction: column; gap: 6px; z-index: 50; box-shadow: 0 10px 30px rgba(0,0,0,1); min-width: 260px; }
        .overlay-menu.active { display: flex; }
        .menu-title { font-size: 12px; color: #888; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        .menu-opt { font-size: 13px; color: #ccc; padding: 8px 10px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: background 0.2s;}
        .menu-opt:hover, .menu-opt.selected { background: #333; color: #fff; }
        .menu-key { color: #4facfe; font-weight: bold; font-family: monospace; margin-right: 12px; min-width: 20px;}
        .menu-opt.delete-opt { color: #e74c3c; }
        #tooltip { position: absolute; opacity: 0; background: rgba(0, 0, 0, 0.9); padding: 10px 14px; border-radius: 4px; border-left: 3px solid #4facfe; pointer-events: none; color: #ddd; font-size: 12px; transition: opacity 0.15s; z-index: 100; max-width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.6);}
        #tooltip.fixed-mode { top: 70%; left: 50%; transform: translate(-50%, 0) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); text-align: center; border-left: none; border-top: 3px solid #4facfe; }
        #flash-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); padding: 15px 30px; border-radius: 8px; font-weight: bold; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 404; box-shadow: 0 0 30px rgba(0,0,0,0.5); text-transform: uppercase; letter-spacing: 1px; }
        #flash-message.info { background: rgba(0, 123, 255, 0.15); color: #4facfe; border: 1px solid #4facfe; }
        #flash-message.warn { background: rgba(255, 0, 0, 0.15); color: #ff4d4d; border: 1px solid #ff4d4d; }
        #content-modal { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.85); z-index: 300; justify-content: center; align-items: center; }
        #content-modal.active { display: flex; }
        #modal-body { background: #161619; width: 800px; max-width: 90%; height: 85%; border: 1px solid #333; border-radius: 8px; padding: 40px; box-sizing: border-box; overflow-y: auto; color: #ccc; box-shadow: 0 0 50px rgba(0,0,0,1); }
        #modal-body h1, #modal-body h2, #modal-body h3 { color: #fff; border-bottom: 1px solid #333; padding-bottom: 5px; margin-top: 20px;}
        #modal-body a { color: #4facfe; text-decoration: none; }
        #io-controls { position: fixed; bottom: 20px; left: 25px; z-index: 5; display: flex; gap: 10px; }
        button { background: #1a1a1d; color: #777; border: 1px solid #333; padding: 6px 12px; cursor: pointer; font-size: 11px; border-radius: 3px; transition: 0.2s; }
        button:hover { background: #333; color: #fff; border-color: #555; }
        #preset-editor { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #161619; border: 1px solid #333; border-radius: 8px; padding: 20px; width: 500px; max-width: 90%; z-index: 400; display: none; flex-direction: column; gap: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        #preset-editor.active { display: flex; }
        .preset-list { max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .preset-row { display: flex; gap: 10px; align-items: center; background: #0a0a0c; padding: 5px; border-radius: 4px; border: 1px solid #222; }
        .preset-row:hover { border-color: #444; }
        .preset-input { background: transparent; border: none; color: #ddd; font-family: monospace; font-size: 12px; padding: 4px; border-bottom: 1px solid transparent; }
        .preset-input:focus { border-bottom-color: #4facfe; }
        .preset-color { width: 25px; height: 25px; border: none; background: none; cursor: pointer; padding: 0; }
        .preset-idx { color: #4facfe; font-weight: bold; font-family: monospace; width: 20px; text-align: center; user-select: none; }
        .preset-del { color: #e74c3c; cursor: pointer; font-weight: bold; padding: 0 5px; user-select: none; }
        .preset-del:hover { color: #ff6b6b; }
        .preset-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px; }
        .btn-primary { background: #2980b9; color: white; border-color: #3498db; }
        .btn-primary:hover { background: #3498db; }
        #modal-body code { background: #282c34; padding: 3px 6px; border-radius: 4px; font-family: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace; color: #abb2bf; font-size: 0.95em; }
        #modal-body pre { background: #282c34; padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 1em; margin-bottom: 1em; }
        #modal-body pre code { background: none; padding: 0; font-size: 1em; color: #abb2bf; line-height: 1.5; }
    </style>
</head>
<body>

<div id="hud">
    <h1>æ˜Ÿç½— <span style="font-size:10px; opacity:0.5">v5.0 Refactored</span></h1>
    <div id="slot-bar">
        <div class="slot" id="slot-1" onclick="App.Input.handleSlot(0)" oncontextmenu="App.Input.clearSlot(0, event)"><div class="slot-circle"><span class="slot-num">1</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-2" onclick="App.Input.handleSlot(1)" oncontextmenu="App.Input.clearSlot(1, event)"><div class="slot-circle"><span class="slot-num">2</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-3" onclick="App.Input.handleSlot(2)" oncontextmenu="App.Input.clearSlot(2, event)"><div class="slot-circle"><span class="slot-num">3</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-4" onclick="App.Input.handleSlot(3)" oncontextmenu="App.Input.clearSlot(3, event)"><div class="slot-circle"><span class="slot-num">4</span></div><span class="slot-name">-</span></div>
    </div>
    <div id="view-controls">è§†é‡èŒƒå›´: <span id="layer-indicator">1</span> å±‚ (æŒ‰ +/- è°ƒæ•´)<br>å½“å‰å¯è§: <span id="visible-count">0</span> èŠ‚ç‚¹</div>
    <div id="link-mode-indicator">ğŸ”— è¿çº¿æ¨¡å¼: è·³è½¬ä»¥è¿æ¥/Esc å–æ¶ˆ</div>
    <div id="key-controls" class="controls">
        <span class="key">L</span> <span class="key">å‰ä¾§é”®</span> æ–°å»ºå…³ç³» <span class="key">Tab</span> <span class="key">N</span> æ–°å»ºèŠ‚ç‚¹<br>
        <span class="key">Del</span> <span class="key">D</span> <span class="key">å³é”®</span> åˆ é™¤å…³ç³»/èŠ‚ç‚¹<br>
        <span class="key">â†‘â†“â†â†’ /?</span> <span class="key">å·¦é”®</span> ç§»åŠ¨ <br>
        <span class="key">F2</span> æ”¹å <span class="key">Space</span> ç¼–è¾‘ <span class="key">Enter</span> <span class="key">å·¦é”®ç„¦ç‚¹</span> æŸ¥çœ‹<br>
        <span class="key">(Shift)1-4</span> (å­˜å…¥)äº¤æ¢ <span class="key">H</span> å›å®¶ <span class="key">B</span> <span class="key">åä¾§é”®</span> åé€€<br>
        <span class="key">, .</span> é¢„è§ˆé‚»å±… <span class="key">< ></span> è‡ªç”±æ—‹è½¬<br>
        <span class="key">`</span> å…³ç³»é¢„è®¾ <span class="key">I</span> éšè—æ­¤æç¤º
    </div>
</div>

<div id="flash-message"></div>
<div id="relation-picker" class="overlay-menu"></div>

<div id="preset-editor">
    <div class="menu-title">é¢„è®¾å…³ç³»ç¼–è¾‘å™¨ <span style="float:right; cursor:pointer" onclick="App.UI.PresetEditor.close()">âœ•</span></div>
    <div class="controls" style="margin-bottom:10px; color:#666;">å®šä¹‰å¸¸ç”¨çš„è¿æ¥ç±»å‹ã€‚æŒ‰ Enter ä¿å­˜ã€‚</div>
    <div class="preset-list" id="preset-list-container"></div>
    <div class="preset-actions">
        <button onclick="App.UI.PresetEditor.add()">+ æ–°å¢é¢„è®¾</button>
        <button class="btn-primary" onclick="App.UI.PresetEditor.saveAndClose()">ä¿å­˜å¹¶åº”ç”¨</button>
    </div>
</div>

<div id="content-modal" onclick="App.UI.Modal.close()"><div id="modal-body" onclick="event.stopPropagation()"></div></div>

<div id="io-controls">
    <button onclick="App.Store.saveToLocal()">ä¿å­˜</button>
    <button onclick="App.Store.exportData()">å¯¼å‡º</button>
    <button onclick="App.Store.resetSystem()">é‡ç½®ç³»ç»Ÿ</button>
    <input type="file" id="importFile" style="display:none" onchange="App.Store.importData(this)">
    <button onclick="document.getElementById('importFile').click()">å¯¼å…¥</button>
    <button onclick="App.UI.PresetEditor.open()">é¢„è®¾ç®¡ç†</button>
</div>

<div id="sidebar">
    <input type="text" id="node-label" placeholder="æ¦‚å¿µåç§°">
    <div id="node-uuid">UUID: -</div>
    <div id="link-status">è¿æ¥æ•°: -</div>
    <textarea id="node-summary" placeholder="ç®€çŸ­æ‘˜è¦ (Markdown/HTML)..."></textarea>
    <div id="node-color-container">
        <input type="color" id="node-color-input">
        <input type="text" id="node-color-hex" placeholder="#FFFFFF">
    </div>
    <textarea id="node-content" placeholder="è¯¦ç»†ç¬”è®° (Markdownæ”¯æŒ)..."></textarea>
</div>
<div id="sidebar-resizer"></div>
<div id="tooltip"></div>
<canvas id="canvas"></canvas>

<script>
/**
 * Stars v5.0 (Web Edition)
 * Fixes: Slot Swap, Navigation Safety (Orphan Check), Async Logic
 */
const App = {};

// ==========================================
// 1. Utils (å·¥å…·å‡½æ•°)
// ==========================================
App.Utils = {
    debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },
    getRandomColor() {
        const h = Math.random(); const s = Math.random(); const v = 1; let r, g, b;
        const i = Math.floor(h * 6); const f = h * 6 - i; const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break;
        }
        const toHex = (c) => Math.round(c * 255).toString(16).padStart(2, '0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    },
    findReachable(allNodes, allLinks, startNodes) {
        const reachable = new Set();
        const queue = [];
        startNodes.forEach(s => {
            if (s && !reachable.has(s.uuid)) {
                const exists = allNodes.find(n => n.uuid === s.uuid);
                if(exists) { reachable.add(s.uuid); queue.push(exists); }
            }
        });
        const adj = {};
        allLinks.forEach(l => {
            const s = l.source.uuid || l.source;
            const t = l.target.uuid || l.target;
            if(!adj[s]) adj[s] = []; adj[s].push(t);
            if(!adj[t]) adj[t] = []; adj[t].push(s);
        });
        let head = 0;
        while(head < queue.length) {
            const curr = queue[head++];
            const neighbors = adj[curr.uuid] || [];
            neighbors.forEach(nid => {
                if (!reachable.has(nid)) {
                    reachable.add(nid);
                    const nodeObj = allNodes.find(n => n.uuid === nid);
                    if(nodeObj) queue.push(nodeObj);
                }
            });
        }
        return reachable;
    }
};

// ==========================================
// 2. Store (æ•°æ®æ ¸å¿ƒ & å®‰å…¨é€»è¾‘)
// ==========================================
App.Store = {
    state: {
        nodes: [],
        links: [],
        slots: [null, null, null, null],
        focusNode: null,
        viewLayers: 1,
        navHistory: [],
        presets: [
            { label: 'åŒ…å«...', val: 'comp', color: '#0062ff' },
            { label: 'å®šä¹‰ä¸º...', val: 'def', color: '#00ff00' },
            { label: 'ç›´è§‚ç†è§£', val: 'ins', color: '#33ffff' },
            { label: 'è®¡ç®—...', val: 'calc', color: '#ffaa00' },
            { label: 'æ„å‘³ç€...', val: 'impl', color: '#bd00ff' },
            { label: 'ä¸...æ­£äº¤', val: 'orth', color: '#ff0055' },
        ]
    },
    
    init() {
        const saved = localStorage.getItem('stars_v4');
        if (saved) {
            try {
                const raw = JSON.parse(saved);
                this.state.nodes = raw.data.nodes;
                this.state.links = raw.data.links;
                if (raw.presets && Array.isArray(raw.presets)) this.state.presets = raw.presets;
                const nodeMap = new Map(this.state.nodes.map(n => [n.uuid, n]));
                this.state.links.forEach(l => {
                    if(typeof l.source === 'string') l.source = nodeMap.get(l.source) || l.source;
                    if(typeof l.target === 'string') l.target = nodeMap.get(l.target) || l.target;
                    l.alpha = 0;
                });
                this.state.nodes.forEach(n => { n.alpha = 0; });
                this.state.slots = raw.slots ? raw.slots.map(uuid => uuid ? nodeMap.get(uuid) : null) : [null, null, null, null];
                this.state.viewLayers = raw.viewLayers || 1;
                this.state.focusNode = raw.focusNodeUuid ? nodeMap.get(raw.focusNodeUuid) : (this.state.nodes.find(n => n.isRoot) || this.state.nodes[0]);
            } catch(e) { console.error("Load error:", e); this.createRoot(); }
        } else { this.createRoot(); }

        if(!this.state.focusNode){ this.createRoot(); this.state.focusNode = this.state.nodes[0]; }
        this.state.focusNode.alpha = 1;
        App.UI.updateSidebar();
        App.UI.updateSlotUI();
        App.Renderer.adjustZoomByLayer();
        App.Renderer.restartSim();
    },

    createRoot() {
        const rootUUID = uuid.v4();
        const root = { uuid: rootUUID, label: "Origin", isRoot: true, x: 0, y: 0, summary: "åˆå§‹å¥‡ç‚¹", content: "æ¬¢è¿æ¥åˆ°æ˜Ÿç½—ã€‚", color: "#ffffff", alpha: 1 };
        this.state.nodes = [root];
        this.state.links = [];
        this.state.slots = [null, null, null, null];
        this.state.focusNode = root;
        this.state.viewLayers = 1;
    },

    // --- CRITICAL FIX: Execute Safe Action (State Mutator Pattern) ---
    executeSafeAction(simulator) {
        const { nodes, focusNode, slots } = this.state;
        const getAnchors = (nl, fn, sl) => {
            const r = nl.find(n=>n.isRoot);
            return new Set([r, fn, ...sl].filter(x=>x).map(x=>x.uuid));
        };
        const curAnchors = getAnchors(nodes, focusNode, slots);

        // 1. Simulate
        const next = simulator();
        const nextAnchors = getAnchors(next.nodes, next.nextFocus, next.nextSlots);

        // 2. Check Structural Integrity
        const structIntact = next.nodes.length >= nodes.length && next.links.length >= this.state.links.length;
        const anchorsSame = curAnchors.size === nextAnchors.size && [...curAnchors].every(id => nextAnchors.has(id));

        // 3. Apply State Function
        const applyState = () => {
            this.state.nodes = next.nodes;
            this.state.links = next.links;
            this.state.focusNode = next.nextFocus;
            this.state.slots = next.nextSlots;
            
            // Link reference fixup if needed (simulation usually handles this but good to be safe)
            // Actually simulator passes objects usually.
            
            App.UI.updateSidebar();
            App.UI.updateSlotUI();
            this.saveToLocal();
            
            // Navigation logic
            if (this.state.focusNode) {
                this.state.focusNode.alpha = 1;
                // Add to history if changed
                const lastHist = this.state.navHistory[this.state.navHistory.length-1];
                if (!lastHist || lastHist.uuid !== this.state.focusNode.uuid) {
                     // Simple history push logic inside safe action if it was a navigation
                     // Note: This is a simplification. Ideally 'navigateTo' does history.
                     // We rely on the caller to handle history if needed, or we just let safeNavigate do it.
                }
            }
            
            App.Renderer.restartSim();
        };

        if (structIntact && anchorsSame) {
            applyState();
            return true;
        }

        // 4. Reachability Check
        const anchorObjs = next.nodes.filter(n => nextAnchors.has(n.uuid));
        const reachable = App.Utils.findReachable(next.nodes, next.links, anchorObjs);
        const lost = next.nodes.filter(n => !reachable.has(n.uuid));

        if (lost.length > 0) {
            const names = lost.slice(0, 3).map(n => n.label).join(', ');
            if (confirm(`è­¦å‘Šï¼šæ­¤æ“ä½œå°†å¯¼è‡´ ${lost.length} ä¸ªèŠ‚ç‚¹ä¸¢å¤±ï¼ˆå¦‚ ${names}...ï¼‰ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ`)) {
                applyState(); // Apply state first
                
                // Cleanup lost nodes
                const deadSet = new Set(lost.map(n => n.uuid));
                this.state.nodes = this.state.nodes.filter(n => !deadSet.has(n.uuid));
                this.state.links = this.state.links.filter(l => !deadSet.has(l.source.uuid) && !deadSet.has(l.target.uuid));
                this.state.slots = this.state.slots.map(s => (s && deadSet.has(s.uuid)) ? null : s);
                this.state.navHistory = this.state.navHistory.filter(n => !deadSet.has(n.uuid));
                lost.forEach(n => App.Runtime.clearStorage(n.uuid));
                
                this.saveToLocal();
                App.Renderer.restartSim();
                return true;
            }
            return false;
        } else {
            applyState();
            return true;
        }
    },

    saveToLocal() {
        const payload = {
            data: {
                nodes: this.state.nodes.map(n => ({ uuid: n.uuid, label: n.label, isRoot: n.isRoot, x: n.x, y: n.y, summary: n.summary, content: n.content, color: n.color })),
                links: this.state.links.map(l => ({ source: l.source.uuid, target: l.target.uuid, type: l.type }))
            },
            focusNodeUuid: this.state.focusNode ? this.state.focusNode.uuid : null,
            slots: this.state.slots.map(s => s ? s.uuid : null),
            viewLayers: this.state.viewLayers,
            presets: this.state.presets
        };
        localStorage.setItem('stars_v4', JSON.stringify(payload));
    },

    saveToLocalDebounced: null, 

    exportData() {
        this.saveToLocal();
        const b = new Blob([localStorage.getItem('stars_v4')], {type:'application/json'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = 'stars_v4.json'; a.click();
    },

    importData(inp) {
        const f = inp.files[0];
        if(f) {
            const r = new FileReader();
            r.onload = e => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (importedData && importedData.data) {
                        App.Runtime.clearAllStorage();
                        localStorage.setItem('stars_v4', e.target.result);
                        location.reload();
                    } else { App.UI.showFlash("å¯¼å…¥æ ¼å¼é”™è¯¯", 'warn'); }
                } catch (error) { App.UI.showFlash("è§£æé”™è¯¯", 'warn'); }
            };
            r.readAsText(f);
            inp.value = '';
        }
    },

    resetSystem() {
        if(confirm("é‡ç½®ç³»ç»Ÿå°†æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Œç¡®å®šå—ï¼Ÿ")) {
            App.Runtime.clearAllStorage();
            localStorage.removeItem('stars_v4');
            location.reload();
        }
    }
};
App.Store.saveToLocalDebounced = App.Utils.debounce(App.Store.saveToLocal, 1000);

// ==========================================
// 3. Runtime (èŠ‚ç‚¹è„šæœ¬æ²™ç®±)
// ==========================================
App.Runtime = {
    activeInstances: {},
    mount(node, containerId) {
        this.unmount(node.uuid);
        const container = document.getElementById(containerId);
        if (!container) return;
        const scriptsToExecute = [];
        const scriptElements = container.querySelectorAll('script');
        scriptElements.forEach(script => {
            scriptsToExecute.push(script.textContent);
            script.remove();
        });
        let unmountCallbacks = [];
        const api = {
            $: (sel) => container.querySelector(sel),
            $$: (sel) => container.querySelectorAll(sel),
            storage: this._createStorageApi(node.uuid),
            node: { uuid: node.uuid, label: node.label, color: node.color },
            onMount: (cb) => { try { cb(); } catch(e) { console.error(e); } },
            onUnmount: (cb) => { unmountCallbacks.push(cb); }
        };
        this.activeInstances[node.uuid] = {
            unmountFn: () => {
                unmountCallbacks.forEach(cb => { try { cb(); } catch(e) { console.error(e); } });
                unmountCallbacks = [];
            }
        };
        scriptsToExecute.forEach((code, idx) => {
            try {
                new Function('api', `(function(Runtime){ ${code} })(arguments[0])`)(api);
            } catch (e) {
                console.error(`Script error in node ${node.uuid}:`, e);
                container.appendChild(document.createTextNode(`[Script Error: ${e.message}]`));
            }
        });
    },
    unmount(uuid) {
        if (this.activeInstances[uuid]) {
            this.activeInstances[uuid].unmountFn();
            delete this.activeInstances[uuid];
        }
    },
    _createStorageApi(uuid) {
        const prefix = `node_storage_${uuid}_`;
        return {
            set: (k, v) => { try { localStorage.setItem(prefix + k, JSON.stringify(v)); return true; } catch(e){return false;} },
            get: (k, def) => { try { const i = localStorage.getItem(prefix + k); return i ? JSON.parse(i) : def; } catch(e){return def;} },
            remove: (k) => localStorage.removeItem(prefix + k),
            clear: () => this.clearStorage(uuid)
        };
    },
    clearStorage(uuid) {
        const prefix = `node_storage_${uuid}_`;
        for (let i = localStorage.length - 1; i >= 0; i--) {
            const key = localStorage.key(i);
            if (key.startsWith(prefix)) localStorage.removeItem(key);
        }
    },
    clearAllStorage() {
        const prefix = "node_storage_";
        for (let i = localStorage.length - 1; i >= 0; i--) {
            const key = localStorage.key(i);
            if (key.startsWith(prefix)) localStorage.removeItem(key);
        }
    }
};

// ==========================================
// 4. UI (ç•Œé¢ç®¡ç†)
// ==========================================
App.UI = {
    els: {},
    init() {
        this.els = {
            label: document.getElementById('node-label'),
            uuid: document.getElementById('node-uuid'),
            linkStatus: document.getElementById('link-status'),
            summary: document.getElementById('node-summary'),
            content: document.getElementById('node-content'),
            colorInput: document.getElementById('node-color-input'),
            colorHex: document.getElementById('node-color-hex')
        };
        this.els.label.addEventListener('input', () => this.onNodeEdit('label', this.els.label.value));
        this.els.label.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-summary', 'node-content'));
        this.els.summary.addEventListener('input', () => this.onNodeEdit('summary', this.els.summary.value));
        this.els.summary.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-content', 'node-label'));
        this.els.content.addEventListener('input', () => this.onNodeEdit('content', this.els.content.value));
        this.els.content.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-label', 'node-summary'));
        this.els.colorInput.addEventListener('input', () => {
            this.els.colorHex.value = this.els.colorInput.value;
            this.onNodeEdit('color', this.els.colorInput.value);
            this.updateSlotUI();
        });
        this.els.colorHex.addEventListener('input', () => {
            if(/^#[0-9A-F]{6}$/i.test(this.els.colorHex.value)) {
                this.els.colorInput.value = this.els.colorHex.value;
                this.onNodeEdit('color', this.els.colorHex.value);
                this.updateSlotUI();
            }
        });
        
        let isResizing = false;
        const resizer = document.getElementById('sidebar-resizer');
        resizer.addEventListener('mousedown', (e) => { isResizing = true; e.preventDefault(); App.Renderer.canvas.style.pointerEvents = 'none'; document.body.style.cursor = 'ew-resize'; });
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = Math.max(250, Math.min(window.innerWidth - e.clientX, window.innerWidth * 0.6));
            document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
            App.Renderer.resize();
        });
        document.addEventListener('mouseup', () => { if(isResizing) { isResizing = false; App.Renderer.canvas.style.pointerEvents = 'auto'; document.body.style.cursor = 'default'; } });
        window.addEventListener('resize', () => App.Renderer.resize());
    },

    onNodeEdit(field, value) {
        if(App.Store.state.focusNode) {
            App.Store.state.focusNode[field] = value;
            App.Store.saveToLocalDebounced();
        }
    },

    handleEditorTab(e, nextId, prevId) {
        if (e.key === 'Tab') {
            e.preventDefault();
            const targetId = e.shiftKey ? prevId : nextId;
            const el = document.getElementById(targetId);
            el.focus(); if(el.tagName!=='DIV') el.select();
        }
    },

    updateSidebar() {
        const node = App.Store.state.focusNode;
        if(!node) return;
        this.els.label.value = node.label;
        this.els.uuid.innerText = "UUID: " + node.uuid;
        this.els.summary.value = node.summary || "";
        this.els.content.value = node.content || "";
        this.els.colorInput.value = node.color || "#4facfe";
        this.els.colorHex.value = node.color || "#4facfe";
        const count = App.Store.state.links.filter(l => l.source.uuid === node.uuid || l.target.uuid === node.uuid).length;
        this.els.linkStatus.innerText = `Links: ${count}`;
    },

    updateSlotUI() {
        const { slots } = App.Store.state;
        for(let i=0; i<4; i++) {
            const el = document.getElementById(`slot-${i+1}`);
            const node = slots[i];
            const circle = el.querySelector('.slot-circle');
            const nameEl = el.querySelector('.slot-name');
            if (node) {
                el.classList.add('active');
                nameEl.innerText = node.label;
                circle.style.background = node.color || "#4facfe";
                circle.style.boxShadow = `0 0 8px ${node.color || "#4facfe"}`;
                circle.style.border = "1px solid rgba(255,255,255,0.3)";
            } else {
                el.classList.remove('active');
                nameEl.innerText = "-";
                circle.style.background = "#222";
                circle.style.boxShadow = "none";
                circle.style.border = "1px solid #333";
            }
        }
    },

    showFlash(msg, type = 'info') {
        const el = document.getElementById('flash-message');
        el.innerText = msg; el.className = type; el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 2000);
    },

    Modal: {
        el: document.getElementById('content-modal'),
        body: document.getElementById('modal-body'),
        show() {
            const node = App.Store.state.focusNode;
            if (!node) return;
            if(App.Runtime.activeInstances[node.uuid]) App.Runtime.unmount(node.uuid);
            this.body.innerHTML = '';
            const raw = node.content || "*æš‚æ— æ­£æ–‡å†…å®¹*";
            const html = typeof marked !== 'undefined' ? marked.parse(raw) : raw;
            const containerId = `node-content-host-${node.uuid}`;
            this.body.innerHTML = `
                <div style="font-size:2em; font-weight:bold; color:#4facfe; margin-bottom:10px;">${node.label}</div>
                <div style="color:#666; font-style:italic; margin-bottom:20px; border-left:3px solid #555; padding-left:10px;">
                    ${node.summary ? (typeof marked !== 'undefined' ? marked.parse(node.summary) : node.summary) : 'æ— æ‘˜è¦'}
                </div>
                <hr style="border:0; border-bottom:1px solid #333; margin-bottom:20px;">
                <div id="${containerId}" class="node-content-host" style="line-height:1.8; font-size:16px;">${html}</div>
                <div style="margin-top:50px; text-align:center; font-size:12px; color:#444; cursor:pointer;" onclick="App.UI.Modal.close()">æŒ‰ ESC å…³é—­</div>
            `;
            if (typeof hljs !== 'undefined') this.body.querySelectorAll('pre code').forEach(b => hljs.highlightElement(b));
            App.Runtime.mount(node, containerId);
            this.el.classList.add('active');
            this._escHandler = (e) => {
                if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); this.close(); }
            };
            window.addEventListener('keydown', this._escHandler);
        },
        close() {
            this.el.classList.remove('active');
            const node = App.Store.state.focusNode;
            if(node) App.Runtime.unmount(node.uuid);
            this.body.innerHTML = '';
            if(this._escHandler) window.removeEventListener('keydown', this._escHandler);
        }
    },

    RelationPicker: {
        el: document.getElementById('relation-picker'),
        active: false, resolve: null, reject: null, allowDelete: false,
        show(allowDelete = false) {
            this.allowDelete = allowDelete;
            return new Promise((res, rej) => {
                const presets = App.Store.state.presets;
                let html = `<div class="menu-title">1. é€‰æ‹©ç±»å‹ <span style="font-weight:normal; color:#888;">(Space è‡ªå®šä¹‰${allowDelete ? ', D åˆ é™¤' : ''})</span></div>`;
                html += presets.slice(0, 9).map((p, i) => 
                    `<div class="menu-opt" onclick="App.UI.RelationPicker.pick('${p.val}')"><span class="menu-key" style="color:${p.color}">[${i+1}]</span>${p.label}</div>`
                ).join('');
                if (presets.length > 9) html += `<div class="menu-title" style="margin-top:10px;">æ›´å¤š</div>` + presets.slice(9).map(p => `<div class="menu-opt" onclick="App.UI.RelationPicker.pick('${p.val}')"><span class="menu-key" style="visibility:hidden;">[]</span>${p.label}</div>`).join('');
                if (allowDelete) html += `<div class="menu-opt delete-opt" style="margin-top:5px; border-top:1px solid #333" onclick="App.UI.RelationPicker.pick('DELETE')"><span class="menu-key" style="color:#e74c3c">[D]</span><span style="color:#e74c3c">åˆ é™¤/æ–­å¼€è¿æ¥</span></div>`;
                this.el.innerHTML = html; this.el.classList.add('active'); this.active = true;
                this.resolve = res; this.reject = rej;
            });
        },
        handleInput(e) {
            if(!this.active) return;
            const num = parseInt(e.key);
            const presets = App.Store.state.presets;
            if (!isNaN(num) && num >= 1 && num <= Math.min(9, presets.length)) { e.preventDefault(); this.pick(presets[num-1].val); }
            else if (e.key === ' ') { e.preventDefault(); this.pick('CUSTOM'); }
            else if (e.key === 'Enter' && presets.length>0) { e.preventDefault(); this.pick(presets[0].val); }
            else if (this.allowDelete && ['d','D','Delete'].includes(e.key)) { e.preventDefault(); this.pick('DELETE'); }
            else if (e.key === 'Escape') { e.preventDefault(); this.reject(); this.close(); }
        },
        pick(val) { this.close(); if(this.resolve) this.resolve({ val }); },
        close() { this.el.classList.remove('active'); this.active = false; }
    },

    PresetEditor: {
        el: document.getElementById('preset-editor'),
        listEl: document.getElementById('preset-list-container'),
        active: false, tempPresets: [],
        open() {
            if(this.active) return;
            this.tempPresets = JSON.parse(JSON.stringify(App.Store.state.presets));
            this.renderList();
            this.el.classList.add('active'); this.active = true;
        },
        renderList() {
            this.listEl.innerHTML = '';
            this.tempPresets.forEach((p, i) => {
                const row = document.createElement('div'); row.className = 'preset-row';
                row.innerHTML = `
                    <span class="preset-idx">${i+1}</span>
                    <input type="color" class="preset-color" value="${p.color}" onchange="App.UI.PresetEditor.update(${i}, 'color', this.value)">
                    <input type="text" class="preset-input" style="width:120px" placeholder="æ˜¾ç¤ºåç§°" value="${p.label}" oninput="App.UI.PresetEditor.update(${i}, 'label', this.value)">
                    <input type="text" class="preset-input" style="flex:1; color:#aaa;" placeholder="Value" value="${p.val}" oninput="App.UI.PresetEditor.update(${i}, 'val', this.value)">
                    <span class="preset-del" onclick="App.UI.PresetEditor.remove(${i})">âœ•</span>`;
                this.listEl.appendChild(row);
            });
        },
        update(idx, field, val) { this.tempPresets[idx][field] = val; },
        remove(idx) { this.tempPresets.splice(idx, 1); this.renderList(); },
        add() { this.tempPresets.push({label:'New', val:'new', color: App.Utils.getRandomColor()}); this.renderList(); },
        saveAndClose() {
            App.Store.state.presets = JSON.parse(JSON.stringify(this.tempPresets));
            App.Store.saveToLocal(); App.Renderer.restartSim(); this.close();
            App.UI.showFlash("é¢„è®¾å·²æ›´æ–°");
        },
        close() { this.el.classList.remove('active'); this.active = false; }
    }
};

// ==========================================
// 5. Renderer (æ¸²æŸ“ä¸ç‰©ç†æ¨¡æ‹Ÿ)
// ==========================================
App.Renderer = {
    canvas: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),
    width: 0, height: 0,
    viewX: 0, viewY: 0, viewK: 1, viewRotation: 0, targetRotation: 0,
    simulation: null, pointerForce: null, lastRenderTime: 0,
    FADE_DURATION: 400, DEFAULT_NODE_COLOR: "#4facfe",

    init() {
        this.resize();
        this.simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.uuid).distance(220).strength(0.1))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("collide", d3.forceCollide(10))
            .force("center", d3.forceCenter(0, 0))
            .alphaDecay(0.05).alphaMin(0.05);

        const force = (() => {
            let node, target, strength = 0.25;
            function f(alpha) {
                if (!node || !target) return;
                const dx = target.x - node.x, dy = target.y - node.y;
                const k = strength * (1 - Math.exp(-Math.hypot(dx, dy) / 120)) * alpha;
                node.vx += dx * k; node.vy += dy * k;
            }
            f.initialize = () => {};
            f.node = (n) => { node = n; return f; };
            f.target = (x, y) => { target = {x,y}; return f; };
            return f;
        })();
        this.pointerForce = force;
        this.simulation.force('pointerDrag', this.pointerForce);
        requestAnimationFrame((t) => this.render(t));
    },

    resize() {
        this.width = window.innerWidth - (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width')) || 340);
        this.height = window.innerHeight;
        this.canvas.width = this.width; this.canvas.height = this.height;
    },

    adjustZoomByLayer() {
        this.viewK = Math.max(0.15, Math.min(2.5, 1.0 / (Math.pow(App.Store.state.viewLayers, 0.7))));
    },

    restartSim() {
        const { nodes, links, focusNode } = App.Store.state;
        const activeNodes = nodes; 
        const activeLinks = links;
        // Simplified sim for now, full culling logic can be re-enabled if perf is issue
        this.simulation.nodes(activeNodes);
        this.simulation.force("link").links(activeLinks);
        this.simulation.alpha(1).restart();
    },

    render(currentTime) {
        if (!this.lastRenderTime) this.lastRenderTime = currentTime;
        const deltaTime = currentTime - this.lastRenderTime;
        this.lastRenderTime = currentTime;

        const { nodes, links, focusNode, viewLayers } = App.Store.state;
        const { hoverNode, previewNode, linkMode } = App.Input.state;

        const targetX = this.width/2, targetY = this.height/2;
        if(focusNode) {
            this.viewX += ((-focusNode.x * this.viewK + targetX) - this.viewX) * 0.1;
            this.viewY += ((-focusNode.y * this.viewK + targetY) - this.viewY) * 0.1;
        }
        let diff = this.targetRotation - this.viewRotation;
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        this.viewRotation += diff * 0.1;

        this.ctx.save();
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.translate(this.width/2, this.height/2);
        this.ctx.rotate(this.viewRotation);
        this.ctx.translate(-this.width/2, -this.height/2);
        this.ctx.translate(this.viewX, this.viewY);
        this.ctx.scale(this.viewK, this.viewK);

        const visibleNodes = new Set();
        const visibleLinks = new Set();
        const addVis = (start, depth) => {
            if(!start) return;
            visibleNodes.add(start.uuid);
            let queue = [{n: start, d: 0}], head = 0;
            while(head < queue.length) {
                const {n, d} = queue[head++];
                if (d >= depth) continue;
                links.forEach(l => {
                    const s = l.source, t = l.target;
                    if (s.uuid === n.uuid) {
                        if(!visibleNodes.has(t.uuid)) { visibleNodes.add(t.uuid); queue.push({n:t, d:d+1}); }
                        visibleLinks.add(l);
                    } else if (t.uuid === n.uuid) {
                        if(!visibleNodes.has(s.uuid)) { visibleNodes.add(s.uuid); queue.push({n:s, d:d+1}); }
                        visibleLinks.add(l);
                    }
                });
            }
        };
        if(focusNode) addVis(focusNode, viewLayers);
        if(hoverNode && hoverNode!==focusNode) addVis(hoverNode, 1);
        if(previewNode && previewNode!==focusNode) addVis(previewNode, 1);

        links.forEach(l => {
            const isVis = visibleLinks.has(l);
            if(isVis && l.alpha < 1) l.alpha += deltaTime/this.FADE_DURATION;
            else if(!isVis && l.alpha > 0) l.alpha -= deltaTime/this.FADE_DURATION;
            l.alpha = Math.max(0, Math.min(1, l.alpha));

            if(l.alpha > 0.01) {
                const src = l.source, tgt = l.target;
                const isFocusLink = (src===focusNode || tgt===focusNode);
                const isHigh = (hoverNode && (src===hoverNode||tgt===hoverNode)) || (previewNode && (src===previewNode||tgt===previewNode));
                const mult = isFocusLink ? 0.9 : (isHigh ? 0.5 : 0.2);
                this.ctx.globalAlpha = l.alpha * mult;
                this.ctx.lineWidth = (isFocusLink || isHigh) ? 2.5 : 1.5;
                const typeColor = App.Store.state.presets.find(p=>p.val===l.type)?.color || '#666';
                const grad = this.ctx.createLinearGradient(src.x, src.y, tgt.x, tgt.y);
                grad.addColorStop(0, typeColor); grad.addColorStop(0.7, "#444"); grad.addColorStop(1, "#222");
                this.ctx.strokeStyle = grad;
                this.ctx.beginPath(); this.ctx.moveTo(src.x, src.y); this.ctx.lineTo(tgt.x, tgt.y); this.ctx.stroke();
                if (l.type && isFocusLink) {
                     const mx = (src.x+tgt.x)/2, my = (src.y+tgt.y)/2;
                     this.ctx.save(); this.ctx.translate(mx, my); this.ctx.rotate(-this.viewRotation);
                     this.ctx.fillStyle = typeColor; this.ctx.font = "11px Arial"; this.ctx.textAlign="center";
                     const label = App.Store.state.presets.find(p=>p.val===l.type)?.label || l.type;
                     this.ctx.fillText(label, 0, -8); this.ctx.restore();
                }
            }
        });

        const pulse = (Math.sin(currentTime * 0.002) + 1) * 0.5 * 20 + 10;
        let visibleCount = 0;
        nodes.forEach(n => {
            const isVis = visibleNodes.has(n.uuid);
            if(n === focusNode) n.alpha = 1;
            else {
                if(isVis && n.alpha < 1) n.alpha += deltaTime/this.FADE_DURATION;
                else if(!isVis && n.alpha > 0) n.alpha -= deltaTime/this.FADE_DURATION;
                n.alpha = Math.max(0, Math.min(1, n.alpha));
            }
            if (n.alpha > 0.01) {
                visibleCount++;
                const isFocus = (n === focusNode);
                const isPreview = (n === previewNode || n === hoverNode);
                const isSlot = App.Store.state.slots.includes(n);
                this.ctx.globalAlpha = isFocus ? 1 : n.alpha;
                let r = isFocus ? 20 : (isSlot ? 14 : 10);
                if (this.viewK < 0.5) r = r / this.viewK * 0.5;
                this.ctx.beginPath(); this.ctx.arc(n.x, n.y, r, 0, 2*Math.PI);
                this.ctx.fillStyle = n.color || this.DEFAULT_NODE_COLOR;
                if(isFocus) {
                    if (linkMode.active) {
                        this.ctx.shadowBlur = pulse; this.ctx.shadowColor = linkMode.color || '#fff';
                    } else { this.ctx.shadowBlur = 35; this.ctx.shadowColor = this.ctx.fillStyle; }
                } else if(isPreview) { this.ctx.shadowBlur = 20; this.ctx.shadowColor = this.ctx.fillStyle; } 
                else { this.ctx.shadowBlur = 0; }
                if (isFocus && linkMode.active) { this.ctx.strokeStyle = linkMode.color || '#fff'; this.ctx.lineWidth = 3; this.ctx.stroke(); }
                if(isSlot && !isFocus) { this.ctx.strokeStyle = "#fff"; this.ctx.lineWidth = 2; this.ctx.stroke(); }
                this.ctx.fill(); this.ctx.shadowBlur=0;
                if (isFocus || isPreview || n.alpha > 0.5) {
                    this.ctx.save(); this.ctx.translate(n.x, n.y); this.ctx.rotate(-this.viewRotation);
                    this.ctx.fillStyle = (isFocus || isPreview) ? "#fff" : "rgba(200,200,200,0.7)";
                    this.ctx.font = (isFocus || isPreview) ? "bold 14px Arial" : "11px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText(n.label, 0, r + 16);
                    const sIdx = App.Store.state.slots.indexOf(n);
                    if (sIdx >= 0) { this.ctx.fillStyle = "#4facfe"; this.ctx.font = "bold 11px monospace"; this.ctx.fillText(`[${sIdx+1}]`, 0, -r - 6); }
                    this.ctx.restore();
                }
            }
        });
        this.ctx.restore();
        document.getElementById('visible-count').innerText = visibleCount;
        requestAnimationFrame((t) => this.render(t));
    },

    screenToWorld(sx, sy) {
        let x = sx - this.width/2, y = sy - this.height/2;
        const cos = Math.cos(-this.viewRotation), sin = Math.sin(-this.viewRotation);
        let rx = x * cos - y * sin, ry = x * sin + y * cos;
        return { x: (rx + this.width/2 - this.viewX) / this.viewK, y: (ry + this.height/2 - this.viewY) / this.viewK };
    },
    setTargetRotation(rad) {
        let current = this.targetRotation; let diff = rad - current;
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        this.targetRotation = current + diff;
    }
};

// ==========================================
// 6. Input (äº¤äº’æ§åˆ¶)
// ==========================================
App.Input = {
    state: {
        hoverNode: null, previewNode: null,
        linkMode: { active: false, source: null, type: null, color: null },
        drag: { active: false, node: null, startX: 0, startY: 0, startTime: 0, maxMove: 0 },
        keyState: {}, hudVisible: true
    },
    
    init() {
        const C = App.Renderer.canvas;
        C.addEventListener('mousedown', this.onMouseDown.bind(this));
        C.addEventListener('mouseup', this.onMouseUp.bind(this));
        C.addEventListener('mousemove', this.onMouseMove.bind(this));
        C.addEventListener('wheel', this.onWheel.bind(this), {passive:false});
        C.addEventListener('contextmenu', this.onContextMenu.bind(this));
        window.addEventListener('keydown', this.onKeyDown.bind(this));
        window.addEventListener('keyup', (e) => {
            this.state.keyState[e.key] = false;
            if(e.key==='Shift') this.state.keyState['Shift'] = false;
        });
    },

    // --- Core: Safe Navigation ---
    safeNavigate(node) {
        if(!node) return;
        if (this.state.linkMode.active) {
            this.navigateTo(node, true);
            return;
        }
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes,
            links: App.Store.state.links,
            nextFocus: node,
            nextSlots: App.Store.state.slots
        }));
    },

    navigateTo(node, recordHistory = true) {
        if(!node) return;
        const { linkMode } = this.state;
        if (linkMode.active && linkMode.source && linkMode.source.uuid !== node.uuid) {
            this.executeLinkAction(linkMode.source, node);
            this.exitLinkMode();
        }
        if(recordHistory && App.Store.state.focusNode !== node) {
            App.Store.state.navHistory.push(App.Store.state.focusNode);
            if(App.Store.state.navHistory.length > 50) App.Store.state.navHistory.shift();
        }
        App.Store.state.focusNode = node;
        node.alpha = 1; this.state.previewNode = null; this.hideTooltip();
        App.UI.updateSidebar(); App.Store.saveToLocal(); App.Renderer.restartSim();
    },

    executeLinkAction(source, target) {
        const { links } = App.Store.state;
        const existing = links.find(l => 
            (l.source.uuid === source.uuid && l.target.uuid === target.uuid) || 
            (l.source.uuid === target.uuid && l.target.uuid === source.uuid)
        );
        const { type } = this.state.linkMode;

        if (type === 'DELETE') {
            if(existing) {
                App.Store.executeSafeAction(() => ({
                    nodes: App.Store.state.nodes,
                    links: links.filter(l => l!==existing),
                    nextFocus: target, nextSlots: App.Store.state.slots
                }));
            } else App.UI.showFlash("æ— è¿æ¥å¯æ–­å¼€", 'info');
        } else {
            if(existing) { existing.type = type; existing.source = source; existing.target = target; }
            else { links.push({source, target, type, alpha: 0}); }
            App.Renderer.restartSim();
        }
    },

    async enterLinkMode() {
        if(this.state.linkMode.active) return;
        try {
            const res = await App.UI.RelationPicker.show(true);
            const mode = { active: true, source: App.Store.state.focusNode, type: res.val, color: '#fff' };
            if (res.val === 'CUSTOM') {
                const cLabel = prompt("è¾“å…¥å…³ç³»åç§°:");
                if(!cLabel) { this.exitLinkMode(); return; }
                const preset = App.Store.state.presets.find(p=>p.label===cLabel);
                mode.type = preset ? preset.val : cLabel;
            } else if (res.val === 'DELETE') { mode.color = '#ff4d4d'; }
            else { const p = App.Store.state.presets.find(x => x.val === res.val); if(p) mode.color = p.color; }
            this.state.linkMode = mode;
            const ind = document.getElementById('link-mode-indicator');
            ind.style.display = 'inline-block';
            ind.innerHTML = `ğŸ”— <span style="color:${mode.color}">è¿çº¿æ¨¡å¼: ${mode.type}</span>`;
            ind.classList.add('active');
        } catch(e) { this.exitLinkMode(); }
    },

    exitLinkMode() {
        this.state.linkMode = { active: false, source: null, type: null, color: null };
        document.getElementById('link-mode-indicator').classList.remove('active');
        document.getElementById('link-mode-indicator').style.display = 'none';
    },

    handleSlot(idx) {
        const { slots, focusNode } = App.Store.state;
        if (slots[idx] === focusNode) return;
        if (slots[idx]) {
            // FIXED: Use executeSafeAction to swap
            const perform = () => {
                // In LinkMode we just jump, no swap needed for logic flow
                this.navigateTo(slots[idx], true);
                App.UI.updateSlotUI();
            };
            
            if (this.state.linkMode.active) perform();
            else {
                App.Store.executeSafeAction(() => ({
                    nodes: App.Store.state.nodes,
                    links: App.Store.state.links,
                    nextFocus: slots[idx], // Jump to slot
                    nextSlots: slots.map((s,i) => i===idx ? focusNode : s) // Swap slot with current
                }));
            }
        } else {
            slots[idx] = focusNode; App.UI.updateSlotUI(); App.Store.saveToLocal();
        }
    },

    clearSlot(idx, e) {
        e.preventDefault();
        const { slots, focusNode } = App.Store.state;
        if(!slots[idx]) return;
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes, links: App.Store.state.links, nextFocus: focusNode, 
            nextSlots: slots.map((s,i)=>i===idx?null:s) 
        }));
    },

    // --- Mouse ---
    onMouseDown(e) {
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(e.button===3) { e.preventDefault(); this.navigateBack(); return; }
        if(e.button===4) { e.preventDefault(); this.enterLinkMode(); return; }
        if(e.button!==0) return;
        const node = this.pickNode(e.clientX, e.clientY);
        this.state.drag = { active: true, node, startX: e.clientX, startY: e.clientY, startTime: performance.now(), maxMove: 0 };
        if(node) {
            const w = App.Renderer.screenToWorld(e.clientX, e.clientY);
            App.Renderer.pointerForce.node(node).target(w.x, w.y);
            App.Renderer.simulation.alphaTarget(0.3).restart();
            this.state.hoverNode = null; this.state.previewNode = null; this.hideTooltip();
            App.Renderer.canvas.style.cursor = 'grabbing';
        } else { App.UI.RelationPicker.close(); }
    },

    onMouseMove(e) {
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(this.state.drag.active) {
            const dx = e.clientX - this.state.drag.startX, dy = e.clientY - this.state.drag.startY;
            this.state.drag.maxMove = Math.max(this.state.drag.maxMove, Math.hypot(dx, dy));
            if(this.state.drag.node) {
                const w = App.Renderer.screenToWorld(e.clientX, e.clientY);
                App.Renderer.pointerForce.target(w.x, w.y);
            }
            return;
        }
        const node = this.pickNode(e.clientX, e.clientY);
        if(node) {
            this.state.hoverNode = node; this.state.previewNode = null;
            const html = typeof marked!=='undefined' ? marked.parse(node.summary||'') : node.summary;
            this.showTooltip(`<strong>${node.label}</strong><br>${html}<br><span style='color:#666'>ç‚¹å‡»è·³è½¬</span>`, e.clientX, e.clientY, 'mouse');
        } else {
            this.state.hoverNode = null; if(!this.state.previewNode) this.hideTooltip();
        }
    },

    onMouseUp(e) {
        if(e.button!==0 || !this.state.drag.active) return;
        const { startTime, maxMove, node } = this.state.drag;
        if(node) {
            App.Renderer.pointerForce.node(null).target(null);
            App.Renderer.simulation.alphaTarget(0);
            App.Store.saveToLocal();
            App.Renderer.canvas.style.cursor = 'crosshair';
        }
        if(performance.now() - startTime < 200 && maxMove < 8) {
            const target = node || this.pickNode(e.clientX, e.clientY);
            if(target) {
                if(target !== App.Store.state.focusNode) this.safeNavigate(target);
                else App.UI.Modal.show();
            }
        }
        this.state.drag = { active: false, node: null, startX:0, startY:0, startTime:0, maxMove:0 };
    },

    onContextMenu(e) {
        e.preventDefault();
        const node = this.pickNode(e.clientX, e.clientY);
        if(node) { this.deleteNode(node); return; }
        const link = this.pickLink(e.clientX, e.clientY);
        if(link) { this.deleteLink(link); return; }
    },

    onWheel(e) {
        e.preventDefault();
        App.Renderer.viewK = Math.max(0.1, Math.min(5, App.Renderer.viewK - e.deltaY * 0.001));
    },

    onKeyDown(e) {
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(App.UI.PresetEditor.active) { if(e.key==='Escape') App.UI.PresetEditor.close(); return; }
        if(App.UI.RelationPicker.active) { App.UI.RelationPicker.handleInput(e); return; }
        if(['INPUT','TEXTAREA'].includes(e.target.tagName)) {
            if(e.key==='Escape') { e.target.blur(); App.Renderer.canvas.focus(); }
            if(e.key==='Enter' && e.target.id==='node-label') { e.preventDefault(); e.target.blur(); }
            return;
        }
        this.state.keyState[e.key] = true; if(e.shiftKey) this.state.keyState['Shift']=true;
        const isSlot = (e.key>='1' && e.key<='4');
        if(['!','@','#','$'].includes(e.key)) { this.handleSlotStore({'!':0,'@':1,'#':2,'$':3}[e.key]); return; }
        if(e.shiftKey && isSlot) { this.handleSlotStore(parseInt(e.key)-1); return; }
        if(isSlot) { this.handleSlot(parseInt(e.key)-1); return; }

        switch(e.key) {
            case 'ArrowUp': case '/': if(this.state.previewNode) this.safeNavigate(this.state.previewNode); else this.jumpDirection(-Math.PI/2); break;
            case 'ArrowDown': case '?': this.jumpDirection(Math.PI/2); break;
            case 'ArrowLeft': this.jumpDirection(Math.PI); break;
            case 'ArrowRight': this.jumpDirection(0); break;
            case '.': this.cyclePreview(1); break;
            case ',': this.cyclePreview(-1); break;
            case '=': case '+': App.Store.state.viewLayers = Math.max(1, App.Store.state.viewLayers-1); App.Renderer.adjustZoomByLayer(); document.getElementById('layer-indicator').innerText=App.Store.state.viewLayers; break;
            case '-': case '_': App.Store.state.viewLayers = Math.min(7, App.Store.state.viewLayers+1); App.Renderer.adjustZoomByLayer(); document.getElementById('layer-indicator').innerText=App.Store.state.viewLayers; break;
            case 'Tab': case 'n': case 'N': e.preventDefault(); this.createNode(); break;
            case 'F2': e.preventDefault(); App.UI.els.label.focus(); App.UI.els.label.select(); break;
            case ' ': e.preventDefault(); App.UI.els.summary.focus(); App.UI.els.summary.select(); break;
            case 'Enter': if(App.Store.state.focusNode) App.UI.Modal.show(); break;
            case 'l': case 'L': this.enterLinkMode(); break;
            case 'h': case 'H': const root = App.Store.state.nodes.find(n=>n.isRoot); if(root) this.safeNavigate(root); break;
            case 'Escape': if(this.state.linkMode.active) this.exitLinkMode(); break;
            case 'b': case 'B': this.navigateBack(); break;
            case 'Delete': case 'd': case 'D': this.deleteNode(); break;
            case 'i': case 'I': e.preventDefault(); this.state.hudVisible=!this.state.hudVisible; document.getElementById('key-controls').style.display=this.state.hudVisible?'block':'none'; break;
            case '`': e.preventDefault(); App.UI.PresetEditor.open(); break;
            case '<': App.Renderer.targetRotation += 0.05; break;
            case '>': App.Renderer.targetRotation -= 0.05; break;
        }
        if (this.state.keyState['<']) App.Renderer.targetRotation += 0.05;
        if (this.state.keyState['>']) App.Renderer.targetRotation -= 0.05;
    },

    createNode() {
        const { focusNode, nodes, links, slots } = App.Store.state;
        const newNode = { uuid: uuid.v4(), label: "æ–°æ¦‚å¿µ", x: focusNode.x + 150, y: focusNode.y + 50, summary: "", content: "", color: App.Utils.getRandomColor(), alpha: 0 };
        if (this.state.linkMode.active) {
            nodes.push(newNode); App.Renderer.restartSim();
            this.executeLinkAction(this.state.linkMode.source, newNode);
            this.exitLinkMode();
            this.navigateTo(newNode, false);
            setTimeout(() => { App.UI.els.label.focus(); App.UI.els.label.select(); }, 50);
        } else {
            App.Store.executeSafeAction(() => ({ nodes: [...nodes, newNode], links, nextFocus: newNode, nextSlots: slots }));
            setTimeout(() => { App.UI.els.label.focus(); App.UI.els.label.select(); }, 100);
        }
    },

    deleteNode(target = null) {
        const node = target || App.Store.state.focusNode;
        if(node.isRoot) { App.UI.showFlash("åˆå§‹å¥‡ç‚¹ä¸å¯åˆ é™¤", 'warn'); return; }
        let nextFocus = App.Store.state.focusNode;
        if(node === nextFocus) {
            nextFocus = App.Store.state.navHistory.length > 0 ? App.Store.state.navHistory[App.Store.state.navHistory.length-1] : App.Store.state.nodes.find(n=>n.isRoot);
            if (nextFocus === node) nextFocus = App.Store.state.nodes.find(n=>n.isRoot);
        }
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes.filter(n => n.uuid !== node.uuid),
            links: App.Store.state.links.filter(l => l.source.uuid !== node.uuid && l.target.uuid !== node.uuid),
            nextFocus: nextFocus,
            nextSlots: App.Store.state.slots.map(s => (s && s.uuid === node.uuid) ? null : s)
        }));
    },

    deleteLink(link) {
        App.Store.executeSafeAction(() => ({ nodes: App.Store.state.nodes, links: App.Store.state.links.filter(l => l !== link), nextFocus: App.Store.state.focusNode, nextSlots: App.Store.state.slots }));
    },

    navigateBack() {
        const h = App.Store.state.navHistory;
        if(h.length) {
            let t = null;
            for(let i=h.length-1; i>=0; i--) {
                if(App.Store.state.nodes.find(n=>n.uuid===h[i].uuid) && h[i].uuid !== App.Store.state.focusNode.uuid) { t=h[i]; break; }
            }
            if(t) this.safeNavigate(t, true);
        }
    },

    handleSlotStore(idx) {
        const { slots, focusNode } = App.Store.state;
        App.Store.executeSafeAction(() => ({ 
            nodes: App.Store.state.nodes, links: App.Store.state.links, nextFocus: focusNode, 
            nextSlots: slots.map((s,i)=>i===idx?focusNode:s) 
        }));
    },

    // ... Radar & Helpers remain similar ...
    getNeighbors() {
        const { links, focusNode } = App.Store.state;
        const list = [];
        links.forEach(l => {
            let other = null;
            if(l.source.uuid===focusNode.uuid) other = l.target;
            else if(l.target.uuid===focusNode.uuid) other = l.source;
            if(other) {
                const dx = other.x - focusNode.x, dy = other.y - focusNode.y;
                const rawAng = Math.atan2(dy, dx);
                let vAng = rawAng + App.Renderer.viewRotation;
                while(vAng > Math.PI) vAng -= 2*Math.PI; while(vAng <= -Math.PI) vAng += 2*Math.PI;
                list.push({ node: other, vAngle: vAng, rawAngle: rawAng });
            }
        });
        return list.sort((a,b) => a.vAngle - b.vAngle);
    },

    cyclePreview(dir) {
        const neighbors = this.getNeighbors();
        if(!neighbors.length) return;
        this.hideTooltip();
        const UP = -Math.PI/2;
        const THRESHOLD = 0.087;
        const exact = neighbors.find(n => Math.abs(n.vAngle - UP) < THRESHOLD);
        const currentIsExact = exact && this.state.previewNode && this.state.previewNode.uuid === exact.node.uuid;
        if (exact && !currentIsExact) { this.setPreview(exact); return; }
        let target = null;
        if (dir > 0) {
            target = neighbors.find(n => n.vAngle > UP && (!exact || n.node.uuid !== exact.node.uuid));
            if (!target) target = neighbors.find(n => (!exact || n.node.uuid !== exact.node.uuid));
        } else {
            for(let i=neighbors.length-1; i>=0; i--) if(neighbors[i].vAngle < UP && (!exact || neighbors[i].node.uuid !== exact.node.uuid)) { target=neighbors[i]; break; }
            if(!target) for(let i=neighbors.length-1; i>=0; i--) if(!exact || neighbors[i].node.uuid !== exact.node.uuid) { target=neighbors[i]; break; }
        }
        if(target) this.setPreview(target);
    },

    setPreview(targetWrapper) {
        this.state.previewNode = targetWrapper.node;
        App.Renderer.setTargetRotation(-Math.PI/2 - targetWrapper.rawAngle);
        const html = typeof marked!=='undefined' ? marked.parse(this.state.previewNode.summary||'') : '';
        this.showTooltip(`<strong>é¢„è§ˆ: ${this.state.previewNode.label}</strong><br>${html}<br><span style='color:#af4cae'>æŒ‰ <span class="key">â†‘</span> <span class="key">/</span> è·³è½¬</span>`, 0, 0, 'fixed');
    },

    jumpDirection(targetAng) {
        const neighbors = this.getNeighbors();
        let best = null, minDiff = 1.2;
        neighbors.forEach(n => {
            let diff = Math.abs(n.vAngle - targetAng); if (diff > Math.PI) diff = 2*Math.PI - diff;
            if (diff < minDiff) { minDiff = diff; best = n.node; }
        });
        if(best) this.safeNavigate(best);
    },

    pickNode(sx, sy) {
        const w = App.Renderer.screenToWorld(sx, sy);
        const nodes = App.Store.state.nodes;
        for(let i=nodes.length-1; i>=0; i--) {
            const n = nodes[i];
            if(n.alpha <= 0.5) continue;
            const dx = n.x - w.x, dy = n.y - w.y;
            if(dx*dx + dy*dy < 600) return n;
        }
        return null;
    },

    pickLink(sx, sy) {
        const w = App.Renderer.screenToWorld(sx, sy);
        const links = App.Store.state.links;
        for(let l of links) {
            if(l.alpha < 0.3) continue;
            const x1 = l.source.x, y1 = l.source.y, x2 = l.target.x, y2 = l.target.y;
            const A = x2-x1, B = y2-y1, lenSq = A*A+B*B;
            let t = ((w.x-x1)*A + (w.y-y1)*B) / lenSq;
            t = Math.max(0, Math.min(1, t));
            if(Math.hypot(w.x-(x1+t*A), w.y-(y1+t*B)) < 10/App.Renderer.viewK) return l;
        }
        return null;
    },

    showTooltip(html, x, y, mode) {
        const t = document.getElementById('tooltip');
        t.innerHTML = html; t.style.opacity = 1;
        if(mode==='mouse') { t.className=''; t.style.left=(x+15)+'px'; t.style.top=(y+15)+'px'; t.style.transform='none'; }
        else { t.className='fixed-mode'; }
    },
    hideTooltip() {
        const t = document.getElementById('tooltip');
        t.style.opacity=0; t.className=''; t.style.left=''; t.style.top=''; t.style.transform='';
    }
};

window.onload = () => {
    App.Renderer.init();
    App.UI.init();
    App.Store.init();
    App.Input.init();
};

</script>
</body>
</html>
