<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ˜Ÿç½— (Stars v5.0 Refactored)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/16.3.0/lib/marked.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/atom-one-dark.min.css">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050508; font-family: 'Segoe UI', sans-serif; color: #ddd; }
        #canvas { display: block; width: calc(100vw - var(--sidebar-width, 340px)); height: 100vh; cursor: crosshair; outline: none; }
        #sidebar { position: fixed; right: 0; top: 0; width: var(--sidebar-width, 340px); height: 100vh; background: #111114; border-left: 1px solid #2a2a30; padding: 25px; box-sizing: border-box; display: flex; flex-direction: column; z-index: 10; box-shadow: -5px 0 20px rgba(0,0,0,0.8); }
        #sidebar-resizer { position: fixed; right: var(--sidebar-width, 340px); top: 0; width: 8px; height: 100vh; background: #050508; cursor: ew-resize; z-index: 11; transition: background 0.2s; }
        #sidebar-resizer:hover { background: #4facfe; }
        input, textarea { background: transparent; border: none; color: #eee; outline: none; width: 100%; display: block; font-family: 'Segoe UI', sans-serif; }
        input::placeholder, textarea::placeholder { color: #444; font-style: italic; }
        #node-label { font-size: 28px; font-weight: 700; margin-bottom: 8px; color: #4facfe; border-bottom: 2px solid #2a2a30; padding-bottom: 8px; }
        #node-label:focus { border-bottom-color: #4facfe; }
        #node-uuid { font-size: 10px; color: #444; font-family: monospace; margin-bottom: 5px; user-select: all;}
        #link-status { font-size: 12px; font-family: monospace; margin-bottom: 15px; color: #666; font-weight: bold; display: flex; justify-content: space-between;}
        #node-summary { font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; background: #0d0d0f; border: 1px solid transparent; border-radius: 4px; padding: 5px; height: 60px; resize: vertical; }
        #node-summary:focus { border-color: #333; background: #151518; }
        #node-content { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 15px; resize: none; font-family: 'Consolas', 'Courier New', monospace; line-height: 1.7; border-radius: 6px; font-size: 13px; color: #ccc; }
        #node-content:focus { border-color: #4facfe; }
        #node-color-container { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        #node-color-input { width: 30px; height: 30px; background: transparent; border: none; cursor: pointer; padding: 0; }
        #node-color-hex { flex-grow: 1; background: #0a0a0c; border: 1px solid #222; padding: 8px 10px; border-radius: 6px; font-size: 13px; color: #ccc; text-transform: uppercase; }
        #hud { position: fixed; top: 20px; left: 25px; pointer-events: none; z-index: 5; opacity: 0.9; display: flex; flex-direction: column; gap: 20px;}
        h1 { margin: 0; font-size: 18px; color: #555; letter-spacing: 2px; text-transform: uppercase; }
        .controls { font-size: 12px; color: #444; line-height: 1.6; font-family: monospace; }
        .key { color: #4facfe; font-weight: bold; background: rgba(79, 172, 254, 0.1); padding: 2px 4px; border-radius: 3px;}
        #slot-bar { display: flex; gap: 15px; pointer-events: auto; margin-top: 5px;}
        .slot { display: flex; flex-direction: column; align-items: center; gap: 5px; cursor: pointer; opacity: 0.6; transition: 0.3s; width: 60px; }
        .slot:hover { opacity: 1; transform: scale(1.1); }
        .slot.active { opacity: 1; }
        .slot-circle { width: 24px; height: 24px; border-radius: 50%; background: #333; border: 2px solid transparent; box-shadow: 0 0 5px rgba(0,0,0,0.5); transition: 0.3s; position: relative; }
        .slot-num { position: absolute; top: -5px; left: -5px; font-size: 10px; font-weight: bold; color: #666; background: #050508; padding: 1px 3px; border-radius: 4px; }
        .slot.active .slot-num { color: #4facfe; }
        .slot-name { font-size: 11px; color: #888; text-align: center; max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .slot.active .slot-name { color: #ddd; font-weight: bold; }
        #view-controls { font-family: monospace; color: #666; font-size: 12px; }
        #layer-indicator { color: #4facfe; font-weight: bold; }
        #link-mode-indicator { display: none; font-size: 14px; font-weight: bold; color: #fff; background: rgba(0,0,0,0.6); padding: 5px 10px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2); margin-top: 5px; }
        #link-mode-indicator.active { display: inline-block; animation: pulse-text 2s infinite; }
        @keyframes pulse-text { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
        .overlay-menu { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateX(-170px); background: #1a1a1d; border: 1px solid #444; padding: 15px; border-radius: 8px; display: none; flex-direction: column; gap: 6px; z-index: 50; box-shadow: 0 10px 30px rgba(0,0,0,1); min-width: 260px; }
        .overlay-menu.active { display: flex; }
        .menu-title { font-size: 12px; color: #888; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 5px;}
        .menu-opt { font-size: 13px; color: #ccc; padding: 8px 10px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; transition: background 0.2s;}
        .menu-opt:hover, .menu-opt.selected { background: #333; color: #fff; }
        .menu-key { color: #4facfe; font-weight: bold; font-family: monospace; margin-right: 12px; min-width: 20px;}
        .menu-opt.delete-opt { color: #e74c3c; }
        #tooltip { position: absolute; opacity: 0; background: rgba(0, 0, 0, 0.9); padding: 10px 14px; border-radius: 4px; border-left: 3px solid #4facfe; pointer-events: none; color: #ddd; font-size: 12px; transition: opacity 0.15s; z-index: 100; max-width: 280px; box-shadow: 0 4px 15px rgba(0,0,0,0.6);}
        #tooltip.fixed-mode { top: 70%; left: 50%; transform: translate(-50%, 0) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); text-align: center; border-left: none; border-top: 3px solid #4facfe; }
        #flash-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) translateX(calc(-1 * var(--sidebar-width, 340px) / 2)); padding: 15px 30px; border-radius: 8px; font-weight: bold; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.3s; z-index: 404; box-shadow: 0 0 30px rgba(0,0,0,0.5); text-transform: uppercase; letter-spacing: 1px; }
        #flash-message.info { background: rgba(0, 123, 255, 0.15); color: #4facfe; border: 1px solid #4facfe; }
        #flash-message.warn { background: rgba(255, 0, 0, 0.15); color: #ff4d4d; border: 1px solid #ff4d4d; }
        #content-modal { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.85); z-index: 300; justify-content: center; align-items: center; }
        #content-modal.active { display: flex; }
        #modal-body { background: #161619; width: 800px; max-width: 90%; height: 85%; border: 1px solid #333; border-radius: 8px; padding: 40px; box-sizing: border-box; overflow-y: auto; color: #ccc; box-shadow: 0 0 50px rgba(0,0,0,1); }
        #modal-body h1, #modal-body h2, #modal-body h3 { color: #fff; border-bottom: 1px solid #333; padding-bottom: 5px; margin-top: 20px;}
        #modal-body a { color: #4facfe; text-decoration: none; }
        #io-controls { position: fixed; bottom: 20px; left: 25px; z-index: 5; display: flex; gap: 10px; }
        button { background: #1a1a1d; color: #777; border: 1px solid #333; padding: 6px 12px; cursor: pointer; font-size: 11px; border-radius: 3px; transition: 0.2s; }
        button:hover { background: #333; color: #fff; border-color: #555; }
        #preset-editor { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #161619; border: 1px solid #333; border-radius: 8px; padding: 20px; width: 500px; max-width: 90%; z-index: 400; display: none; flex-direction: column; gap: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); }
        #preset-editor.active { display: flex; }
        .preset-list { max-height: 400px; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .preset-row { display: flex; gap: 10px; align-items: center; background: #0a0a0c; padding: 5px; border-radius: 4px; border: 1px solid #222; }
        .preset-row:hover { border-color: #444; }
        .preset-input { background: transparent; border: none; color: #ddd; font-family: monospace; font-size: 12px; padding: 4px; border-bottom: 1px solid transparent; }
        .preset-input:focus { border-bottom-color: #4facfe; }
        .preset-color { width: 25px; height: 25px; border: none; background: none; cursor: pointer; padding: 0; }
        .preset-idx { color: #4facfe; font-weight: bold; font-family: monospace; width: 20px; text-align: center; user-select: none; }
        .preset-del { color: #e74c3c; cursor: pointer; font-weight: bold; padding: 0 5px; user-select: none; }
        .preset-del:hover { color: #ff6b6b; }
        .preset-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px; }
        .btn-primary { background: #2980b9; color: white; border-color: #3498db; }
        .btn-primary:hover { background: #3498db; }
        #modal-body code { background: #282c34; padding: 3px 6px; border-radius: 4px; font-family: 'Fira Code', 'JetBrains Mono', 'Consolas', monospace; color: #abb2bf; font-size: 0.95em; }
        #modal-body pre { background: #282c34; padding: 15px; border-radius: 6px; overflow-x: auto; margin-top: 1em; margin-bottom: 1em; }
        #modal-body pre code { background: none; padding: 0; font-size: 1em; color: #abb2bf; line-height: 1.5; }
        #custom-dialog-overlay {
            display: none;
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.7); z-index: 500;
            align-items: center; justify-content: center;
        }
        #custom-dialog-overlay.active { display: flex; }

        #custom-dialog {
            background: #1a1a1d; border: 1px solid #444; border-radius: 8px;
            padding: 20px; width: 320px; box-shadow: 0 10px 40px rgba(0,0,0,0.9);
            display: flex; flex-direction: column; gap: 15px;
        }
        #custom-dialog-msg { font-size: 14px; color: #ddd; line-height: 1.5; text-align: center; }
        #custom-dialog-input {
            background: #0a0a0c; border: 1px solid #333; padding: 8px;
            border-radius: 4px; width: 100%; box-sizing: border-box;
            color: #fff; display: none; /* é»˜è®¤éšè— */
        }
        #custom-dialog-input:focus { border-color: #4facfe; }
        #custom-dialog-buttons { display: flex; justify-content: center; gap: 10px; } /* æŒ‰é’®å±…ä¸­ */
    </style>
</head>
<body>

<div id="hud">
    <h1 id="app-title">æ˜Ÿç½— <span style="font-size:10px; opacity:0.5">v5.0</span></h1>
    <div id="slot-bar">
        <div class="slot" id="slot-1" data-index="0"><div class="slot-circle"><span class="slot-num">1</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-2" data-index="1"><div class="slot-circle"><span class="slot-num">2</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-3" data-index="2"><div class="slot-circle"><span class="slot-num">3</span></div><span class="slot-name">-</span></div>
        <div class="slot" id="slot-4" data-index="3"><div class="slot-circle"><span class="slot-num">4</span></div><span class="slot-name">-</span></div>
    </div>

    <div id="view-controls">
        <span id="txt-view-range">è§†é‡èŒƒå›´:</span> <span id="layer-indicator">1</span> <span id="txt-layers">å±‚</span>
        <span id="txt-adjust">(æŒ‰ +/- è°ƒæ•´)</span><br>
        <span id="txt-visible">å½“å‰å¯è§:</span> <span id="visible-count">0</span> <span id="txt-nodes">èŠ‚ç‚¹</span>
    </div>

    <div id="link-mode-indicator">...</div> <!-- å†…å®¹ä¼šåœ¨JSé‡Œåˆå§‹åŒ– -->

    <!-- æŒ‰é”®å¸®åŠ©ï¼šå†…å®¹ä¼šè¢« JS çš„ apply() è¦†ç›–ï¼Œè¿™é‡Œå¯ä»¥ç•™ç©º -->
    <div id="key-controls" class="controls"></div>
</div>

<div id="flash-message"></div>
<div id="relation-picker" class="overlay-menu"></div>

<div id="preset-editor">
    <div class="menu-title">
        <span id="pe-title">é¢„è®¾å…³ç³»ç¼–è¾‘å™¨</span>
        <span style="float:right; cursor:pointer" onclick="App.UI.PresetEditor.close()">âœ•</span>
    </div>
    <div class="controls" id="pe-desc" style="margin-bottom:10px; color:#666;">...</div>
    <div class="preset-list" id="preset-list-container"></div>
    <div class="preset-actions">
        <button id="pe-btn-add" onclick="App.UI.PresetEditor.add()">+ æ–°å¢</button>
        <button id="pe-btn-save" class="btn-primary" onclick="App.UI.PresetEditor.saveAndClose()">ä¿å­˜</button>
    </div>
</div>

<div id="content-modal"><div id="modal-body"></div></div>

<div id="io-controls">
    <button id="btn-save" onclick="App.Store.save()">ä¿å­˜</button>
    <button id="btn-export" onclick="App.Store.exportData()">å¯¼å‡º</button>
    <button id="btn-reset" onclick="App.Store.resetSystem()">é‡ç½®</button>
    <input type="file" id="importFile" style="display:none" onchange="App.Store.importData(this)">
    <button id="btn-import" onclick="document.getElementById('importFile').click()">å¯¼å…¥</button>
    <button id="btn-lang" onclick="App.I18n.toggle()">ğŸŒ English</button>
    <button id="btn-preset" onclick="App.UI.PresetEditor.open()">é¢„è®¾</button>
</div>

<div id="sidebar">
    <input type="text" id="node-label" placeholder="æ¦‚å¿µåç§°">
    <div id="node-uuid">UUID: -</div>
    <div id="link-status">è¿æ¥æ•°: -</div>
    <textarea id="node-summary" placeholder="ç®€çŸ­æ‘˜è¦ (Markdown/HTML)..."></textarea>
    <div id="node-color-container">
        <input type="color" id="node-color-input">
        <input type="text" id="node-color-hex" placeholder="#FFFFFF">
    </div>
    <textarea id="node-content" placeholder="è¯¦ç»†ç¬”è®° (Markdownæ”¯æŒ)..."></textarea>
</div>
<div id="sidebar-resizer"></div>
<div id="tooltip"></div>
<canvas id="canvas"></canvas>

<div id="custom-dialog-overlay">
<div id="custom-dialog">
    <div id="custom-dialog-msg"></div>
    <input type="text" id="custom-dialog-input" placeholder="">
    <div id="custom-dialog-buttons">
        <button id="btn-cancel">å–æ¶ˆ</button>
        <button id="btn-confirm" class="btn-primary">ç¡®å®š</button>
    </div>
</div>
</div>

<script>
/**
 * Stars v5.0 Refactored
 * Single File Modular Architecture
 */
const App = {};

// ==========================================
// 0. I18n (å›½é™…åŒ–)
// ==========================================
App.I18n = {
    lang: 'en', // é»˜è®¤
    data: {
        "en": {
            "hud.title": "Stars <span style='font-size:10px; opacity:0.5'>v5.0</span>", // ç‰¹æ®Šå¤„ç†å¸¦HTMLçš„æ ‡é¢˜
            "hud.viewLayers": "View Range:",
            "hud.layers": "Layers",
            "hud.adjust": "(+/- to adjust)",
            "hud.visible": "Visible:",
            "hud.nodes": "nodes",
            "hud.linkMode": "ğŸ”— Link Mode: Jump to connect / Esc to cancel",
            "hud.controls": `
                <span class="key">L</span> <span class="key">Front Key</span> New Link <span class="key">N</span> New Node <span class="key">Tab</span> New Linked Node<br>
                <span class="key">Del</span> <span class="key">D</span> <span class="key">Right Click</span> Delete Link/Node<br>
                <span class="key">â†‘â†“â†â†’ /?</span> <span class="key">L-Click</span> Move <br>
                <span class="key">F2</span> Rename <span class="key">Space</span> Edit <span class="key">Enter</span> <span class="key">Focus</span> View<br>
                <span class="key">(Shift)1-4</span> Swap(Store) <span class="key">H</span> Home <span class="key">B</span> <span class="key">Back Key</span> Back<br>
                <span class="key">, .</span> Preview Neighbors <span class="key">< ></span> Rotate<br>
                <span class="key">\`</span> Presets <span class="key">I</span> Hide Help
            `,
            "btn.save": "Save",
            "btn.export": "Export",
            "btn.reset": "Reset System",
            "btn.import": "Import",
            "btn.language": "ğŸŒ English",
            "btn.presets": "Manage Presets",
            "sidebar.placeholder.label": "Concept Name",
            "sidebar.placeholder.summary": "Short summary (Markdown/HTML)...",
            "sidebar.placeholder.content": "Detailed notes (Markdown supported)...",
            "modal.noContent": "*No content available*",
            "modal.close": "Press ESC to close",
            "alert.resetConfirm": "Resetting the system will clear all data. Are you sure?",
            "alert.deleteConfirm": "Warning: This action will cause {n} nodes to be lost (e.g., {label}...). Continue?",
            "alert.importSuccess": "Data imported successfully",
            "alert.importFail": "Invalid import file format",
            "alert.parseFail": "Failed to parse imported file.",
            "alert.presetValueEmpty": "Preset 'Value' cannot be empty.",
            "alert.presetValueDuplicate": "Preset 'Value' cannot be duplicated.",
            "alert.presetExceedMax": "Maximum number of presets reached.",
            "alert.noLinkToBreak": "No link to break.",
            "alert.rootCannotDelete": "The root node cannot be deleted.",
            "flash.presetUpdated": "Presets updated.",
            "flash.linkCut": "Link cut.",
            "flash.noHistory": "No more history to navigate back to.",
            "linkMode.prompt": "Enter link relationship name or val:",
            "linkMode.promptPlaceholder": "e.g., contains, defined as...",
            "linkMode.typeIndicator": "ğŸ”— <span style='color:{color};'>Link Mode: {type} (Jump to connect / Esc to cancel)</span>",
            "linkMode.deleteLabel": "Delete/Break Link",
            "preset.title": "1. Select Type <span style='font-weight:normal; color:#888;'>(Space Custom{deleteFragment})</span>",
            "preset.menuTitle": "Preset Relationship Editor",
            "preset.menuDesc": "Define common connection types. Press Enter to save.",
            "preset.btnAdd": "+ Add Preset",
            "preset.btnSave": "Save & Apply",
            "preset.input.label": "Display Name (Label)",
            "preset.input.value": "Data Value (Value)",
            "preset.delete": ", D Delete",
            "preset.more": "More",
            "preset.default.includes": "Includes...",
            "preset.default.definedAs": "Defined as...",
            "preset.default.intuitive": "Intuitive understanding",
            "preset.default.calculates": "Calculates...",
            "preset.default.implies": "Implies...",
            "preset.default.orthogonalTo": "Orthogonal to...",
            "fallback.origin": "Origin",
            "fallback.summary": "Workspace Root",
            "fallback.content": "Welcome to Stars in VSCode. Start exploring!",
            "fallback.newNode": "New Concept",
            "fallback.newRelationship": "New Relationship",
            "dialog.confirm": "Confirm",
            "dialog.cancel": "Cancel",
            "tooltip.preview": "<strong>Preview: {label}</strong><br>{summary}<br><span style='color:#af4cae'>Press <span class=\"key\">â†‘</span> <span class=\"key\">/</span> to Jump</span>",
            "tooltip.click": "<span style='color:#666'>Click to Jump</span>",
            "tooltip.nodeHover": "<strong>{label}</strong><br>{summary}<br><span style='color:#666'>Click to Jump</span>",
            "status.saved": "Stars: Saved.",
            "status.noWorkspace": "Stars: Please open a folder to save data."
        },
        "zh-cn": {
            "hud.title": "æ˜Ÿç½— <span style='font-size:10px; opacity:0.5'>v5.0</span>",
            "hud.viewLayers": "è§†é‡èŒƒå›´:",
            "hud.layers": "å±‚",
            "hud.adjust": "(æŒ‰ +/- è°ƒæ•´)",
            "hud.visible": "å½“å‰å¯è§:",
            "hud.nodes": "èŠ‚ç‚¹",
            "hud.linkMode": "ğŸ”— è¿çº¿æ¨¡å¼: è·³è½¬ä»¥è¿æ¥/Esc å–æ¶ˆ",
            "hud.controls": `
                <span class="key">L</span> <span class="key">å‰ä¾§é”®</span> æ–°å»ºå…³ç³» <span class="key">N</span> æ–°å»ºèŠ‚ç‚¹ <span class="key">Tab</span> æ–°å»ºå¹¶è¿æ¥èŠ‚ç‚¹<br>
                <span class="key">Del</span> <span class="key">D</span> <span class="key">å³é”®</span> åˆ é™¤å…³ç³»/èŠ‚ç‚¹<br>
                <span class="key">â†‘â†“â†â†’ /?</span> <span class="key">å·¦é”®</span> ç§»åŠ¨ <br>
                <span class="key">F2</span> æ”¹å <span class="key">Space</span> ç¼–è¾‘ <span class="key">Enter</span> <span class="key">å·¦é”®ç„¦ç‚¹</span> æŸ¥çœ‹<br>
                <span class="key">(Shift)1-4</span> (å­˜å…¥)äº¤æ¢ <span class="key">H</span> å›å®¶ <span class="key">B</span> <span class="key">åä¾§é”®</span> åé€€<br>
                <span class="key">, .</span> é¢„è§ˆé‚»å±… <span class="key">< ></span> è‡ªç”±æ—‹è½¬<br>
                <span class="key">\`</span> å…³ç³»é¢„è®¾ <span class="key">I</span> éšè—æ­¤æç¤º
            `,
            "btn.save": "ä¿å­˜",
            "btn.export": "å¯¼å‡º",
            "btn.reset": "é‡ç½®ç³»ç»Ÿ",
            "btn.import": "å¯¼å…¥",
            "btn.language": "ğŸŒ ä¸­æ–‡",
            "btn.presets": "é¢„è®¾ç®¡ç†",
            "sidebar.placeholder.label": "æ¦‚å¿µåç§°",
            "sidebar.placeholder.summary": "ç®€çŸ­æ‘˜è¦ (Markdown/HTML)...",
            "sidebar.placeholder.content": "è¯¦ç»†ç¬”è®° (Markdownæ”¯æŒ)...",
            "modal.noContent": "*æš‚æ— æ­£æ–‡å†…å®¹*",
            "modal.close": "æŒ‰ ESC å…³é—­",
            "alert.resetConfirm": "é‡ç½®ç³»ç»Ÿå°†æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼Œç¡®å®šå—ï¼Ÿ",
            "alert.deleteConfirm": "è­¦å‘Šï¼šæ­¤æ“ä½œå°†å¯¼è‡´ {n} ä¸ªèŠ‚ç‚¹ä¸¢å¤±ï¼ˆå¦‚ {label}...ï¼‰ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ",
            "alert.importSuccess": "æ•°æ®å¯¼å…¥æˆåŠŸ",
            "alert.importFail": "å¯¼å…¥æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®",
            "alert.parseFail": "è§£æå¯¼å…¥æ–‡ä»¶å¤±è´¥ã€‚",
            "alert.presetValueEmpty": "é¢„è®¾çš„â€œæ•°æ®å€¼â€ä¸èƒ½ä¸ºç©ºã€‚",
            "alert.presetValueDuplicate": "é¢„è®¾çš„â€œæ•°æ®å€¼â€ä¸èƒ½é‡å¤ã€‚",
            "alert.presetExceedMax": "é¢„è®¾æ•°é‡å·²è¾¾ä¸Šé™ã€‚",
            "alert.noLinkToBreak": "æ— è¿æ¥å¯æ–­å¼€ã€‚",
            "alert.rootCannotDelete": "åˆå§‹å¥‡ç‚¹ä¸å¯åˆ é™¤ã€‚",
            "flash.presetUpdated": "é¢„è®¾å·²æ›´æ–°ã€‚",
            "flash.linkCut": "é“¾æ¥å·²åˆ‡æ–­ã€‚",
            "flash.noHistory": "æ²¡æœ‰æ›´å¤šå†å²è®°å½•å¯å›é€€ã€‚",
            "linkMode.prompt": "è¯·è¾“å…¥é“¾æ¥å…³ç³»åç§°æˆ–æ•°æ®å€¼:",
            "linkMode.promptPlaceholder": "ä¾‹å¦‚: åŒ…å«, å®šä¹‰ä¸º...",
            "linkMode.typeIndicator": "ğŸ”— <span style='color:{color};'>è¿çº¿æ¨¡å¼: {type} (è·³è½¬ä»¥è¿æ¥/Esc å–æ¶ˆ)</span>",
            "linkMode.deleteLabel": "åˆ é™¤/æ–­å¼€è¿æ¥",
            "preset.title": "1. é€‰æ‹©ç±»å‹ <span style='font-weight:normal; color:#888;'>(Space è‡ªå®šä¹‰{deleteFragment})</span>",
            "preset.menuTitle": "é¢„è®¾å…³ç³»ç¼–è¾‘å™¨",
            "preset.menuDesc": "å®šä¹‰å¸¸ç”¨çš„è¿æ¥ç±»å‹ã€‚æŒ‰ Enter ä¿å­˜ã€‚",
            "preset.btnAdd": "+ æ–°å¢é¢„è®¾",
            "preset.btnSave": "ä¿å­˜å¹¶åº”ç”¨",
            "preset.input.label": "æ˜¾ç¤ºåç§° (Label)",
            "preset.input.value": "æ•°æ®å€¼ (Value)",
            "preset.delete": ", D åˆ é™¤",
            "preset.more": "æ›´å¤š",
            "preset.default.includes": "åŒ…å«...",
            "preset.default.definedAs": "å®šä¹‰ä¸º...",
            "preset.default.intuitive": "ç›´è§‚ç†è§£",
            "preset.default.calculates": "è®¡ç®—...",
            "preset.default.implies": "æ„å‘³ç€...",
            "preset.default.orthogonalTo": "ä¸...æ­£äº¤",
            "fallback.origin": "èµ·æº",
            "fallback.summary": "å·¥ä½œåŒºæ ¹èŠ‚ç‚¹",
            "fallback.content": "æ¬¢è¿ä½¿ç”¨ VSCode ä¸­çš„æ˜Ÿç½—ç³»ç»Ÿã€‚",
            "fallback.newNode": "æ–°æ¦‚å¿µ",
            "fallback.newRelationship": "æ–°å…³ç³»",
            "dialog.confirm": "ç¡®å®š",
            "dialog.cancel": "å–æ¶ˆ",
            "tooltip.preview": "<strong>é¢„è§ˆ: {label}</strong><br>{summary}<br><span style='color:#af4cae'>æŒ‰ <span class=\"key\">â†‘</span> <span class=\"key\">/</span> è·³è½¬</span>",
            "tooltip.click": "<span style='color:#666'>ç‚¹å‡»è·³è½¬</span>",
            "tooltip.nodeHover": "<strong>{label}</strong><br>{summary}<br><span style='color:#666'>ç‚¹å‡»è·³è½¬</span>",
            "status.saved": "æ˜Ÿç½—: å·²ä¿å­˜ã€‚",
            "status.noWorkspace": "æ˜Ÿç½—: è¯·å…ˆæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶å¤¹ä»¥ä¿å­˜æ•°æ®ã€‚"
        }
    },
    init() {
        const savedLang = localStorage.getItem('stars_lang');

        if (savedLang) {
            this.lang = savedLang;
        } else {
            // 2. å¦‚æœæ²¡æœ‰å­˜æ¡£ï¼Œå†æ£€æµ‹æµè§ˆå™¨
            const navLang = (navigator.language || navigator.userLanguage).toLowerCase();
            if (navLang.startsWith('zh')) this.lang = 'zh-cn';
            else this.lang = 'en';
        }

        console.log("Stars I18n Initialized:", this.lang);
        this.apply();
    },
    toggle() {
        // åˆ‡æ¢çŠ¶æ€
        this.lang = (this.lang === 'zh-cn') ? 'en' : 'zh-cn';

        // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
        localStorage.setItem('stars_lang', this.lang);

        // åº”ç”¨æ›´æ”¹
        this.apply();

        // å¯é€‰ï¼šå¼¹å‡ºæç¤º
        App.UI.showFlash((this.lang === 'zh-cn' ? "è¯­è¨€: ä¸­æ–‡" : "Language: English"));
    },
    t(key, params = {}) {
        const dict = this.data[this.lang] || this.data['en'];
        let str = dict[key] || key;
        Object.keys(params).forEach(k => {
            str = str.replace(new RegExp(`{${k}}`, 'g'), params[k]);
        });
        return str;
    },
    apply() {
        const setText = (id, key) => { const el = document.getElementById(id); if(el) el.innerHTML = this.t(key); };
        const setPh = (id, key) => { const el = document.getElementById(id); if(el) el.placeholder = this.t(key); };
        // æ›¿æ¢ HTML ä¸­çš„é™æ€æ–‡æœ¬
        setText('app-title', 'hud.title');
        setText('txt-view-range', 'hud.viewLayers');
        setText('txt-layers', 'hud.layers');
        setText('txt-adjust', 'hud.adjust');
        setText('txt-visible', 'hud.visible');
        setText('txt-nodes', 'hud.nodes');
        setText('key-controls', 'hud.controls');

        setText('btn-save', 'btn.save');
        setText('btn-export', 'btn.export');
        setText('btn-reset', 'btn.reset');
        setText('btn-import', 'btn.import');
        setText('btn-lang', 'btn.language');
        setText('btn-preset', 'btn.presets');

        setPh('node-label', 'sidebar.placeholder.label');
        setPh('node-summary', 'sidebar.placeholder.summary');
        setPh('node-content', 'sidebar.placeholder.content');

        // é¢„è®¾ç¼–è¾‘å™¨
        setText('pe-title', 'preset.menuTitle');
        setText('pe-desc', 'preset.menuDesc');
        setText('pe-btn-add', 'preset.btnAdd');
        setText('pe-btn-save', 'preset.btnSave');

        App.Input.updateLinkModeIndicator(); // åˆ·æ–°è¿çº¿æ¨¡å¼æç¤º
    }
};
// å¿«æ·æ–¹å¼ï¼Œæ–¹ä¾¿è°ƒç”¨
const t = (k, p) => App.I18n.t(k, p);

// ==========================================
// 1. Utils (å·¥å…·å‡½æ•°)
// ==========================================
App.Utils = {
    debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    },
    getRandomColor() {
        const h = Math.random(); const s = Math.random(); const v = 1; let r, g, b;
        const i = Math.floor(h * 6); const f = h * 6 - i; const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break;
            case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break;
        }
        const toHex = (c) => Math.round(c * 255).toString(16).padStart(2, '0'); return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    },
    findReachable(allNodes, allLinks, startNodes) {
        const reachable = new Set();
        const queue = [];
        startNodes.forEach(s => {
            if (s && !reachable.has(s.uuid)) {
                const exists = allNodes.find(n => n.uuid === s.uuid);
                if(exists) { reachable.add(s.uuid); queue.push(exists); }
            }
        });
        const adj = {};
        allLinks.forEach(l => {
            const s = l.source.uuid || l.source;
            const t = l.target.uuid || l.target;
            if(!adj[s]) adj[s] = []; adj[s].push(t);
            if(!adj[t]) adj[t] = []; adj[t].push(s);
        });
        let head = 0;
        while(head < queue.length) {
            const curr = queue[head++];
            const neighbors = adj[curr.uuid] || [];
            neighbors.forEach(nid => {
                if (!reachable.has(nid)) {
                    reachable.add(nid);
                    const nodeObj = allNodes.find(n => n.uuid === nid);
                    if(nodeObj) queue.push(nodeObj);
                }
            });
        }
        return reachable;
    }
};

// ==========================================
// 2. Store (æ•°æ®æ ¸å¿ƒ & å®‰å…¨é€»è¾‘)
// ==========================================
App.Store = {
    state: {
        nodes: [],
        links: [],
        slots: [null, null, null, null],
        focusNode: null,
        viewLayers: 1,
        navHistory: [],
        presets: []
    },

    get DEFAULT_PRESETS () {
        return [
            { label: t('preset.default.includes'), val: 'comp', color: '#0062ff' },
            { label: t('preset.default.definedAs'), val: 'def', color: '#00ff00' },
            { label: t('preset.default.intuitive'), val: 'ins', color: '#33ffff' },
            { label: t('preset.default.calculates'), val: 'calc', color: '#ffaa00' },
            { label: t('preset.default.implies'), val: 'impl', color: '#bd00ff' },
            { label: t('preset.default.orthogonalTo'), val: 'orth', color: '#ff0055' },
        ];
    },

    pushHistory(node) {
        if(node) {
            this.state.navHistory.push(node);
            if(this.state.navHistory.length > 50) {
                this.state.navHistory.shift();
            }
        }
    },

    getBackNodeIndex() {
        let {focusNode, navHistory, nodes} = this.state;
        // ç­–ç•¥ï¼šå€’åºéå†å†å²ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªâ€œæ—¢ä¸æ˜¯å½“å‰çš„èŠ‚ç‚¹ï¼ŒåˆçœŸå®å­˜åœ¨äº nodes åˆ—è¡¨â€çš„èŠ‚ç‚¹
        for (let i = navHistory.length - 1; i >= 0; i--) {
            const hNode = navHistory[i];
            // æ’é™¤æ‰è‡ªå·±
            if (hNode.uuid === focusNode.uuid) continue;
            // ç¡®ä¿è¿™ä¸ªå†å²èŠ‚ç‚¹è¿˜â€œæ´»ç€â€
            if (nodes.find(n => n.uuid === hNode.uuid)) return i;
        }
        return -1;
    },

    loadState(payload, shouldSave = false) {
        // 1. æ¸…ç†æ—§çŠ¶æ€
        App.Runtime.clearAllStorage();
        this.state.navHistory = [];
        // 2. å¤„ç†ç©ºæ•°æ®æƒ…å†µ (å›é€€åˆ°åˆ›å»ºæ ¹èŠ‚ç‚¹)
        if (!payload || !payload.data || !payload.data.nodes) {
            this.createRoot();
            if (shouldSave) this.save();
            return;
        }
        // 3. è§£æåŸºç¡€æ•°æ®
        // å…¼å®¹ä¸¤ç§ presets å†™æ³•
        this.state.presets = (payload.presets && Array.isArray(payload.presets))
            ? payload.presets
            : this.DEFAULT_PRESETS;
        this.state.viewLayers = payload.viewLayers || 1;
        // 4. é‡å»ºå¯¹è±¡å¼•ç”¨ (æ ¸å¿ƒé€»è¾‘)
        // æ— è®ºæ•°æ®æºæ˜¯å¯¹è±¡è¿˜æ˜¯å­—ç¬¦ä¸²ï¼Œè¿™é‡Œéƒ½ç»Ÿä¸€å¤„ç†
        // ä½¿ç”¨ Map ç¡®ä¿ O(1) æŸ¥æ‰¾
        const nodeMap = new Map(payload.data.nodes.map(n => [n.uuid, { ...n }])); // æµ…æ‹·è´é˜²æ­¢æ±¡æŸ“æºæ•°æ®
        // åˆå§‹åŒ–èŠ‚ç‚¹ç‰©ç†çŠ¶æ€
        nodeMap.forEach(n => {
            if (n.x == null || isNaN(n.x)) n.x = (Math.random() - 0.5) * 50;
            if (n.y == null || isNaN(n.y)) n.y = (Math.random() - 0.5) * 50;
            n.alpha = 0; n.vx = 0; n.vy = 0; n.fx = null; n.fy = null;
            if (n.isRoot) { n.fx = 0; n.fy = 0; }
        });
        this.state.nodes = Array.from(nodeMap.values());
        // æ¢å¤è¿çº¿å¼•ç”¨
        this.state.links = (payload.data.links || []).map(l => ({
            source: nodeMap.get(typeof l.source === 'object' ? l.source.uuid : l.source) || l.source,
            target: nodeMap.get(typeof l.target === 'object' ? l.target.uuid : l.target) || l.target,
            type: l.type,
            alpha: 0
        })).filter(l => l.source && l.target && typeof l.source !== 'string' && typeof l.target !== 'string');
        // æ¢å¤æ’æ§½å¼•ç”¨
        this.state.slots = (payload.slots || [null, null, null, null])
            .map(uuid => uuid ? nodeMap.get(uuid) : null);
        // 5. è®¾ç½®ç„¦ç‚¹èŠ‚ç‚¹ (Focus Node)
        this.state.focusNode = payload.focusNodeUuid
            ? nodeMap.get(payload.focusNodeUuid)
            : (this.state.nodes.find(n => n.isRoot) || this.state.nodes[0]);
        // å…œåº•ï¼šå¦‚æœæ²¡æœ‰ç„¦ç‚¹èŠ‚ç‚¹ï¼Œåˆ›å»ºä¸€ä¸ª
        if (!this.state.focusNode) {
            this.createRoot();
        } else {
            this.state.focusNode.alpha = 1;
        }
        // 6. è®¡ç®—åˆå§‹å¯è§æ€§ (BFS)
        // è¿™ä¸€æ­¥æ˜¯ä¸ºäº†è®©é¦–å±æ¸²æŸ“ä¸è‡³äºå…¨é»‘ï¼Œä¸”ä¸éœ€è¦ç­‰ç‰©ç†æ¨¡æ‹Ÿè·‘å¤ªä¹…
        if (this.state.focusNode) {
            const initVis = new Set([this.state.focusNode.uuid]);
            const q = [{n: this.state.focusNode, d: 0}];
            let h = 0;

            // å»ºç«‹ä¸´æ—¶é‚»æ¥è¡¨åŠ é€ŸæŸ¥æ‰¾
            const adj = {};
            this.state.links.forEach(l => {
                const s = l.source.uuid, t = l.target.uuid;
                if(!adj[s]) adj[s] = []; adj[s].push(t);
                if(!adj[t]) adj[t] = []; adj[t].push(s);
            });
            while(h < q.length) {
                const {n, d} = q[h++];
                if(d >= this.state.viewLayers) continue;
                (adj[n.uuid] || []).forEach(neighborUuid => {
                    if (!initVis.has(neighborUuid)) {
                        initVis.add(neighborUuid);
                        const neighborNode = nodeMap.get(neighborUuid);
                        if (neighborNode) {
                            neighborNode.alpha = 1;
                            q.push({n: neighborNode, d: d+1});
                        }
                    }
                });
            }
        }
        // 7. é‡ç½®è§†å›¾ä½ç½® (Camera)
        if (App.Renderer.width > 0 && this.state.focusNode) {
            App.Renderer.viewX = -this.state.focusNode.x * App.Renderer.viewK + App.Renderer.width/2;
            App.Renderer.viewY = -this.state.focusNode.y * App.Renderer.viewK + App.Renderer.height/2;
        }
        // 8. åˆ·æ–° UI å’Œ æ¨¡æ‹Ÿå™¨
        App.UI.updateSidebar();
        App.UI.updateSlotUI();
        App.Renderer.adjustZoomByLayer(); // ç¡®ä¿ç¼©æ”¾çº§åˆ«æ­£ç¡®
        App.Renderer.restartSim();

        // é¢„çƒ­æ¨¡æ‹Ÿ (è®©èŠ‚ç‚¹ç¨å¾®æ•£å¼€ä¸€ç‚¹)
        for(let i=0; i<30; i++) App.Renderer.simulation.tick();
        this.save();
    },

    // åˆå§‹åŒ–ç³»ç»Ÿ
    init() {
        const saved = localStorage.getItem('stars_v5');
        if (saved) {
            try {
                const raw = JSON.parse(saved);
                this.loadState(raw, true); // æŠ½è±¡å‡ºåŠ è½½é€»è¾‘
            } catch(e) { console.error("Load error:", e); this.createRoot(); }
        } else { this.createRoot(); }

        if(!this.state.focusNode){ this.createRoot(); this.state.focusNode = this.state.nodes[0]; }
        this.state.focusNode.alpha = 1;

        App.UI.updateSidebar();
        App.UI.updateSlotUI();
        App.Renderer.adjustZoomByLayer();
        App.Renderer.restartSim();
    },

    createRoot() {
        const rootUUID = uuid.v4();
        const root = {
            uuid: rootUUID,
            label: t('fallback.origin'),
            isRoot: true,
            x: 0, y: 0,
            fx: 0, fy: 0,
            summary: t('fallback.summary'),
            content: t('fallback.content'),
            color: "#ffffff",
            alpha: 1
        };
        this.state.nodes = [root];
        this.state.links = [];
        this.state.slots = [null, null, null, null];
        this.state.focusNode = root;
        this.state.viewLayers = 1;
        this.state.navHistory = []; // æ–°å»ºæ ¹èŠ‚ç‚¹æ—¶æ¸…ç©ºå†å²è®°å½•
        this.state.presets = this.DEFAULT_PRESETS; // æ–°å»ºæ ¹èŠ‚ç‚¹æ—¶é‡ç½®é¢„è®¾
    },

    // æ ¸å¿ƒå®‰å…¨æ‰§è¡Œå™¨ (Anchor-based Safety Check)
    async executeSafeAction(simulator, onApplied = null) {
        const { nodes, focusNode, slots } = this.state;

        // 1. è·å–å½“å‰é”šç‚¹é›†åˆ (Origin + Focus + Slots)
        const getAnchorUUIDs = (nList, fNode, sList) => {
            const root = nList.find(n => n.isRoot);
            return new Set([root, fNode, ...sList].filter(n => n).map(n => n.uuid));
        };
        const currentAnchorUUIDs = getAnchorUUIDs(nodes, focusNode, slots);

        // 2. æ¨¡æ‹Ÿæœªæ¥çŠ¶æ€
        const nextState = simulator();
        const nextAnchorUUIDs = getAnchorUUIDs(nextState.nodes, nextState.nextFocus, nextState.nextSlots);

        // 3. å¿«é€Ÿæ”¾è¡Œåˆ¤å®š
        // å¦‚æœç»“æ„æœªå—æŸ(æœªåˆ èŠ‚ç‚¹/è¿çº¿) ä¸” é”šç‚¹é›†åˆå†…å®¹ä¸€è‡´(åªæ˜¯ä½ç½®äº’æ¢)
        const isStructureIntact = nextState.nodes.length >= nodes.length && nextState.links.length >= this.state.links.length;
        const isAnchorsSame = currentAnchorUUIDs.size === nextAnchorUUIDs.size && [...currentAnchorUUIDs].every(id => nextAnchorUUIDs.has(id));

        const applyState = () => {
            this.state.nodes = nextState.nodes;
            this.state.links = nextState.links;
            this.state.focusNode = nextState.nextFocus;
            this.state.slots = nextState.nextSlots;
            if (typeof onApplied === 'function') {
                onApplied();
            }
            App.UI.updateSidebar();
            App.UI.updateSlotUI();
            this.save();
            App.Renderer.restartSim();
        };

        if (isStructureIntact && isAnchorsSame) {
            applyState();
            return true;
        }

        // 4. è¿é€šæ€§æ£€æŸ¥ (Reachability)
        const anchorsObjects = nextState.nodes.filter(n => nextAnchorUUIDs.has(n.uuid));
        const reachableUUIDs = App.Utils.findReachable(nextState.nodes, nextState.links, anchorsObjects);
        const lostNodes = nextState.nodes.filter(n => !reachableUUIDs.has(n.uuid));

        if (lostNodes.length > 0) {
            const names = lostNodes.slice(0, 3).map(n => n.label).join(', ');
            const msg = t('alert.deleteConfirm', {n: lostNodes.length, label: lostNodes[0].label});
            if (await App.UI.Dialog.confirm(msg)) {
                // Apply the simulated state first
                applyState();

                // Then clean up lost nodes
                const deadSet = new Set(lostNodes.map(n => n.uuid));
                this.state.nodes = this.state.nodes.filter(n => !deadSet.has(n.uuid));
                this.state.links = this.state.links.filter(l => !deadSet.has(l.source.uuid) && !deadSet.has(l.target.uuid));
                this.state.slots = this.state.slots.map(s => (s && deadSet.has(s.uuid)) ? null : s);
                this.state.navHistory = this.state.navHistory.filter(n => !deadSet.has(n.uuid));
                lostNodes.forEach(n => App.Runtime.clearStorage(n.uuid));

                this.save();
                App.Renderer.restartSim();
                return true;
            }
            return false;
        } else {
            applyState();
            return true;
        }
    },

    save() {
        const payload = {
            data: {
                nodes: this.state.nodes.map(n => ({
                    uuid: n.uuid, label: n.label, isRoot: n.isRoot, x: n.x, y: n.y,
                    summary: n.summary, content: n.content, color: n.color
                })),
                links: this.state.links.map(l => ({
                    source: l.source.uuid,
                    target: l.target.uuid,
                    type: l.type
                }))
            },
            focusNodeUuid: this.state.focusNode ? this.state.focusNode.uuid : null,
            slots: this.state.slots.map(s => s ? s.uuid : null),
            viewLayers: this.state.viewLayers,
            presets: this.state.presets
        };
        localStorage.setItem('stars_v5', JSON.stringify(payload));
        return payload;
    },

    saveDebounced: null,

    exportData() {
        const data = this.save();

        const b = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(b);
        a.download = 'stars_v5.json';
        a.click();
    },

    importData(inp) {
        const f = inp.files[0];
        if(f) {
            const r = new FileReader();
            r.onload = e => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (importedData && importedData.data) {
                        this.loadState(importedData, true);
                        App.UI.showFlash(t('alert.importSuccess'), 'info');
                    } else { App.UI.showFlash(t('alert.importFail'), 'warn'); }
                } catch (error) {
                    console.error(t('alert.parseFail'), error);
                    App.UI.showFlash(t('alert.parseFail'), 'warn');
                };
            };
            r.readAsText(f);
            inp.value = '';
        }
    },

    async resetSystem() {
        if(await App.UI.Dialog.confirm(t('alert.resetConfirm'))) {
            App.Runtime.clearAllStorage();
            localStorage.removeItem('stars_v5');
            location.reload();
        }
    }
};
App.Store.saveDebounced = App.Utils.debounce(App.Store.save, 1000);

// ==========================================
// 3. Runtime (èŠ‚ç‚¹è„šæœ¬æ²™ç®±) - Unified Version
// ==========================================
App.Runtime = {
    activeInstances: {}, // { uuid: { unmountFn: ... } }
    mount(node, containerId) {
        // 1. æ¸…ç†æ—§å®ä¾‹
        this.unmount(node.uuid);
        const container = document.getElementById(containerId);
        if (!container) return;
        // 2. æå–å¹¶ç§»é™¤ script æ ‡ç­¾
        const scriptsToExecute = [];
        // ä½¿ç”¨ Array.from è½¬æ¢ NodeList ä»¥ä¾¿å®‰å…¨éå†
        Array.from(container.querySelectorAll('script')).forEach(script => {
            scriptsToExecute.push(script.textContent);
            script.remove();
        });
        let unmountCallbacks = [];
        // 3. åˆ›å»º API æ²™ç®±ç¯å¢ƒ
        const api = {
            // DOM æ“ä½œä»…é™äºå®¹å™¨å†…éƒ¨
            $: (sel) => container.querySelector(sel),
            $$: (sel) => container.querySelectorAll(sel),

            // æ•°æ®å­˜å‚¨
            storage: this._createStorageApi(node.uuid),

            // èŠ‚ç‚¹å…ƒæ•°æ®
            node: { uuid: node.uuid, label: node.label, color: node.color },

            // ç”Ÿå‘½å‘¨æœŸ
            onMount: (cb) => {
                try { cb(); } catch(e) { console.error(`[Node ${node.uuid}] onMount error:`, e); }
            },
            onUnmount: (cb) => { unmountCallbacks.push(cb); },
            // å…¨å±€å¯¹è±¡è®¿é—® (ä¿ç•™ VSCode ç‰ˆçš„èƒ½åŠ›ï¼Œå¦‚æœè¿½æ±‚ç»å¯¹å®‰å…¨å¯ç§»é™¤)
            window: window,
            document: document,

            // è¾…åŠ©å·¥å…·
            container: container
        };
        // 4. æ³¨å†Œé”€æ¯å‡½æ•°
        this.activeInstances[node.uuid] = {
            unmountFn: () => {
                unmountCallbacks.forEach(cb => {
                    try { cb(); } catch(e) { console.error(`[Node ${node.uuid}] onUnmount error:`, e); }
                });
                unmountCallbacks = [];
            }
        };
        // 5. æ‰§è¡Œè„šæœ¬
        scriptsToExecute.forEach((code) => {
            try {
                // ä½¿ç”¨ "use strict" æ¨¡å¼ (æ¥è‡ª VSCode ç‰ˆä¼˜åŒ–)
                new Function('api', `(function(Runtime){ "use strict"; ${code} })(arguments[0])`)(api);
            } catch (e) {
                console.error(`Script error in node ${node.uuid}:`, e);
                this._renderError(container, e.message);
            }
        });
    },
    unmount(uuid) {
        if (this.activeInstances[uuid]) {
            try {
                this.activeInstances[uuid].unmountFn();
            } catch (e) {
                console.warn(`Error unmounting node ${uuid}:`, e);
            }
            delete this.activeInstances[uuid];
        }
    },
    _renderError(container, message) {
        const errDiv = document.createElement('div');
        Object.assign(errDiv.style, {
            color: '#ff4d4f',
            fontSize: '12px',
            marginTop: '8px',
            padding: '4px',
            background: 'rgba(255,0,0,0.05)',
            borderLeft: '2px solid #ff4d4f'
        });
        errDiv.innerText = `Script Error: ${message}`;
        container.appendChild(errDiv);
    },
    _createStorageApi(uuid) {
        const prefix = `node_storage_${uuid}_`;
        // ä¿ç•™ Web ç‰ˆçš„ try-catchï¼Œé˜²æ­¢éšç§æ¨¡å¼æˆ–é…é¢å·²æ»¡å¯¼è‡´å´©æºƒ
        return {
            set: (k, v) => {
                try { localStorage.setItem(prefix + k, JSON.stringify(v)); return true; }
                catch(e) { console.warn('Storage set failed:', e); return false; }
            },
            get: (k, def) => {
                try { const i = localStorage.getItem(prefix + k); return i ? JSON.parse(i) : def; }
                catch(e) { return def; }
            },
            remove: (k) => localStorage.removeItem(prefix + k),
            clear: () => this.clearStorage(uuid)
        };
    },
    clearStorage(uuid) {
        const prefix = `node_storage_${uuid}_`;
        this._clearStorageByPrefix(prefix);
    },
    clearAllStorage() {
        this._clearStorageByPrefix("node_storage_");
    },
    // ç»Ÿä¸€çš„æ¸…ç†é€»è¾‘ (ç»“åˆ VSCode çš„ç®€æ´å’Œ Web çš„å€’åºéå†æ€æƒ³é¿å…ç´¢å¼•å¡Œé™·)
    _clearStorageByPrefix(prefix) {
        Object.keys(localStorage)
            .filter(k => k.startsWith(prefix))
            .forEach(k => localStorage.removeItem(k));
    }
};

// ==========================================
// 4. UI (ç•Œé¢ç®¡ç†)
// ==========================================
App.UI = {
    els: {
        label: document.getElementById('node-label'),
        uuid: document.getElementById('node-uuid'),
        linkStatus: document.getElementById('link-status'),
        summary: document.getElementById('node-summary'),
        content: document.getElementById('node-content'),
        colorInput: document.getElementById('node-color-input'),
        colorHex: document.getElementById('node-color-hex')
    },

    init() {
        this.initBindings();
        this.Dialog.init();
    },

    initBindings() {
        // Sidebar Bindings with Tab Cycling
        this.els.label.addEventListener('input', () => this.onNodeEdit('label', this.els.label.value));
        this.els.label.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-summary', 'node-content'));

        this.els.summary.addEventListener('input', () => this.onNodeEdit('summary', this.els.summary.value));
        this.els.summary.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-content', 'node-label'));

        this.els.content.addEventListener('input', () => this.onNodeEdit('content', this.els.content.value));
        this.els.content.addEventListener('keydown', (e) => this.handleEditorTab(e, 'node-label', 'node-summary'));

        this.els.colorInput.addEventListener('input', () => {
            this.els.colorHex.value = this.els.colorInput.value;
            this.onNodeEdit('color', this.els.colorInput.value);
            this.updateSlotUI();
        });

        this.els.colorHex.addEventListener('input', () => {
            if(/^#[0-9A-F]{6}$/i.test(this.els.colorHex.value)) {
                this.els.colorInput.value = this.els.colorHex.value;
                this.onNodeEdit('color', this.els.colorHex.value);
                this.updateSlotUI();
            }
        });

        // dialog Background Click to Close
        const dialog = document.getElementById('custom-dialog-overlay');
        dialog.addEventListener('mousedown', (e) => {
            if (e.target === dialog) App.UI.Dialog.close();
        });

        // Modal Background Click to Close
        const modal = document.getElementById('content-modal');
        modal.addEventListener('mousedown', (e) => {
            if (e.target === modal) App.UI.Modal.close();
        });

        // Slot Click Listeners (Dynamic)
        for(let i=0; i<4; i++) {
            const slotEl = document.getElementById(`slot-${i+1}`);
            if(slotEl) {
                slotEl.addEventListener('click', (e) => {
                    // Shift detection fix
                    App.Input.handleSlotClick(i, e.shiftKey);
                });
                slotEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    App.Input.clearSlot(i);
                });
            }
        }

        // Sidebar Resizer
        let isResizing = false;
        const resizer = document.getElementById('sidebar-resizer');
        resizer.addEventListener('mousedown', (e) => { isResizing = true; e.preventDefault(); App.Renderer.canvas.style.pointerEvents = 'none'; document.body.style.cursor = 'ew-resize'; });
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = Math.max(250, Math.min(window.innerWidth - e.clientX, window.innerWidth * 0.6));
            document.documentElement.style.setProperty('--sidebar-width', `${newWidth}px`);
            App.Renderer.resize();
        });
        document.addEventListener('mouseup', () => { if(isResizing) { isResizing = false; App.Renderer.canvas.style.pointerEvents = 'auto'; document.body.style.cursor = 'default'; } });
        window.addEventListener('resize', () => App.Renderer.resize());
    },

    onNodeEdit(field, value) {
        if(App.Store.state.focusNode) {
            App.Store.state.focusNode[field] = value;
            App.Store.saveDebounced();
        }
    },

    handleEditorTab(e, nextId, prevId) {
        if (e.key === 'Tab') {
            e.preventDefault();
            const targetId = e.shiftKey ? prevId : nextId;
            const el = document.getElementById(targetId);
            el.focus(); if(el.tagName!=='DIV') el.select();
        }
    },

    updateSidebar() {
        const node = App.Store.state.focusNode;
        if(!node) return;
        this.els.label.value = node.label;
        this.els.uuid.innerText = "UUID: " + node.uuid;
        this.els.summary.value = node.summary || "";
        this.els.content.value = node.content || "";
        this.els.colorInput.value = node.color || "#4facfe";
        this.els.colorHex.value = node.color || "#4facfe";
        const count = App.Store.state.links.filter(l => l.source.uuid === node.uuid || l.target.uuid === node.uuid).length;
        this.els.linkStatus.innerText = `Links: ${count}`;
    },

    updateSlotUI() {
        const { slots } = App.Store.state;
        for(let i=0; i<4; i++) {
            const el = document.getElementById(`slot-${i+1}`);
            const node = slots[i];
            const circle = el.querySelector('.slot-circle');
            const nameEl = el.querySelector('.slot-name');
            if (node) {
                el.classList.add('active');
                nameEl.innerText = node.label;
                circle.style.background = node.color || "#4facfe";
                circle.style.boxShadow = `0 0 8px ${node.color || "#4facfe"}`;
                circle.style.border = "1px solid rgba(255,255,255,0.3)";
            } else {
                el.classList.remove('active');
                nameEl.innerText = "-";
                circle.style.background = "#222";
                circle.style.boxShadow = "none";
                circle.style.border = "1px solid #333";
            }
        }
    },

    showFlash(msg, type = 'info') {
        const el = document.getElementById('flash-message');
        el.innerText = msg; el.className = type; el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 2000);
    },

    Dialog: {
        overlay: document.getElementById('custom-dialog-overlay'),
        msgEl: document.getElementById('custom-dialog-msg'),
        inputEl: document.getElementById('custom-dialog-input'),
        btnConfirm: document.getElementById('btn-confirm'),
        btnCancel: document.getElementById('btn-cancel'),
        isActive: false,

        // ç”¨äºå­˜å‚¨å½“å‰æ­£åœ¨è¿è¡Œçš„å…³é—­å›è°ƒï¼Œä»¥ä¾¿å¤–éƒ¨å¼ºè¡Œå…³é—­
        _currentCleanup: null,
        init() {},
        /**
         * å¼ºè¡Œå…³é—­å½“å‰å¯¹è¯æ¡†
         * è¿™ç­‰åŒäºç”¨æˆ·ç‚¹å‡»äº†â€œå–æ¶ˆâ€æŒ‰é’®
         */
        close() {
            if (this.isActive && this.btnCancel) {
                // æ¨¡æ‹Ÿç‚¹å‡»å–æ¶ˆæŒ‰é’®ï¼Œè¿™æ ·å¯ä»¥å¤ç”¨å·²æœ‰çš„ Promise resolve(false/null) é€»è¾‘
                // å¹¶ä¸”ä¼šè‡ªåŠ¨è°ƒç”¨ cleanup æ¸…ç†äº‹ä»¶ç›‘å¬
                this.btnCancel.click();
            } else if (this.isActive && this._currentCleanup) {
                // å¦‚æœ DOM è¿˜æ²¡å‡†å¤‡å¥½æˆ–è€…å‘ç”Ÿäº†å…¶ä»–å¼‚å¸¸ï¼Œä½†åœ¨é€»è¾‘ä¸Šæ˜¯ Active
                // æ­¤æ—¶ç›´æ¥è°ƒç”¨æ¸…ç†å‡½æ•°ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
                this._currentCleanup();
            }
        },
        _show(msg, needsInput = false, placeholder = '') {
            return new Promise((resolve) => {
                // å¦‚æœå½“å‰å·²ç»æœ‰ä¸€ä¸ªçª—å£æ‰“å¼€ï¼Œå…ˆå…³æ‰å®ƒï¼Œé˜²æ­¢å†²çª
                if (this.isActive) this.close();
                this.isActive = true;
                this.msgEl.innerText = msg;
                this.inputEl.style.display = needsInput ? 'block' : 'none';
                this.inputEl.value = '';
                this.inputEl.placeholder = placeholder;

                // ä½¿ç”¨ I18n è·å–æŒ‰é’®æ–‡æœ¬ (å‡è®¾ t å‡½æ•°å­˜åœ¨)
                this.btnConfirm.innerText = typeof t !== 'undefined' ? t('dialog.confirm') : 'Confirm';
                this.btnCancel.innerText = typeof t !== 'undefined' ? t('dialog.cancel') : 'Cancel';
                this.overlay.classList.add('active');
                // ç„¦ç‚¹ç®¡ç†
                if (needsInput) setTimeout(() => this.inputEl.focus(), 50);
                else setTimeout(() => this.btnConfirm.focus(), 50);
                // é”®ç›˜è¾…åŠ©å¯¼èˆª
                const handleBtnKey = (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); e.stopPropagation(); this.btnConfirm.click(); }
                    if (e.key === 'Escape') { e.preventDefault(); e.stopPropagation(); this.btnCancel.click(); }
                };
                // æ¸…ç†ä¸å…³é—­é—­åŒ…
                const cleanup = (e) => {
                    if(e) { e.preventDefault(); e.stopPropagation(); }

                    // è§£ç»‘äº‹ä»¶
                    this.btnConfirm.onclick = null;
                    this.btnCancel.onclick = null;
                    this.inputEl.onkeydown = null;
                    this.btnConfirm.removeEventListener('keydown', handleBtnKey);
                    this.btnCancel.removeEventListener('keydown', handleBtnKey);

                    // éšè— UI
                    this.overlay.classList.remove('active');
                    this.isActive = false;
                    this._currentCleanup = null; // æ¸…ç©ºå¼•ç”¨
                    // å½’è¿˜ç„¦ç‚¹
                    if (App && App.Renderer && App.Renderer.canvas) {
                        App.Renderer.canvas.focus();
                    }
                };
                // å°† cleanup æš´éœ²ç»™å®ä¾‹ï¼Œä»¥é˜²ä¸‡ä¸€éœ€è¦å¼ºåˆ¶ç›´æ¥è°ƒç”¨
                this._currentCleanup = () => { cleanup(); resolve(needsInput ? null : false); };
                // äº‹ä»¶ç»‘å®š
                this.btnConfirm.onclick = (e) => {
                    const val = this.inputEl.value;
                    cleanup(e);
                    resolve(needsInput ? val : true);
                };

                this.btnCancel.onclick = (e) => {
                    cleanup(e);
                    resolve(needsInput ? null : false);
                };
                this.inputEl.onkeydown = (e) => {
                    if(e.key === 'Enter') { e.preventDefault(); this.btnConfirm.click(); }
                    if(e.key === 'Escape') { e.preventDefault(); this.btnCancel.click(); }
                };
                // é˜²æ­¢ ESC å…³é—­å¼¹çª—æ—¶è¯¯è§¦å…¶ä»–é€»è¾‘
                this.btnConfirm.addEventListener('keydown', handleBtnKey);
                this.btnCancel.addEventListener('keydown', handleBtnKey);
            });
        },
        confirm(msg) { return this._show(msg, false); },
        prompt(msg, ph = '') { return this._show(msg, true, ph); }
    },

    Modal: {
        el: document.getElementById('content-modal'),
        body: document.getElementById('modal-body'),
        show() {
            const node = App.Store.state.focusNode;
            if (!node) return;
            // Unmount previous if exists (safety)
            if(App.Runtime.activeInstances[node.uuid]) App.Runtime.unmount(node.uuid);

            this.body.innerHTML = ''; // æ¸…ç©º

            const raw = node.content || t('modal.noContent');
            const html = typeof marked !== 'undefined' ? marked.parse(raw) : raw;
            const containerId = `node-content-host-${node.uuid}`;

            this.body.innerHTML = `
                <div style="font-size:2em; font-weight:bold; color:#4facfe; margin-bottom:10px;">${node.label}</div>
                <div style="color:#666; font-style:italic; margin-bottom:20px; border-left:3px solid #555; padding-left:10px;">
                    ${node.summary ? (typeof marked !== 'undefined' ? marked.parse(node.summary) : node.summary) : ''}
                </div>
                <hr style="border:0; border-bottom:1px solid #333; margin-bottom:20px;">
                <div id="${containerId}" class="node-content-host" style="line-height:1.8; font-size:16px;">${html}</div>
                <div id="modal-close-btn" style="margin-top:50px; text-align:center; font-size:12px; color:#444; cursor:pointer;">
                    ${App.Utils.t('modal.close')} (Esc)
                </div>
            `;

            document.getElementById('modal-close-btn').addEventListener('click', () => App.UI.Modal.close());

            if (typeof hljs !== 'undefined') this.body.querySelectorAll('pre code').forEach(b => hljs.highlightElement(b));

            // Mount scripts
            App.Runtime.mount(node, containerId);

            this.el.classList.add('active');

            // Temporary Key Listener for ESC inside modal
            this._escHandler = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault(); e.stopPropagation();
                    this.close();
                }
            };
            window.addEventListener('keydown', this._escHandler);
        },
        close() {
            this.el.classList.remove('active');
            const node = App.Store.state.focusNode;
            if(node) App.Runtime.unmount(node.uuid);
            this.body.innerHTML = '';
            if(this._escHandler) window.removeEventListener('keydown', this._escHandler);
        }
    },

    RelationPicker: {
        el: document.getElementById('relation-picker'),
        active: false, resolve: null, reject: null, allowDelete: false,
        show(allowDelete = false) {
            this.allowDelete = allowDelete;
            return new Promise((res, rej) => {
                const presets = App.Store.state.presets;
                const delFrag = allowDelete ? t('preset.delete') : '';
                let html = `<div class="menu-title">${t('preset.title', {deleteFragment: delFrag})}</div>`;
                html += presets.slice(0, 9).map((p, i) =>
                    `<div class="menu-opt" onclick="App.UI.RelationPicker.pick('${p.val}')"><span class="menu-key" style="color:${p.color}">[${i+1}]</span>${p.label || p.val}</div>`
                ).join('');
                if (presets.length > 9) html += `<div class="menu-title" style="margin-top:10px;">${t('preset.more')}</div>` + presets.slice(9).map(p => `<div class="menu-opt" onclick="App.UI.RelationPicker.pick('${p.val}')"><span class="menu-key" style="visibility:hidden;">[]</span>${p.label}</div>`).join('');
                if (allowDelete) html += `<div class="menu-opt delete-opt" style="margin-top:5px; border-top:1px solid #333" onclick="App.UI.RelationPicker.pick('DELETE')"><span class="menu-key" style="color:#e74c3c">[D]</span><span style="color:#e74c3c">${t('linkMode.deleteLabel')}</span></div>`;

                this.el.innerHTML = html; this.el.classList.add('active'); this.active = true;
                this.resolve = res; this.reject = rej;
            });
        },
        handleInput(e) {
            if(!this.active) return;
            const num = parseInt(e.key);
            const presets = App.Store.state.presets;
            if (!isNaN(num) && num >= 1 && num <= Math.min(9, presets.length)) { e.preventDefault(); this.pick(presets[num-1].val); }
            else if (e.key === ' ') { e.preventDefault(); this.pick('CUSTOM'); }
            else if (e.key === 'Enter' && presets.length>0) { e.preventDefault(); this.pick(presets[0].val); }
            else if (this.allowDelete && ['d','D','Delete'].includes(e.key)) { e.preventDefault(); this.pick('DELETE'); }
            else if (e.key === 'Escape') { e.preventDefault(); this.reject(); this.close(); }
        },
        pick(val) {
            // 1. å…ˆè§£å†³ Promise (æˆåŠŸ)
            if(this.resolve) {
                this.resolve({ val });
                // å…³é”®ï¼šæ¸…ç©ºå›è°ƒï¼Œé˜²æ­¢ close() è¯¯åˆ¤ä¸ºå–æ¶ˆ
                this.resolve = null;
                this.reject = null;
            }
            // 2. å†å…³é—­ UI
            this.close();
        },
        close() {
            this.el.classList.remove('active');
            this.active = false;
            // 3. é˜²å¾¡é€»è¾‘ï¼šå¦‚æœèµ°åˆ°è¿™é‡Œ resolve/reject è¿˜æ²¡è¢«æ¸…ç†ï¼Œè¯´æ˜æ˜¯æ„å¤–å…³é—­ï¼ˆç‚¹ç©ºç™½å¤„/Escï¼‰ï¼Œè§†ä¸ºå–æ¶ˆ
            if(this.reject) {
                this.reject();
                this.resolve = null; this.reject = null;
            }
        }
    },

    PresetEditor: {
        el: document.getElementById('preset-editor'),
        listEl: document.getElementById('preset-list-container'),
        active: false, tempPresets: [],
        open() {
            if(this.active) return;
            this.tempPresets = JSON.parse(JSON.stringify(App.Store.state.presets));
            this.renderList();
            this.el.classList.add('active'); this.active = true;
        },
        renderList() {
            this.listEl.innerHTML = '';
            this.tempPresets.forEach((p, i) => {
                const row = document.createElement('div'); row.className = 'preset-row';
                row.innerHTML = `
                    <span class="preset-idx">${i+1}</span>
                    <input type="color" class="preset-color" value="${p.color}" onchange="App.UI.PresetEditor.update(${i}, 'color', this.value)">
                    <input type="text" class="preset-input" style="width:120px" placeholder="${t('preset.input.label')}" value="${p.label}" oninput="App.UI.PresetEditor.update(${i}, 'label', this.value)">
                    <input type="text" class="preset-input" style="flex:1; color:#aaa;" placeholder="${t('preset.input.value')}" value="${p.val}" oninput="App.UI.PresetEditor.update(${i}, 'val', this.value)">
                    <span class="preset-del" onclick="App.UI.PresetEditor.remove(${i})">âœ•</span>`;
                this.listEl.appendChild(row);
            });
        },
        update(idx, field, val) { this.tempPresets[idx][field] = val; },
        remove(idx) { this.tempPresets.splice(idx, 1); this.renderList(); },
        add() {
            this.tempPresets.push({label:t('fallback.newRelationship'), val:'new', color: App.Utils.getRandomColor()});
            this.renderList();
            setTimeout(() => this.listEl.scrollTop = this.listEl.scrollHeight, 10);
        },
        saveAndClose() {
            // 1. æ£€æŸ¥ç©ºå€¼
            if (this.tempPresets.some(p => !p.val || !p.val.trim())) {
                App.UI.showFlash(t('alert.presetValueEmpty'), 'warn');
                return;
            }
            // 2. æ£€æŸ¥é‡å¤å€¼
            const values = this.tempPresets.map(p => p.val.trim());
            if (new Set(values).size !== values.length) {
                App.UI.showFlash(t('alert.presetValueDuplicate'), 'warn');
                return;
            }

            // æ‰§è¡Œä¿å­˜
            App.Store.state.presets = JSON.parse(JSON.stringify(this.tempPresets));
            App.Store.save();
            App.Renderer.restartSim();
            this.close();
            App.UI.showFlash(t('flash.presetUpdated'));
        },
        close() { this.el.classList.remove('active'); this.active = false; }
    }
};

// ==========================================
// 5. Renderer (æ¸²æŸ“ä¸ç‰©ç†æ¨¡æ‹Ÿ)
// ==========================================
App.Renderer = {
    canvas: document.getElementById('canvas'),
    ctx: document.getElementById('canvas').getContext('2d'),
    width: 0, height: 0,
    viewX: 0, viewY: 0, viewK: 1, viewRotation: 0, targetRotation: 0,
    simulation: null,
    pointerForce: null,
    lastRenderTime: 0,

    // Constants
    FADE_DURATION: 400,
    DEFAULT_NODE_COLOR: "#4facfe",

    init() {
        this.resize();
        this.simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.uuid).distance(220).strength(0.1))
            .force("charge", d3.forceManyBody().strength(-200))
            .force("collide", d3.forceCollide(10))
            .force("x", d3.forceX(0).strength(0.01))
            .force("y", d3.forceY(0).strength(0.01))
            .alphaDecay(0.05).alphaMin(0.05);

        // Custom Pointer Force
        const force = (() => {
            let node, target, strength = 0.02;
            function f(alpha) {
                if (!node || !target) return;
                const dx = target.x - node.x, dy = target.y - node.y;
                const k = strength * (1 - Math.exp(-Math.hypot(dx, dy) / 120));
                node.vx += dx * k; node.vy += dy * k;
            }
            f.initialize = () => {};
            f.node = (n) => { node = n; return f; };
            f.target = (x, y) => { target = {x,y}; return f; };
            return f;
        })();
        this.pointerForce = force;
        this.simulation.force('pointerDrag', this.pointerForce);

        requestAnimationFrame((t) => this.render(t));
    },

    resize() {
        this.width = window.innerWidth - (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width')) || 340);
        this.height = window.innerHeight;
        this.canvas.width = this.width; this.canvas.height = this.height;
    },

    adjustZoomByLayer() {
        // è®©å…¶æ›´å¤§
        this.viewK = Math.max(0.3, Math.min(5, 2.0 / (Math.pow(App.Store.state.viewLayers, 0.7))));
    },

    restartSim() {
        // Find visible nodes for simulation to reduce load
        const SIM_LAYERS = 7;
        const targets = new Set();
        const { nodes, links, focusNode } = App.Store.state;

        const root = nodes.find(n => n.isRoot);
        if (root) {
            root.fx = 0;
            root.fy = 0;
        }

        if (focusNode) {
            targets.add(focusNode.uuid);
            let queue = [{n: focusNode, d: 0}], head = 0;
            const adj = {};
            links.forEach(l => {
                const s = l.source.uuid||l.source, t = l.target.uuid||l.target;
                if(!adj[s]) adj[s]=[]; adj[s].push(t);
                if(!adj[t]) adj[t]=[]; adj[t].push(s);
            });
            while(head < queue.length) {
                const {n, d} = queue[head++];
                if (d >= SIM_LAYERS) continue;
                (adj[n.uuid]||[]).forEach(nid => {
                    if(!targets.has(nid)) {
                        targets.add(nid);
                        const obj = nodes.find(x=>x.uuid===nid);
                        if(obj) queue.push({n:obj, d:d+1});
                    }
                });
            }
        }

        const activeNodes = nodes.filter(n => targets.has(n.uuid));
        const activeLinks = links.filter(l => targets.has(l.source.uuid) && targets.has(l.target.uuid));

        this.simulation.nodes(activeNodes);
        this.simulation.force("link").links(activeLinks);
        this.simulation.alpha(1).restart();
    },

    render(currentTime) {
        const { keyState } = App.Input.state;
        if (keyState['<']) {
            this.targetRotation += 0.05;
            if(App.Input.state.previewNode) { // è¿˜åŸï¼šæ—‹è½¬æ—¶å–æ¶ˆé¢„è§ˆçš„ç»†èŠ‚
                App.Input.state.previewNode = null;
                App.Input.hideTooltip();
            }
        }
        if (keyState['>']) {
            this.targetRotation -= 0.05;
            if(App.Input.state.previewNode) {
                App.Input.state.previewNode = null;
                App.Input.hideTooltip();
            }
        }

        if (!this.lastRenderTime) this.lastRenderTime = currentTime;
        const deltaTime = currentTime - this.lastRenderTime;
        this.lastRenderTime = currentTime;

        // --- æ–°å¢ï¼šå®æ—¶æ›´æ–°æ‹–æ‹½åŠ›ç›®æ ‡ ---
        // è¿™æ˜¯å¿…è¦çš„ã€‚å³ä½¿é¼ æ ‡æ²¡åŠ¨ï¼Œä¸–ç•Œæ¨¡æ‹Ÿä¹Ÿåœ¨ç»§ç»­ï¼Œä¸–ç•Œä»ç„¶ä¼šç›¸å¯¹å±å¹•ç§»åŠ¨ï¼Œå› æ­¤é¼ æ ‡å¯¹åº”çš„ä¸–ç•Œåæ ‡ä¼šå‘ç”Ÿå˜åŒ–
        const { dragNode, mouseX, mouseY } = App.Input.state;
        if (dragNode) {
            const w = this.screenToWorld(mouseX, mouseY);
            this.pointerForce.node(dragNode).target(w.x, w.y);
        }

        const { nodes, links, focusNode, viewLayers } = App.Store.state;
        const { hoverNode, previewNode, linkMode } = App.Input.state;

        // Camera Logic
        const targetX = this.width/2, targetY = this.height/2;
        if(focusNode) {
            this.viewX += ((-focusNode.x * this.viewK + targetX) - this.viewX) * 0.1;
            this.viewY += ((-focusNode.y * this.viewK + targetY) - this.viewY) * 0.1;
        }
        let diff = this.targetRotation - this.viewRotation;
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        this.viewRotation += diff * 0.1;

        // Clear & Transform
        this.ctx.save();
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.translate(this.width/2, this.height/2);
        this.ctx.rotate(this.viewRotation);
        this.ctx.translate(-this.width/2, -this.height/2);
        this.ctx.translate(this.viewX, this.viewY);
        this.ctx.scale(this.viewK, this.viewK);

        // Visibility Logic (BFS)
        const visibleNodes = new Set();
        const visibleLinks = new Set();
        const addVis = (start, depth) => {
            if(!start) return;
            visibleNodes.add(start.uuid);
            let queue = [{n: start, d: 0}], head = 0;
            while(head < queue.length) {
                const {n, d} = queue[head++];
                if (d >= depth) continue;
                links.forEach(l => {
                    const s = l.source, t = l.target;
                    if (s.uuid === n.uuid) {
                        if(!visibleNodes.has(t.uuid)) { visibleNodes.add(t.uuid); queue.push({n:t, d:d+1}); }
                        visibleLinks.add(l);
                    } else if (t.uuid === n.uuid) {
                        if(!visibleNodes.has(s.uuid)) { visibleNodes.add(s.uuid); queue.push({n:s, d:d+1}); }
                        visibleLinks.add(l);
                    }
                });
            }
        };
        if(focusNode) addVis(focusNode, viewLayers);
        if(hoverNode && hoverNode!==focusNode) addVis(hoverNode, 1);
        if(previewNode && previewNode!==focusNode) addVis(previewNode, 1);

        // Draw Links
        links.forEach(l => {
            const isVis = visibleLinks.has(l);
            if(isVis && l.alpha < 1) l.alpha += deltaTime/this.FADE_DURATION;
            else if(!isVis && l.alpha > 0) l.alpha -= deltaTime/this.FADE_DURATION;
            l.alpha = Math.max(0, Math.min(1, l.alpha));

            if(l.alpha > 0.01) {
                const src = l.source, tgt = l.target;
                const isFocusLink = (src===focusNode || tgt===focusNode);
                const isHigh = (hoverNode && (src===hoverNode||tgt===hoverNode)) || (previewNode && (src===previewNode||tgt===previewNode));
                const mult = isFocusLink ? 1.0 : (isHigh ? 0.7 : 0.4);

                this.ctx.globalAlpha = l.alpha * mult;
                this.ctx.lineWidth = (isFocusLink || isHigh) ? 2.5 : 1.5;

                const typeColor = App.Store.state.presets.find(p=>p.val===l.type)?.color || '#666';
                const grad = this.ctx.createLinearGradient(src.x, src.y, tgt.x, tgt.y);
                grad.addColorStop(0, typeColor); grad.addColorStop(0.7, "#444"); grad.addColorStop(1, "#222");

                this.ctx.strokeStyle = grad;
                this.ctx.beginPath(); this.ctx.moveTo(src.x, src.y); this.ctx.lineTo(tgt.x, tgt.y); this.ctx.stroke();

                if (l.type && isFocusLink) {
                     const mx = (src.x+tgt.x)/2, my = (src.y+tgt.y)/2;
                     this.ctx.save(); this.ctx.translate(mx, my); this.ctx.rotate(-this.viewRotation);
                     this.ctx.fillStyle = typeColor; this.ctx.font = "11px Arial"; this.ctx.textAlign="center";
                     const label = App.Store.state.presets.find(p=>p.val===l.type)?.label || l.type;
                     this.ctx.fillText(label, 0, -8); this.ctx.restore();
                }
            }
        });

        // Draw Nodes
        const pulse = (Math.sin(currentTime * 0.002) + 1) * 0.5 * 20 + 10;
        let visibleCount = 0;

        nodes.forEach(n => {
            const isVis = visibleNodes.has(n.uuid);
            if(n === focusNode) n.alpha = 1;
            else {
                if(isVis && n.alpha < 1) n.alpha += deltaTime/this.FADE_DURATION;
                else if(!isVis && n.alpha > 0) n.alpha -= deltaTime/this.FADE_DURATION;
                n.alpha = Math.max(0, Math.min(1, n.alpha));
            }

            if (n.alpha > 0.01) {
                visibleCount++;
                const isFocus = (n === focusNode);
                const isPreview = (n === previewNode || n === hoverNode);
                const isSlot = App.Store.state.slots.includes(n);

                this.ctx.globalAlpha = isFocus ? 1 : n.alpha;
                let r = isFocus ? 20 : (isSlot ? 14 : 10);
                if (this.viewK < 0.5) r = r / this.viewK * 0.5;

                this.ctx.beginPath(); this.ctx.arc(n.x, n.y, r, 0, 2*Math.PI);
                this.ctx.fillStyle = n.color || this.DEFAULT_NODE_COLOR;

                // Shadows & Halo
                if(isFocus) {
                    if (linkMode.active) {
                        this.ctx.shadowBlur = pulse;
                        this.ctx.shadowColor = linkMode.color || '#fff';
                    } else {
                        this.ctx.shadowBlur = 35; this.ctx.shadowColor = this.ctx.fillStyle;
                    }
                } else if(isPreview) {
                    this.ctx.shadowBlur = 20; this.ctx.shadowColor = this.ctx.fillStyle;
                } else {
                    this.ctx.shadowBlur = 0;
                }

                // Stroke
                if (isFocus && linkMode.active) { this.ctx.strokeStyle = linkMode.color || '#fff'; this.ctx.lineWidth = 3; this.ctx.stroke(); }
                if(isSlot && !isFocus) { this.ctx.strokeStyle = "#fff"; this.ctx.lineWidth = 2; this.ctx.stroke(); }

                this.ctx.fill();
                this.ctx.shadowBlur=0;

                // Text
                if (isFocus || isPreview || n.alpha > 0.5) {
                    this.ctx.save(); this.ctx.translate(n.x, n.y); this.ctx.rotate(-this.viewRotation);
                    this.ctx.fillStyle = (isFocus || isPreview) ? "#fff" : "rgba(200,200,200,0.7)";
                    this.ctx.font = (isFocus || isPreview) ? "bold 14px Arial" : "11px Arial";
                    this.ctx.textAlign = "center";
                    this.ctx.fillText(n.label, 0, r + 16);
                    const sIdx = App.Store.state.slots.indexOf(n);
                    if (sIdx >= 0) { this.ctx.fillStyle = "#4facfe"; this.ctx.font = "bold 11px monospace"; this.ctx.fillText(`[${sIdx+1}]`, 0, -r - 6); }
                    this.ctx.restore();
                }
            }
        });

        this.ctx.restore();
        document.getElementById('layer-indicator').innerText=App.Store.state.viewLayers;
        document.getElementById('visible-count').innerText = visibleCount;
        requestAnimationFrame((t) => this.render(t));
        if (this.simulation.alpha() < 0.3) this.simulation.alpha(0.3).restart();
    },

    screenToWorld(sx, sy) {
        let x = sx - this.width/2, y = sy - this.height/2;
        const cos = Math.cos(-this.viewRotation), sin = Math.sin(-this.viewRotation);
        let rx = x * cos - y * sin, ry = x * sin + y * cos;
        return { x: (rx + this.width/2 - this.viewX) / this.viewK, y: (ry + this.height/2 - this.viewY) / this.viewK };
    },

    setTargetRotation(rad) {
        let current = this.targetRotation; let diff = rad - current;
        while (diff > Math.PI) diff -= 2 * Math.PI; while (diff < -Math.PI) diff += 2 * Math.PI;
        this.targetRotation = current + diff;
    }
};

// ==========================================
// 6. Input (äº¤äº’æ§åˆ¶)
// ==========================================
App.Input = {
    state: {
        hoverNode: null,
        previewNode: null,
        linkMode: { active: false, source: null, type: null, color: null },
        dragNode: null,
        click: { startTime: 0, startX: 0, startY: 0 },
        keyState: {},
        keyControlsVisible: true,
        mouseX: 0,
        mouseY: 0,
    },

    init() {
        const C = App.Renderer.canvas;
        C.addEventListener('mousedown', this.onMouseDown.bind(this));
        C.addEventListener('mouseup', this.onMouseUp.bind(this));
        C.addEventListener('mousemove', this.onMouseMove.bind(this));
        C.addEventListener('wheel', this.onWheel.bind(this), {passive:false});
        C.addEventListener('contextmenu', this.onContextMenu.bind(this));
        window.addEventListener('keydown', this.onKeyDown.bind(this));
        window.addEventListener('keyup', (e) => {
            this.state.keyState[e.key] = false;
            if(e.key==='Shift') this.state.keyState['Shift'] = false;
        });
    },

    // --- Action Handlers ---

    safeNavigate(node, recordHistory = true) {
        if (!node) return;
        if (this.state.linkMode.active && this.state.linkMode.type === 'DELETE') {
            const { focusNode, nodes, links } = App.Store.state;
            const linkIndex = links.findIndex(l =>
                (l.source.uuid===focusNode.uuid && l.target.uuid===node.uuid) ||
                (l.source.uuid===node.uuid && l.target.uuid===focusNode.uuid)
            );
            if (linkIndex !== -1) {
                App.Store.executeSafeAction(() => ({
                    nodes: nodes,
                    links: links.filter(l => l !== links[linkIndex]),
                    nextFocus: node,
                    nextSlots: App.Store.state.slots
                }), () => {
                    if (recordHistory) App.Store.pushHistory(focusNode);
                    this.exitLinkMode();
                });
                return;
            } else {
                this.exitLinkMode();
            }
        }
        if (this.state.linkMode.active) {
            this.navigate(node, recordHistory);
            return;
        }
        // Wrap in Safe Action
        const { focusNode } = App.Store.state;
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes,
            links: App.Store.state.links,
            nextFocus: node,
            nextSlots: App.Store.state.slots
        }), () => {
            if (recordHistory) {
                App.Store.pushHistory(focusNode);
            }
        });
        // Note: executeSafeAction will call navigateTo if safe via its applyState
    },

    navigate(node, recordHistory = true) {
        if(!node) return;
        const { linkMode } = this.state;
        // Link Mode Logic
        if (linkMode.active && linkMode.source && linkMode.source.uuid !== node.uuid) {
            this.executeLinkAction(linkMode.source, node);
            this.exitLinkMode();
            // Note: Does NOT return, continues to navigate
        }

        const { focusNode } = App.Store.state;
        if(recordHistory) {
            App.Store.pushHistory(focusNode);
        }

        App.Store.state.focusNode = node;
        node.alpha = 1;
        this.state.previewNode = null;
        this.hideTooltip();

        App.UI.updateSidebar();
        App.Store.save();
        App.Renderer.restartSim();
    },

    executeLinkAction(source, target) {
        const { links } = App.Store.state;
        const existing = links.find(l =>
            (l.source.uuid === source.uuid && l.target.uuid === target.uuid) ||
            (l.source.uuid === target.uuid && l.target.uuid === source.uuid)
        );
        const { type } = this.state.linkMode;

        if (type === 'DELETE') {
            if(existing) {
                App.Store.executeSafeAction(() => ({
                    nodes: App.Store.state.nodes,
                    links: links.filter(l => l!==existing),
                    nextFocus: target,
                    nextSlots: App.Store.state.slots
                }));
            } else App.UI.showFlash(t('alert.noLinkToBreak'), 'info');
        } else {
            if(existing) { existing.type = type; existing.source = source; existing.target = target; }
            else { links.push({source, target, type, alpha: 0}); }
            App.Renderer.restartSim();
        }
    },

    async enterLinkMode() {
        if(this.state.linkMode.active) return;
        try {
            const res = await App.UI.RelationPicker.show(true);
            const mode = { active: true, source: App.Store.state.focusNode, type: res.val, color: '#fff' };

            if (res.val === 'CUSTOM') {
                const cLabel = await App.UI.Dialog.prompt(t('linkMode.prompt'), t('linkMode.promptPlaceholder'));
                if(!cLabel) { this.exitLinkMode(); return; }
                const preset = App.Store.state.presets.find(p=>p.label===cLabel);
                mode.type = preset ? preset.val : cLabel;
            } else if (res.val === 'DELETE') {
                mode.color = '#ff4d4d';
            } else {
                const p = App.Store.state.presets.find(x => x.val === res.val);
                if(p) mode.color = p.color;
            }

            this.state.linkMode = mode;
            this.updateLinkModeIndicator();
        } catch(e) { this.exitLinkMode(); }
    },

    exitLinkMode() {
        this.state.linkMode = { active: false, source: null, type: null, color: null };
        this.updateLinkModeIndicator();
    },

    updateLinkModeIndicator() {
        const el = document.getElementById('link-mode-indicator');
        if (this.state.linkMode.active) {
            el.innerHTML = t('linkMode.typeIndicator', {color: this.state.linkMode.color, type: this.state.linkMode.type});
            el.classList.add('active');
            el.style.display = 'inline-block';
        } else {
            el.innerHTML = t('hud.linkMode');
            el.classList.remove('active');
            el.style.display = 'none';
        }
    },

    handleSlotClick(idx, isShift) {
        if (isShift) this.handleSlotStore(idx);
        else this.handleSlot(idx);
    },

    handleSlot(idx) {
        const { slots, focusNode } = App.Store.state;
        const slotNode = slots[idx];
        if (slotNode === focusNode) return;

        if (slotNode) {
            slots[idx] = focusNode;
            App.UI.updateSlotUI();
            this.navigate(slotNode, true);
        } else {
            // Store logic
            slots[idx] = focusNode;
            App.UI.updateSlotUI();
            App.Store.save();
        }
    },

    clearSlot(idx) {
        const { slots, nodes, links, focusNode } = App.Store.state;
        if(!slots[idx]) return;
        App.Store.executeSafeAction(() => ({
            nodes,
            links,
            nextFocus: focusNode,
            nextSlots: slots.map((s,i)=>i===idx?null:s)
        }));
    },

    handleSlotStore(idx) {
        const { slots, focusNode, nodes, links } = App.Store.state;
        if(slots[idx]===focusNode) return;
        App.Store.executeSafeAction(() => ({
            nodes,
            links,
            nextFocus: focusNode,
            nextSlots: slots.map((s,i)=>i===idx?focusNode:s)
        }));
    },

    // --- Mouse Events ---

    onMouseDown(e) {
        if(App.UI.Dialog.isActive) return;
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(e.button===3) { e.preventDefault(); this.safeNavigateBack(); return; }
        if(e.button===4) { e.preventDefault(); this.enterLinkMode(); return; }
        if(e.button!==0) return;

        const node = this.pickNode(e.clientX, e.clientY);
        this.state.mouseX = e.clientX;
        this.state.mouseY = e.clientY;
        this.state.dragNode = node;
        this.state.click = {
            startX: e.clientX, startY: e.clientY,
            startTime: performance.now(),
        };

        if(node) {
            this.state.hoverNode = null;
            this.state.previewNode = null;
            this.hideTooltip();
            App.Renderer.canvas.style.cursor = 'grabbing';
        } else {
            App.UI.RelationPicker.close();
            App.UI.PresetEditor.close();
        }
    },

    onMouseMove(e) {
        // æ— è®ºä»€ä¹ˆæƒ…å†µï¼Œå…ˆæ›´æ–°å±å¹•åæ ‡
        this.state.mouseX = e.clientX;
        this.state.mouseY = e.clientY;
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(this.state.dragNode) return;
        const node = this.pickNode(e.clientX, e.clientY);
        if(node) {
            this.state.hoverNode = node;
            this.state.previewNode = null;
            const html = typeof marked!=='undefined'
                ? marked.parse(node.summary||'')
                : node.summary;
            this.showTooltip(t('tooltip.nodeHover', {label: node.label, summary: html}), e.clientX, e.clientY, 'mouse');
        } else {
            this.state.hoverNode = null;
            if(!this.state.previewNode) this.hideTooltip();
        }
    },

    onMouseUp(e) {
        if(e.button!==0 || !this.state.dragNode) return;

        // æ¸…ç†ç‰©ç†çŠ¶æ€ (è™½ç„¶ render é‡Œä¸å†æ›´æ–°äº†ï¼Œä½†æ˜¾å¼æ–­å¼€å¼•ç”¨æ˜¯ä¸ªå¥½ä¹ æƒ¯)
        const node = this.state.dragNode;
        if(node) {
            App.Renderer.pointerForce.node(null).target(null);
            App.Store.save();
            App.Renderer.canvas.style.cursor = 'crosshair';
        }
        this.state.dragNode = null; // å…³é”®ï¼šè¿™ä¸€è¡Œä¼šè®© render å¾ªç¯åœæ­¢æ›´æ–°ç‰©ç†åŠ›

        // Click Threshold Logic
        const {startTime, startX, startY} = this.state.click;
        move = Math.hypot(e.clientX - startX, e.clientY - startY);
        if(performance.now() - startTime < 200 && move < 8) {
            const target = node || this.pickNode(e.clientX, e.clientY);
            if(target) {
                if(target !== App.Store.state.focusNode) this.safeNavigate(target);
                else App.UI.Modal.show();
            }
        }
    },

    onContextMenu(e) {
        e.preventDefault();
        const node = this.pickNode(e.clientX, e.clientY);
        if(node) { this.deleteNode(node); return; }
        const link = this.pickLink(e.clientX, e.clientY);
        if(link) { this.deleteLink(link); return; }
    },

    onWheel(e) {
        e.preventDefault();
        App.Renderer.viewK = Math.max(0.1, Math.min(5, App.Renderer.viewK - e.deltaY * 0.001));
    },

    // --- Keyboard Events ---

    onKeyDown(e) {
        if(App.UI.Dialog.isActive) return;
        if(App.UI.Modal.el.classList.contains('active')) return;
        if(App.UI.PresetEditor.active) { if(e.key==='Escape' || e.key==='`') App.UI.PresetEditor.close(); return; }
        if(App.UI.RelationPicker.active) { App.UI.RelationPicker.handleInput(e); return; }

        if(['INPUT','TEXTAREA'].includes(e.target.tagName)) {
            if(e.key==='Escape') { e.target.blur(); }
            if(e.key==='Enter' && e.target.id==='node-label') {
                e.preventDefault();
                e.target.blur();
            }
            return;
        }

        this.state.keyState[e.key] = true; if(e.shiftKey) this.state.keyState['Shift']=true;

        const isSlot = (e.key>='1' && e.key<='4');
        if(['!','@','#','$'].includes(e.key)) { this.handleSlotStore({'!':0,'@':1,'#':2,'$':3}[e.key]); return; }
        if(e.shiftKey && isSlot) { this.handleSlotStore(parseInt(e.key)-1); return; }
        if(isSlot) { this.handleSlot(parseInt(e.key)-1); return; }

        switch(e.key) {
            // FIX: Use safeNavigate
            case 'ArrowUp': case '/': if(this.state.previewNode) this.safeNavigate(this.state.previewNode); else this.jumpDirection(-Math.PI/2); break;
            case 'ArrowDown': case '?': this.jumpDirection(Math.PI/2); break;
            case 'ArrowLeft': this.jumpDirection(Math.PI); break;
            case 'ArrowRight': this.jumpDirection(0); break;
            case '.': this.cyclePreview(1); break;
            case ',': this.cyclePreview(-1); break;
            case '=': case '+': App.Store.state.viewLayers = Math.max(1, App.Store.state.viewLayers-1); App.Renderer.adjustZoomByLayer(); break;
            case '-': case '_': App.Store.state.viewLayers = Math.min(7, App.Store.state.viewLayers+1); App.Renderer.adjustZoomByLayer(); break;
            case 'Tab': e.preventDefault(); this.createDefaultLinkedNode(); break;
            case 'n': case 'N': e.preventDefault(); this.createNode(); break;
            case 'F2': e.preventDefault(); App.UI.els.label.focus(); App.UI.els.label.select(); break;
            case ' ': e.preventDefault(); App.UI.els.label.focus(); App.UI.els.label.select(); break;
            case 'Enter': if(App.Store.state.focusNode) App.UI.Modal.show(); break;
            case 'l': case 'L': this.enterLinkMode(); break;
            case 'h': case 'H': const root = App.Store.state.nodes.find(n=>n.isRoot); if(root) this.safeNavigate(root); break;
            case 'Escape': if(this.state.linkMode.active) this.exitLinkMode(); break;
            case 'b': case 'B': this.safeNavigateBack(); break;
            case 'Delete': case 'd': case 'D': this.deleteNode(); break;
            case 'i': case 'I': e.preventDefault(); this.state.keyControlsVisible=!this.state.keyControlsVisible; document.getElementById('key-controls').style.display=this.state.keyControlsVisible?'block':'none'; break;
            case '`': e.preventDefault(); App.UI.PresetEditor.open(); break;
            case '<': App.Renderer.targetRotation += 0.05; break;
            case '>': App.Renderer.targetRotation -= 0.05; break;
        }

        // // Continuous Rotation
        // if (this.state.keyState['<']) App.Renderer.targetRotation += 0.05;
        // if (this.state.keyState['>']) App.Renderer.targetRotation -= 0.05;
    },

    // --- Complex Logic Helpers ---

    createDefaultLinkedNode() {
        const { focusNode, presets } = App.Store.state;
        if (!focusNode) return;
        // 1. è·å–ç¬¬ä¸€ä¸ªé¢„è®¾å…³ç³» (å¯¹åº” "å›è½¦é€‰æ‹©ç¬¬ä¸€ä¸ª")
        // å¦‚æœæ²¡æœ‰é¢„è®¾ï¼Œå…œåº•ä½¿ç”¨ "comp"
        const defaultPreset = presets.length > 0
            ? presets[0]
            : App.Store.DEFAULT_PRESETS[0];
        // 2. æ‰‹åŠ¨æ¿€æ´»è¿çº¿æ¨¡å¼çŠ¶æ€ (å¯¹åº” "æŒ‰L")
        // æˆ‘ä»¬ä¸éœ€è¦çœŸçš„æ‰“å¼€UIï¼Œåªéœ€è¦è®¾ç½®çŠ¶æ€ï¼Œå› ä¸º createNode ä¼šè¯»å–è¿™ä¸ªçŠ¶æ€
        if (!this.state.linkMode.active) {
            this.state.linkMode = {
                active: true,
                source: focusNode,
                type: defaultPreset.val,
                color: defaultPreset.color
            };
        }
        // 3. è°ƒç”¨åŸæœ‰çš„åˆ›å»ºé€»è¾‘ (å¯¹åº” "æŒ‰N")
        // createNode å†…éƒ¨æ£€æµ‹åˆ° linkMode.active ä¸º true æ—¶ï¼Œ
        // ä¼šè‡ªåŠ¨å»ºç«‹è¿æ¥ã€é€€å‡ºè¿çº¿æ¨¡å¼å¹¶è·³è½¬ç„¦ç‚¹
        this.createNode();
    },

    createNode() {
        const { focusNode, nodes, links, slots } = App.Store.state;
        const newNode = {
            uuid: uuid.v4(), label: t('fallback.newNode'),
            x: focusNode.x + 150, y: focusNode.y + 50,
            summary: "", content: "", color: App.Utils.getRandomColor(), alpha: 0
        };

        // If LinkMode, we skip safe check because we create a link immediately
        if (this.state.linkMode.active && this.state.linkMode.type !== 'DELETE') {
            nodes.push(newNode);
            App.Renderer.restartSim();
            this.executeLinkAction(this.state.linkMode.source, newNode);
            this.exitLinkMode();
            this.navigate(newNode, true);
            // setTimeout(() => { App.UI.els.label.focus(); App.UI.els.label.select(); }, 50);
        } else {
            // Safe Create
            const { focusNode } = App.Store.state;
            App.Store.executeSafeAction(() => ({
                nodes: [...nodes, newNode],
                links,
                nextFocus: newNode,
                nextSlots: slots
            }),  () => {
                App.Store.pushHistory(focusNode);
                // setTimeout(() => { App.UI.els.label.focus(); App.UI.els.label.select(); }, 50);
            });
        }
    },

    deleteNode(target = null) {
        const node = target || App.Store.state.focusNode;
        if(node.isRoot) { App.UI.showFlash(t('alert.rootCannotDelete'), 'warn'); return; }

        const { focusNode, navHistory, nodes, links, slots } = App.Store.state;

        let nextFocus = null;
        if (focusNode && node !== focusNode) {
            nextFocus = focusNode;
        } else {
            // --- é¢„åˆ¤ä¸‹ä¸€è·³ ---
            const backIdx = App.Store.getBackNodeIndex();

            if (backIdx >= 0) {
                // ç”¨å†å²è®°å½•çš„ UUID å»æ‰¾â€œæ´»ä½“â€èŠ‚ç‚¹ï¼Œé˜²æ­¢ä½¿ç”¨è¿‡æœŸçš„å†å²å¿«ç…§
                const uuid = navHistory[backIdx].uuid;
                nextFocus = nodes.find(n => n.uuid === uuid);
            }

            // å…œåº•é€»è¾‘
            if (!nextFocus) {
                nextFocus = nodes.find(n => n.isRoot) || nodes.find(n => n.uuid !== node.uuid);
            }
        }

        App.Store.executeSafeAction(
            () => ({
                nodes: nodes.filter(n => n.uuid !== node.uuid),
                links: links.filter(l => l.source.uuid !== node.uuid && l.target.uuid !== node.uuid),
                nextFocus: nextFocus,
                nextSlots: slots.map(s => (s && s.uuid === node.uuid) ? null : s)
            }),
            () => {
                App.Store.state.navHistory = App.Store.state.navHistory.filter(n => n.uuid !== node.uuid);
            }
        );
    },

    deleteLink(link) {
        App.Store.executeSafeAction(() => ({
            nodes: App.Store.state.nodes,
            links: App.Store.state.links.filter(l=>l!==link),
            nextFocus: App.Store.state.focusNode,
            nextSlots: App.Store.state.slots
        }));
    },

    safeNavigateBack() {
        const backIdx = App.Store.getBackNodeIndex();
        const { navHistory, nodes } = App.Store.state;

        if (backIdx >= 0) {
            const targetUUID = navHistory[backIdx].uuid;
            App.Store.state.navHistory.splice(backIdx + 1);
            const targetNode = nodes.find(n => n.uuid === targetUUID)
            if (targetNode) {
                this.safeNavigate(targetNode, false);
            }
        } else {
            App.UI.showFlash(t('flash.noHistory'), 'info');
        }
    },

    // --- Radar/Preview Logic ---

    getNeighbors() {
        const { links, focusNode } = App.Store.state;
        const list = [];
        links.forEach(l => {
            let other = null;
            if(l.source.uuid===focusNode.uuid) other = l.target;
            else if(l.target.uuid===focusNode.uuid) other = l.source;
            if(other) {
                const dx = other.x - focusNode.x, dy = other.y - focusNode.y;
                const rawAng = Math.atan2(dy, dx);
                let vAng = rawAng + App.Renderer.viewRotation;
                while(vAng > Math.PI) vAng -= 2*Math.PI; while(vAng <= -Math.PI) vAng += 2*Math.PI;
                list.push({ node: other, vAngle: vAng, rawAngle: rawAng });
            }
        });
        return list.sort((a,b) => a.vAngle - b.vAngle);
    },

    cyclePreview(dir) {
        const neighbors = this.getNeighbors();
        if(!neighbors.length) return;
        this.hideTooltip();

        const UP = -Math.PI/2;
        const THRESHOLD = 0.087; // approx 5 deg
        const exact = neighbors.find(n => Math.abs(n.vAngle - UP) < THRESHOLD);

        // Logic: Exact Top Priority
        const currentIsExact = exact && this.state.previewNode && this.state.previewNode.uuid === exact.node.uuid;

        if (exact && !currentIsExact) {
            this.setPreview(exact);
            return;
        }

        let target = null;
        if (dir > 0) { // Clockwise
            target = neighbors.find(n => n.vAngle > UP && (!exact || n.node.uuid !== exact.node.uuid));
            if (!target) target = neighbors.find(n => (!exact || n.node.uuid !== exact.node.uuid)); // Wrap
        } else { // Counter-Clockwise
            // Find last one smaller than UP
            for(let i=neighbors.length-1; i>=0; i--) {
                if(neighbors[i].vAngle < UP && (!exact || neighbors[i].node.uuid !== exact.node.uuid)) { target=neighbors[i]; break; }
            }
            if(!target) { // Wrap to end
                for(let i=neighbors.length-1; i>=0; i--) {
                    if(!exact || neighbors[i].node.uuid !== exact.node.uuid) { target=neighbors[i]; break; }
                }
            }
        }

        if(target) this.setPreview(target);
    },

    setPreview(targetWrapper) {
        this.state.previewNode = targetWrapper.node;
        App.Renderer.setTargetRotation(-Math.PI/2 - targetWrapper.rawAngle);
        const html = (typeof marked!=='undefined' ? marked.parse(this.state.previewNode.summary||'') : this.state.previewNode.summary) || '';
        this.showTooltip(t('tooltip.preview', {label: this.state.previewNode.label, summary: html}), 0, 0, 'fixed');
    },

    jumpDirection(targetAng) {
        const neighbors = this.getNeighbors();
        let best = null, minDiff = 1.2; // Threshold ~68 deg
        neighbors.forEach(n => {
            let diff = Math.abs(n.vAngle - targetAng);
            if (diff > Math.PI) diff = 2*Math.PI - diff;
            if (diff < minDiff) { minDiff = diff; best = n.node; }
        });
        if(best) this.safeNavigate(best); // FIX: safeNavigate
    },

    // --- Helpers ---

    pickNode(sx, sy) {
        const w = App.Renderer.screenToWorld(sx, sy);
        const nodes = App.Store.state.nodes;
        // Search reverse to pick top-most visually
        for(let i=nodes.length-1; i>=0; i--) {
            const n = nodes[i];
            if(n.alpha <= 0.5) continue; // Only pick visible
            const dx = n.x - w.x, dy = n.y - w.y;
            if(dx*dx + dy*dy < 600) return n; // Radius^2 approx 24
        }
        return null;
    },

    pickLink(sx, sy) {
        const w = App.Renderer.screenToWorld(sx, sy);
        const links = App.Store.state.links;
        for(let l of links) {
            if(l.alpha < 0.3) continue;
            const x1 = l.source.x, y1 = l.source.y, x2 = l.target.x, y2 = l.target.y;
            const A = x2-x1, B = y2-y1;
            const lenSq = A*A+B*B;
            let t = ((w.x-x1)*A + (w.y-y1)*B) / lenSq;
            t = Math.max(0, Math.min(1, t));
            const dist = Math.hypot(w.x - (x1+t*A), w.y - (y1+t*B));
            if(dist < 10/App.Renderer.viewK) return l;
        }
        return null;
    },

    showTooltip(html, x, y, mode) {
        const t = document.getElementById('tooltip');
        t.innerHTML = html; t.style.opacity = 1;
        if(mode==='mouse') { t.className=''; t.style.left=(x+15)+'px'; t.style.top=(y+15)+'px'; t.style.transform='none'; }
        else { t.className='fixed-mode'; }
    },
    hideTooltip() {
        const t = document.getElementById('tooltip');
        t.style.opacity=0; t.className=''; t.style.left=''; t.style.top=''; t.style.transform='';
    }
};

// ==========================================
// Main Initialization
// ==========================================
window.onload = () => {
    App.I18n.init();
    // 1. åˆå§‹åŒ– Renderer (ç¡®ä¿ simulation å­˜åœ¨)
    App.Renderer.init();
    // 2. åˆå§‹åŒ– Store (ä¼šä¾èµ– Renderer çš„æ–¹æ³•)
    App.Store.init();
    // 3. åˆå§‹åŒ– UI
    App.UI.init();
    // 4. åˆå§‹åŒ– Input (ä¼šä¾èµ– Store å’Œ Renderer çš„æ–¹æ³•)
    App.Input.init();
};

</script>
</body>
</html>